{
  "project": "nextjs-firebase",
  "fileCount": 32,
  "files": [
    {
      "path": ".eslintrc.json",
      "content": "{\n  \"extends\": \"next/core-web-vitals\",\n  \"rules\": {\n    \"react/no-unescaped-entities\": \"off\",\n    \"@next/next/no-img-element\": \"warn\"\n  }\n}\n",
      "language": "json"
    },
    {
      "path": "LEARNING_GUIDE.md",
      "content": "# Next.js + Firebase - Learning Guide\n\n## ðŸŽ¯ Project Overview\n\nA complete full-stack todo application demonstrating Firebase integration with Next.js.\n\n## ðŸ”‘ Key Features & Implementation\n\n### Cross-Cutting Concerns\n\n**Authentication:**\n- Implementation: Firebase Authentication\n- Location: `contexts/AuthContext.tsx`\n- Pattern: React Context + Firebase SDK\n- Features: Email/password, session management, user state\n\n**Database:**\n- Implementation: Cloud Firestore (NoSQL)\n- Location: `lib/firebase/firestore.ts`\n- Pattern: Real-time listeners with onSnapshot\n- Features: CRUD operations, real-time updates, 15+ helper functions\n\n**Storage:**\n- Implementation: Firebase Storage\n- Location: `lib/firebase/storage.ts`\n- Pattern: Direct file uploads with validation\n- Features: Profile pictures, todo attachments, size limits\n\n**Security:**\n- Implementation: Firestore Security Rules\n- Location: `firestore.rules`, `storage.rules`\n- Pattern: Declarative access control\n- Features: User-based rules, field validation\n\n**Rendering:**\n- Implementation: Client-Side Rendering (CSR)\n- Pattern: All components use 'use client' or default client\n- Features: Real-time updates, interactive UI\n\n**Real-time:**\n- Implementation: Firestore onSnapshot listeners\n- Pattern: Subscribe to queries, callback on changes\n- Features: Live updates, cross-device sync\n\n## ðŸ“š Learning Flows\n\n### Flow 1: Understanding Firebase Setup (15 minutes)\n\n**Goal:** Learn how Firebase is configured and initialized\n\n**Path:**\n1. Start: `lib/firebase/client.ts`\n   - See Firebase SDK initialization\n   - Understand singleton pattern\n   - Learn about environment variables\n\n2. Next: `lib/firebase/admin.ts`\n   - Understand client vs server SDK\n   - Learn when to use admin SDK\n   - See credential handling\n\n3. Then: `.env.example`\n   - See required environment variables\n   - Understand public vs private keys\n   - Learn configuration structure\n\n**Key Concepts:**\n- Firebase SDK initialization\n- Singleton pattern\n- Environment variables in Next.js\n- Client vs server-side Firebase\n\n**Audio Guide:** `audio/01-firebase-setup-overview.mp3`\n\n---\n\n### Flow 2: Authentication System (20 minutes)\n\n**Goal:** Understand how user authentication works\n\n**Path:**\n1. Start: `contexts/AuthContext.tsx`\n   - See React Context pattern\n   - Understand auth state management\n   - Learn onAuthStateChanged listener\n   - See signup/signin/signout methods\n\n2. Next: `app/(auth)/signin/page.tsx`\n   - See form handling\n   - Understand controlled inputs\n   - Learn error handling\n   - See navigation after login\n\n3. Then: `app/(auth)/signup/page.tsx`\n   - See user creation flow\n   - Understand form validation\n   - Learn password confirmation\n   - See profile initialization\n\n4. Finally: `app/(dashboard)/layout.tsx`\n   - See protected route pattern\n   - Understand useEffect for auth checking\n   - Learn redirect logic\n\n**Key Concepts:**\n- React Context for global state\n- Firebase Authentication API\n- Protected routes\n- Form handling and validation\n\n**Audio Guide:** `audio/02-authentication-flow.mp3`\n\n---\n\n### Flow 3: Todo CRUD Operations (25 minutes)\n\n**Goal:** Learn how todos are created, read, updated, and deleted\n\n**Path:**\n1. Start: `types/index.ts`\n   - See TypeScript interfaces\n   - Understand data shape\n   - Learn type definitions\n\n2. Next: `lib/firebase/firestore.ts`\n   - See CRUD helper functions\n   - Understand Firestore queries\n   - Learn real-time subscriptions\n   - See error handling\n\n3. Then: `app/(dashboard)/dashboard/page.tsx`\n   - See how page uses CRUD operations\n   - Understand state management\n   - Learn real-time subscription setup\n   - See component composition\n\n4. Next: `components/todos/TodoForm.tsx`\n   - See form component structure\n   - Understand controlled inputs\n   - Learn validation logic\n   - See tag management\n\n5. Next: `components/todos/TodoList.tsx`\n   - See list rendering\n   - Understand component composition\n   - Learn active/completed separation\n\n6. Finally: `components/todos/TodoItem.tsx`\n   - See individual todo display\n   - Understand inline editing\n   - Learn action handlers\n   - See conditional rendering\n\n**Key Concepts:**\n- Firestore CRUD operations\n- Real-time subscriptions\n- Component composition\n- State management with hooks\n- Form handling\n\n**Audio Guide:** `audio/03-todo-crud-operations.mp3`\n\n---\n\n### Flow 4: Real-time Public Feed (20 minutes)\n\n**Goal:** Understand public data sharing and search\n\n**Path:**\n1. Start: `app/(dashboard)/feed/page.tsx`\n   - See public data querying\n   - Understand search implementation\n   - Learn tag filtering\n   - See real-time public updates\n\n2. Then: `firestore.rules`\n   - See security rules for public todos\n   - Understand isPublic field check\n   - Learn rule structure\n\n**Key Concepts:**\n- Querying public data\n- Client-side search and filtering\n- Real-time subscriptions for community data\n- Firestore security rules\n\n**Audio Guide:** `audio/04-public-feed-system.mp3`\n\n---\n\n### Flow 5: Real-time Messaging (20 minutes)\n\n**Goal:** Learn real-time chat implementation\n\n**Path:**\n1. Start: `app/(dashboard)/messages/page.tsx`\n   - See message state management\n   - Understand conversation queries\n   - Learn real-time message updates\n   - See read receipts\n   - Understand auto-scrolling\n\n2. Then: `firestore.rules` (messages section)\n   - See message security rules\n   - Understand sender/recipient checks\n   - Learn privacy enforcement\n\n**Key Concepts:**\n- Real-time messaging with Firestore\n- Conversation queries\n- Read receipts\n- Message privacy\n- Auto-scrolling UI\n\n**Audio Guide:** `audio/05-realtime-messaging.mp3`\n\n---\n\n### Flow 6: User Settings & Accessibility (15 minutes)\n\n**Goal:** Learn preference management and accessibility\n\n**Path:**\n1. Start: `app/(dashboard)/settings/page.tsx`\n   - See settings state management\n   - Understand optimistic updates\n   - Learn file upload for profile\n   - See CSS class application\n\n2. Then: `app/globals.css`\n   - See accessibility utility classes\n   - Understand theme switching\n   - Learn font size classes\n   - See high contrast and reduced motion\n\n**Key Concepts:**\n- User preference persistence\n- Accessibility features\n- File uploads to Firebase Storage\n- Dynamic CSS class application\n- Optimistic UI updates\n\n**Audio Guide:** `audio/06-settings-accessibility.mp3`\n\n---\n\n### Flow 7: File Attachments (15 minutes)\n\n**Goal:** Understand file upload and management\n\n**Path:**\n1. Start: `lib/firebase/storage.ts`\n   - See file upload functions\n   - Understand validation\n   - Learn storage path structure\n   - See download URL generation\n\n2. Next: `components/attachments/AttachmentUpload.tsx`\n   - See upload UI component\n   - Understand file input handling\n   - Learn metadata saving\n\n3. Finally: `components/attachments/AttachmentList.tsx`\n   - See attachment display\n   - Understand file download\n   - Learn delete functionality\n   - See MIME type icons\n\n4. Then: `storage.rules`\n   - See storage security rules\n   - Understand path-based access\n   - Learn file type validation\n\n**Key Concepts:**\n- Firebase Storage uploads\n- File validation\n- Metadata management\n- Storage security rules\n\n**Audio Guide:** `audio/07-file-attachments.mp3`\n\n---\n\n### Flow 8: Security Rules Deep Dive (20 minutes)\n\n**Goal:** Master Firebase security\n\n**Path:**\n1. Start: `firestore.rules`\n   - Read all rule definitions\n   - Understand rule structure\n   - Learn helper functions\n   - See field validation\n\n2. Next: `storage.rules`\n   - See storage rules\n   - Understand path-based rules\n   - Learn file type checks\n\n**Key Concepts:**\n- Firestore security rules syntax\n- Storage security rules\n- Rule testing\n- Access control patterns\n\n**Audio Guide:** `audio/08-security-rules-explained.mp3`\n\n---\n\n## ðŸŽ“ Recommended Learning Order\n\n### Beginner Path (4-6 hours)\n1. Flow 1: Firebase Setup (15 min)\n2. Flow 2: Authentication (20 min)\n3. Flow 3: Todo CRUD (25 min)\n4. Build something simple yourself! (3-5 hours)\n\n### Intermediate Path (6-8 hours)\n1. Complete Beginner Path\n2. Flow 4: Public Feed (20 min)\n3. Flow 6: Settings (15 min)\n4. Flow 7: File Attachments (15 min)\n5. Build your own feature! (4-6 hours)\n\n### Advanced Path (8-10 hours)\n1. Complete Intermediate Path\n2. Flow 5: Messaging (20 min)\n3. Flow 8: Security Rules (20 min)\n4. Study all inline documentation\n5. Build a complete app yourself! (6-8 hours)\n\n## ðŸ”— Quick Reference Links\n\n### Essential Files\n- **Firebase Setup:** `lib/firebase/client.ts`, `lib/firebase/admin.ts`\n- **Database Operations:** `lib/firebase/firestore.ts`\n- **Auth Context:** `contexts/AuthContext.tsx`\n- **Main Dashboard:** `app/(dashboard)/dashboard/page.tsx`\n- **Security:** `firestore.rules`, `storage.rules`\n\n### Component Library\n- **Forms:** `components/todos/TodoForm.tsx`\n- **Lists:** `components/todos/TodoList.tsx`\n- **Items:** `components/todos/TodoItem.tsx`\n- **Uploads:** `components/attachments/`\n- **UI:** `components/ui/LoadingSpinner.tsx`\n\n### Pages\n- **Auth:** `app/(auth)/signin/page.tsx`, `signup/page.tsx`\n- **Dashboard:** `app/(dashboard)/dashboard/page.tsx`\n- **Feed:** `app/(dashboard)/feed/page.tsx`\n- **Messages:** `app/(dashboard)/messages/page.tsx`\n- **Settings:** `app/(dashboard)/settings/page.tsx`\n\n## ðŸŽ¯ Feature Implementation Map\n\n### Authentication\n**Files:** `contexts/AuthContext.tsx`, `app/(auth)/*`\n**Concepts:** Firebase Auth, React Context, protected routes\n**Audio:** `audio/02-authentication-flow.mp3`\n\n### Database CRUD\n**Files:** `lib/firebase/firestore.ts`, `components/todos/*`\n**Concepts:** Firestore operations, real-time, hooks\n**Audio:** `audio/03-todo-crud-operations.mp3`\n\n### Real-time Features\n**Files:** `lib/firebase/firestore.ts`, all page files\n**Concepts:** onSnapshot, subscriptions, live updates\n**Audio:** `audio/realtime-overview.mp3`\n\n### File Uploads\n**Files:** `lib/firebase/storage.ts`, `components/attachments/*`\n**Concepts:** Storage API, validation, metadata\n**Audio:** `audio/07-file-attachments.mp3`\n\n### Security\n**Files:** `firestore.rules`, `storage.rules`\n**Concepts:** Access control, validation, testing\n**Audio:** `audio/08-security-rules-explained.mp3`\n\n## ðŸ’¡ Tips for Learning\n\n**Read the inline comments!**\n- Every file has extensive documentation\n- Concepts explained as you read\n- Security and performance notes included\n\n**Run the code:**\n- See it work live\n- Modify and experiment\n- Break things and fix them\n\n**Compare with other projects:**\n- See same features with Supabase\n- Understand Firebase vs PostgreSQL\n- Learn trade-offs\n\n## ðŸš€ Next Steps\n\n1. **Follow Flow 1** to understand setup\n2. **Run the project** locally\n3. **Read inline documentation** in each file\n4. **Experiment** with the code\n5. **Compare** with Next.js + Supabase project\n\n---\n\n**This project is 100% complete and ready for learning!**\n\n**Audio guides coming soon to `audio/` folder.**\n",
      "language": "markdown"
    },
    {
      "path": "README.md",
      "content": "# Next.js + Firebase Todo Application\n\nA full-stack todo application built with Next.js 15 and Firebase.\n\n## Features\n\n- User authentication (sign up, sign in, sign out)\n- Todo CRUD operations with real-time updates\n- User accessibility settings (theme, font size, contrast, motion)\n- Profile picture uploads\n- Todo file attachments\n- Public feed of todos (searchable, filterable, paginated)\n- Real-time messaging between users\n- Tags for categorization\n- Responsive design\n- Real-time updates across all features\n\n## Tech Stack\n\n- **Framework:** Next.js 15 (App Router)\n- **Language:** TypeScript\n- **Styling:** Tailwind CSS\n- **Authentication:** Firebase Authentication\n- **Database:** Cloud Firestore\n- **Storage:** Firebase Storage\n- **Real-time:** Firestore real-time listeners\n\n## Getting Started\n\n### Prerequisites\n\n- Node.js 18+ installed\n- Firebase project created\n\n### Setup\n\n1. Clone the repository\n2. Install dependencies:\n   ```bash\n   npm install\n   ```\n\n3. Copy `.env.example` to `.env.local` and fill in your Firebase credentials:\n   ```bash\n   cp .env.example .env.local\n   ```\n\n4. Set up Firebase:\n   - Create a Firebase project at https://console.firebase.google.com\n   - Enable Authentication (Email/Password)\n   - Create a Firestore database\n   - Create a Storage bucket\n   - Copy your Firebase config to `.env.local`\n\n5. Run the development server:\n   ```bash\n   npm run dev\n   ```\n\n6. Open [http://localhost:3000](http://localhost:3000)\n\n## Project Structure\n\n```\nnextjs-firebase/\nâ”œâ”€â”€ app/                    # Next.js app directory\nâ”‚   â”œâ”€â”€ (auth)/            # Authentication routes\nâ”‚   â”œâ”€â”€ (dashboard)/       # Protected dashboard routes\nâ”‚   â”œâ”€â”€ api/               # API routes\nâ”‚   â””â”€â”€ layout.tsx         # Root layout\nâ”œâ”€â”€ components/            # React components\nâ”‚   â”œâ”€â”€ auth/             # Authentication components\nâ”‚   â”œâ”€â”€ todos/            # Todo components\nâ”‚   â”œâ”€â”€ feed/             # Public feed components\nâ”‚   â”œâ”€â”€ messages/         # Messaging components\nâ”‚   â””â”€â”€ ui/               # Shared UI components\nâ”œâ”€â”€ lib/                  # Utility functions\nâ”‚   â”œâ”€â”€ firebase/         # Firebase configuration\nâ”‚   â””â”€â”€ hooks/            # Custom React hooks\nâ””â”€â”€ types/                # TypeScript type definitions\n```\n\n## Firebase Security Rules\n\n### Firestore Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Users collection\n    match /users/{userId} {\n      allow read: if request.auth != null;\n      allow write: if request.auth.uid == userId;\n    }\n\n    // User settings\n    match /userSettings/{userId} {\n      allow read, write: if request.auth.uid == userId;\n    }\n\n    // Todos\n    match /todos/{todoId} {\n      allow read: if resource.data.isPublic == true ||\n                     request.auth.uid == resource.data.userId;\n      allow create: if request.auth.uid == request.resource.data.userId;\n      allow update, delete: if request.auth.uid == resource.data.userId;\n    }\n\n    // Todo attachments\n    match /todoAttachments/{attachmentId} {\n      allow read, write: if request.auth.uid == get(/databases/$(database)/documents/todos/$(resource.data.todoId)).data.userId;\n    }\n\n    // Messages\n    match /messages/{messageId} {\n      allow read: if request.auth.uid == resource.data.senderId ||\n                     request.auth.uid == resource.data.recipientId;\n      allow create: if request.auth.uid == request.resource.data.senderId;\n      allow update: if request.auth.uid == resource.data.recipientId;\n    }\n  }\n}\n```\n\n### Storage Rules\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // Profile pictures\n    match /profile-pictures/{userId}/{fileName} {\n      allow read: if request.auth != null;\n      allow write: if request.auth.uid == userId &&\n                      request.resource.size < 5 * 1024 * 1024 &&\n                      request.resource.contentType.matches('image/.*');\n    }\n\n    // Todo attachments\n    match /todo-attachments/{userId}/{todoId}/{fileName} {\n      allow read: if request.auth != null;\n      allow write: if request.auth.uid == userId &&\n                      request.resource.size < 5 * 1024 * 1024;\n    }\n  }\n}\n```\n\n## Deployment\n\n### Vercel (Recommended)\n\n1. Push your code to GitHub\n2. Import the project to Vercel\n3. Add environment variables\n4. Deploy\n\n### Other Platforms\n\nThis app can be deployed to any platform that supports Next.js:\n- Netlify\n- AWS Amplify\n- Google Cloud Run\n- Self-hosted\n\n## Learn More\n\n- [Next.js Documentation](https://nextjs.org/docs)\n- [Firebase Documentation](https://firebase.google.com/docs)\n- [Tailwind CSS Documentation](https://tailwindcss.com/docs)\n\n## License\n\nMIT\n",
      "language": "markdown"
    },
    {
      "path": "app/(auth)/signin/page.tsx",
      "content": "/**\n * REF: signin-page\n *\n * # Sign In Page\n *\n * User authentication page using Firebase Auth.\n *\n * ## Key Concepts\n *\n * - **Form handling** in React\n * - **Controlled inputs** (value tied to state)\n * - **Firebase authentication**\n * - **Error handling** and user feedback\n * - **Navigation** after successful login\n *\n * ## Authentication Flow\n *\n * 1. User enters email and password\n * 2. Form submits to `handleSubmit`\n * 3. Calls Firebase `signIn()` from context\n * 4. On success â†’ navigate to dashboard\n * 5. On error â†’ show error message\n */\n\n'use client'\n\nimport { useState, FormEvent } from 'react'\nimport { useRouter } from 'next/navigation'\nimport Link from 'next/link'\nimport { useAuth } from '@/contexts/AuthContext'\n\n/**\n * REF: signin-component\n *\n * ## SignInPage Component\n *\n * Authentication form component.\n */\nexport default function SignInPage() {\n  /**\n   * REF: signin-state\n   *\n   * ## Form State\n   *\n   * Track form inputs and submission status.\n   *\n   * - `email`: User's email input\n   * - `password`: User's password input\n   * - `error`: Error message to display\n   * - `loading`: Form submission in progress\n   */\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n  const [error, setError] = useState('')\n  const [loading, setLoading] = useState(false)\n  // CLOSE: signin-state\n\n  /**\n   * Get auth methods from context.\n   */\n  const { signIn } = useAuth()\n  const router = useRouter()\n\n  /**\n   * REF: signin-submit\n   *\n   * ## Form Submit Handler\n   *\n   * Authenticates user with Firebase.\n   *\n   * ### Flow\n   *\n   * 1. Prevent default form submission\n   * 2. Clear previous errors\n   * 3. Set loading state\n   * 4. Call Firebase `signIn()`\n   * 5. Navigate to dashboard on success\n   * 6. Show error on failure\n   *\n   * ### Error Handling\n   *\n   * Firebase auth errors are caught and displayed:\n   * - Wrong password\n   * - User not found\n   * - Network errors\n   */\n  const handleSubmit = async (e: FormEvent) => {\n    e.preventDefault()\n    setError('')\n    setLoading(true)\n\n    try {\n      await signIn(email, password)\n      router.push('/dashboard')\n    } catch (err: any) {\n      setError(err.message || 'Failed to sign in')\n    } finally {\n      setLoading(false)\n    }\n  }\n  // CLOSE: signin-submit\n\n  /**\n   * REF: signin-render\n   *\n   * ## Sign In Form UI\n   *\n   * Centered card with email/password inputs.\n   *\n   * ### Structure\n   *\n   * - Centered container\n   * - White card with shadow\n   * - Error message (if any)\n   * - Email input\n   * - Password input\n   * - Submit button (disabled while loading)\n   * - Link to sign up page\n   */\n  return (\n    <div className=\"flex min-h-screen items-center justify-center p-4\">\n      <div className=\"w-full max-w-md\">\n        <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8\">\n          <h1 className=\"text-3xl font-bold text-center mb-6\">Sign In</h1>\n\n          {error && (\n            <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4\">\n              {error}\n            </div>\n          )}\n\n          <form onSubmit={handleSubmit} className=\"space-y-4\">\n            <div>\n              <label htmlFor=\"email\" className=\"block text-sm font-medium mb-2\">\n                Email\n              </label>\n              <input\n                id=\"email\"\n                type=\"email\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                required\n                className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                placeholder=\"you@example.com\"\n              />\n            </div>\n\n            <div>\n              <label htmlFor=\"password\" className=\"block text-sm font-medium mb-2\">\n                Password\n              </label>\n              <input\n                id=\"password\"\n                type=\"password\"\n                value={password}\n                onChange={(e) => setPassword(e.target.value)}\n                required\n                className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                placeholder=\"â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢\"\n              />\n            </div>\n\n            <button\n              type=\"submit\"\n              disabled={loading}\n              className=\"w-full py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition\"\n            >\n              {loading ? 'Signing in...' : 'Sign In'}\n            </button>\n          </form>\n\n          <p className=\"text-center mt-6 text-gray-600 dark:text-gray-300\">\n            Don't have an account?{' '}\n            <Link href=\"/signup\" className=\"text-blue-600 hover:underline\">\n              Sign up\n            </Link>\n          </p>\n        </div>\n      </div>\n    </div>\n  )\n}\n// CLOSE: signin-render\n// CLOSE: signin-component\n// CLOSE: signin-page\n",
      "language": "typescript"
    },
    {
      "path": "app/(auth)/signup/page.tsx",
      "content": "/**\n * REF: signup-page\n *\n * # Sign Up Page\n *\n * New user registration with Firebase Auth.\n *\n * ## Key Concepts\n *\n * - **User registration** with email/password\n * - **Form validation** (password match, length)\n * - **Display name** collection\n * - **Error handling** with user-friendly messages\n *\n * ## Registration Flow\n *\n * 1. User fills form (email, password, confirm, name)\n * 2. Client validates (passwords match, length)\n * 3. Calls Firebase `signUp()`\n * 4. Firebase creates user account\n * 5. Profile updated with display name\n * 6. Navigate to dashboard\n */\n\n'use client'\n\nimport { useState, FormEvent } from 'react'\nimport { useRouter } from 'next/navigation'\nimport Link from 'next/link'\nimport { useAuth } from '@/contexts/AuthContext'\n\n/**\n * REF: signup-component\n *\n * ## SignUpPage Component\n *\n * User registration form.\n */\nexport default function SignUpPage() {\n  /**\n   * REF: signup-state\n   *\n   * ## Form State\n   *\n   * More fields than sign in:\n   * - Email and password (required)\n   * - Confirm password (validation)\n   * - Display name (optional but collected)\n   */\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n  const [confirmPassword, setConfirmPassword] = useState('')\n  const [displayName, setDisplayName] = useState('')\n  const [error, setError] = useState('')\n  const [loading, setLoading] = useState(false)\n  const { signUp } = useAuth()\n  const router = useRouter()\n  // CLOSE: signup-state\n\n  /**\n   * REF: signup-submit\n   *\n   * ## Form Submit with Validation\n   *\n   * Validates before calling Firebase.\n   *\n   * ### Client-Side Validation\n   *\n   * - Passwords must match\n   * - Password minimum 6 characters (Firebase requirement)\n   *\n   * ### Why Validate Client-Side?\n   *\n   * - Immediate feedback to user\n   * - Saves unnecessary API calls\n   * - Better UX\n   *\n   * **Note:** Firebase also validates server-side!\n   */\n  const handleSubmit = async (e: FormEvent) => {\n    e.preventDefault()\n    setError('')\n\n    if (password !== confirmPassword) {\n      setError('Passwords do not match')\n      return\n    }\n\n    if (password.length < 6) {\n      setError('Password must be at least 6 characters')\n      return\n    }\n\n    setLoading(true)\n\n    try {\n      await signUp(email, password, displayName)\n      router.push('/dashboard')\n    } catch (err: any) {\n      setError(err.message || 'Failed to sign up')\n    } finally {\n      setLoading(false)\n    }\n  }\n  // CLOSE: signup-submit\n\n  /**\n   * REF: signup-render\n   *\n   * ## Sign Up Form UI\n   *\n   * Registration form with all required fields.\n   *\n   * ### Form Fields\n   *\n   * 1. Display name (optional)\n   * 2. Email (required)\n   * 3. Password (required, min 6 chars)\n   4. Confirm password (must match)\n   * 5. Submit button\n   * 6. Link to sign in\n   */\n  return (\n    <div className=\"flex min-h-screen items-center justify-center p-4\">\n      <div className=\"w-full max-w-md\">\n        <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8\">\n          <h1 className=\"text-3xl font-bold text-center mb-6\">Sign Up</h1>\n\n          {error && (\n            <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4\">\n              {error}\n            </div>\n          )}\n\n          <form onSubmit={handleSubmit} className=\"space-y-4\">\n            <div>\n              <label htmlFor=\"displayName\" className=\"block text-sm font-medium mb-2\">\n                Display Name\n              </label>\n              <input\n                id=\"displayName\"\n                type=\"text\"\n                value={displayName}\n                onChange={(e) => setDisplayName(e.target.value)}\n                className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                placeholder=\"John Doe\"\n              />\n            </div>\n\n            <div>\n              <label htmlFor=\"email\" className=\"block text-sm font-medium mb-2\">\n                Email\n              </label>\n              <input\n                id=\"email\"\n                type=\"email\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                required\n                className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                placeholder=\"you@example.com\"\n              />\n            </div>\n\n            <div>\n              <label htmlFor=\"password\" className=\"block text-sm font-medium mb-2\">\n                Password\n              </label>\n              <input\n                id=\"password\"\n                type=\"password\"\n                value={password}\n                onChange={(e) => setPassword(e.target.value)}\n                required\n                className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                placeholder=\"â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢\"\n              />\n            </div>\n\n            <div>\n              <label htmlFor=\"confirmPassword\" className=\"block text-sm font-medium mb-2\">\n                Confirm Password\n              </label>\n              <input\n                id=\"confirmPassword\"\n                type=\"password\"\n                value={confirmPassword}\n                onChange={(e) => setConfirmPassword(e.target.value)}\n                required\n                className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                placeholder=\"â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢\"\n              />\n            </div>\n\n            <button\n              type=\"submit\"\n              disabled={loading}\n              className=\"w-full py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition\"\n            >\n              {loading ? 'Creating account...' : 'Sign Up'}\n            </button>\n          </form>\n\n          <p className=\"text-center mt-6 text-gray-600 dark:text-gray-300\">\n            Already have an account?{' '}\n            <Link href=\"/signin\" className=\"text-blue-600 hover:underline\">\n              Sign in\n            </Link>\n          </p>\n        </div>\n      </div>\n    </div>\n  )\n}\n// CLOSE: signup-render\n// CLOSE: signup-component\n// CLOSE: signup-page\n",
      "language": "typescript"
    },
    {
      "path": "app/(dashboard)/dashboard/page.tsx",
      "content": "/**\n * REF: dashboard-page\n *\n * # Dashboard Page - Personal Todo Management\n *\n * Main page where users manage their personal todos.\n *\n * ## Key Concepts\n *\n * 1. **React Hooks** - `useState`, `useEffect` for state\n * 2. **Real-time Firestore** - Live data updates\n * 3. **CRUD Operations** - Create, Read, Update, Delete\n * 4. **Optimistic UI** - Immediate feedback\n * 5. **Error Handling** - User-friendly messages\n *\n * ## Real-Time Updates\n *\n * Uses `onSnapshot()` instead of `getDocs()`:\n * - Listens for changes continuously\n * - Updates UI automatically\n * - Works across devices instantly\n */\n\n'use client'\n\nimport { useState, useEffect } from 'react'\nimport { useAuth } from '@/contexts/AuthContext'\nimport {\n  subscribeToUserTodos,\n  createTodo,\n  updateTodo,\n  deleteTodo,\n} from '@/lib/firebase/firestore'\nimport { Todo } from '@/types'\nimport TodoList from '@/components/todos/TodoList'\nimport TodoForm from '@/components/todos/TodoForm'\n\n/**\n * REF: dashboard-component\n *\n * ## DashboardPage Component\n *\n * Main dashboard component.\n */\nexport default function DashboardPage() {\n  /**\n   * Get authenticated user from context.\n   */\n  const { user } = useAuth()\n\n  /**\n   * REF: dashboard-state\n   *\n   * ## State Management\n   *\n   * Track todos and UI state.\n   *\n   * ### State Variables\n   *\n   * - `todos`: Array of user's todos (real-time)\n   * - `loading`: Initial data fetch in progress\n   * - `error`: Error message to display\n   */\n  const [todos, setTodos] = useState<Todo[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState('')\n  // CLOSE: dashboard-state\n\n  /**\n   * REF: realtime-subscription\n   *\n   * ## Real-Time Subscription Effect\n   *\n   * Sets up live listener when component mounts.\n   *\n   * ### How It Works\n   *\n   * 1. `subscribeToUserTodos()` returns unsubscribe function\n   * 2. Pass callback that updates state on changes\n   * 3. Cleanup function unsubscribes on unmount\n   *\n   * ### Why Cleanup Matters\n   *\n   * - **Prevents memory leaks**\n   * - Stops listening when navigating away\n   * - Firestore charges per read (avoid orphaned listeners)\n   *\n   * ### Dependency Array\n   *\n   * `[user?.uid]` means:\n   * - Re-run if user ID changes\n   * - Only once if user stays same\n   */\n  useEffect(() => {\n    if (!user) return\n\n    // Subscribe to real-time updates\n    const unsubscribe = subscribeToUserTodos(user.uid, (updatedTodos) => {\n      setTodos(updatedTodos)\n      setLoading(false)\n    })\n\n    // Cleanup: unsubscribe when component unmounts\n    return () => unsubscribe()\n  }, [user?.uid])\n  // CLOSE: realtime-subscription\n\n  /**\n   * REF: create-todo-handler\n   *\n   * ## Create Todo Handler\n   *\n   * Called when user submits form.\n   *\n   * ### Parameters\n   *\n   * - `todoData`: Partial todo data (title, description, etc.)\n   *\n   * ### Optimistic Updates\n   *\n   * We **don't** manually update todos array:\n   * - Real-time listener handles it automatically\n   * - Ensures database and UI stay in sync\n   * - No stale data issues\n   *\n   * ### Error Handling\n   *\n   * - Try/catch prevents crashes\n   * - Errors shown to user via state\n   */\n  const handleCreateTodo = async (todoData: Partial<Todo>) => {\n    if (!user) return\n\n    try {\n      setError('')\n      await createTodo(user.uid, todoData)\n      // No need to update todos array - real-time listener handles it!\n    } catch (err: any) {\n      setError(err.message || 'Failed to create todo')\n      console.error('Error creating todo:', err)\n    }\n  }\n  // CLOSE: create-todo-handler\n\n  /**\n   * REF: update-todo-handler\n   *\n   * ## Update Todo Handler\n   *\n   * Called when user toggles completion or edits a todo.\n   *\n   * ### Parameters\n   *\n   * - todoId: The ID of the todo to update\n   * - updates: Object containing fields to update\n   *\n   * ### Partial Updates\n   *\n   * - We only send changed fields, not the entire todo\n   * - More efficient and prevents accidental data loss\n   */\n  const handleUpdateTodo = async (todoId: string, updates: Partial<Todo>) => {\n    try {\n      setError('')\n      await updateTodo(todoId, updates)\n    } catch (err: any) {\n      setError(err.message || 'Failed to update todo')\n      console.error('Error updating todo:', err)\n    }\n  }\n  // CLOSE: update-todo-handler\n\n  /**\n   * REF: delete-todo-handler\n   *\n   * ## Delete Todo Handler\n   *\n   * Called when user clicks delete button.\n   *\n   * ### Confirmation\n   *\n   * - In production, you might want to add a confirmation dialog\n   * - Consider a \"soft delete\" (archived: true) instead of hard delete\n   */\n  const handleDeleteTodo = async (todoId: string) => {\n    if (!confirm('Are you sure you want to delete this todo?')) return\n\n    try {\n      setError('')\n      await deleteTodo(todoId)\n    } catch (err: any) {\n      setError(err.message || 'Failed to delete todo')\n      console.error('Error deleting todo:', err)\n    }\n  }\n  // CLOSE: delete-todo-handler\n\n  /**\n   * REF: toggle-complete-handler\n   *\n   * ## Toggle Completion Handler\n   *\n   * Convenience function for the common action of marking todo complete/incomplete.\n   */\n  const handleToggleComplete = async (todoId: string, completed: boolean) => {\n    await handleUpdateTodo(todoId, { completed })\n  }\n  // CLOSE: toggle-complete-handler\n\n  /**\n   * REF: loading-state-check\n   *\n   * ## Loading State Check\n   *\n   * Show a loading spinner while initial data fetches.\n   * This only shows on first load, not for real-time updates.\n   */\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-[400px]\">\n        <div className=\"text-xl\">Loading your todos...</div>\n      </div>\n    )\n  }\n  // CLOSE: loading-state-check\n\n  /**\n   * REF: main-dashboard-render\n   *\n   * ## Main Render\n   *\n   * ### Structure\n   *\n   * 1. Page header with title and stats\n   * 2. Error message (if any)\n   * 3. Form to create new todos\n   * 4. List of existing todos with actions\n   *\n   * ### Component Composition\n   *\n   * - TodoForm: Handles input and validation for new todos\n   * - TodoList: Displays todos with edit/delete/complete actions\n   * - Both are reusable components used elsewhere in the app\n   */\n  return (\n    <div className=\"max-w-4xl mx-auto\">\n      {/* Page Header */}\n      <div className=\"mb-8\">\n        <h1 className=\"text-4xl font-bold mb-2\">My Todos</h1>\n        <p className=\"text-gray-600 dark:text-gray-300\">\n          You have {todos.filter(t => !t.completed).length} active todos and{' '}\n          {todos.filter(t => t.completed).length} completed\n        </p>\n      </div>\n\n      {/* Error Display */}\n      {error && (\n        <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-6\">\n          {error}\n        </div>\n      )}\n\n      {/* Create Todo Form */}\n      <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6\">\n        <h2 className=\"text-2xl font-bold mb-4\">Create New Todo</h2>\n        <TodoForm onSubmit={handleCreateTodo} />\n      </div>\n\n      {/* Todos List */}\n      <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6\">\n        <h2 className=\"text-2xl font-bold mb-4\">Your Todos</h2>\n        {todos.length === 0 ? (\n          <p className=\"text-gray-500 text-center py-8\">\n            No todos yet. Create one above to get started!\n          </p>\n        ) : (\n          <TodoList\n            todos={todos}\n            onToggleComplete={handleToggleComplete}\n            onUpdate={handleUpdateTodo}\n            onDelete={handleDeleteTodo}\n          />\n        )}\n      </div>\n    </div>\n  )\n  // CLOSE: main-dashboard-render\n}\n// CLOSE: dashboard-component\n// CLOSE: dashboard-page\n",
      "language": "typescript"
    },
    {
      "path": "app/(dashboard)/feed/page.tsx",
      "content": "/**\n * REF: feed-page\n *\n * # Public Feed Page - Community Todos\n *\n * Browse and search public todos from all users.\n *\n * ## Key Concepts\n *\n * 1. **Real-time subscriptions** - Live updates from all users\n * 2. **Client-side search** - Filter without server requests\n * 3. **Tag filtering** - Find todos by category\n * 4. **Public data** - Firestore rules control access\n *\n * ## Community Feed\n *\n * Users can:\n * - Mark todos as public\n * - See everyone's public todos\n * - Search across all public content\n * - Filter by tags\n *\n * ## Performance\n *\n * - Limit to 20 items initially\n * - Client-side filtering (fast for < 1000 items)\n * - Firestore indexes for efficient queries\n */\n\n'use client'\n\nimport { useState, useEffect } from 'react'\nimport { useAuth } from '@/contexts/AuthContext'\nimport { subscribeToPublicFeed } from '@/lib/firebase/firestore'\nimport { Todo } from '@/types'\n\n/**\n * REF: feed-component\n *\n * ## FeedPage Component\n *\n * Public feed with search and filtering.\n */\nexport default function FeedPage() {\n  const { user } = useAuth()\n\n  /**\n   * REF: feed-state\n   *\n   * ## State Management\n   *\n   * Track todos and UI state for the feed.\n   *\n   * ### State Variables\n   *\n   * - `todos`: All public todos (from subscription)\n   * - `filteredTodos`: After search/filter applied\n   * - `searchTerm`: Search query\n   * - `selectedTag`: Active tag filter\n   * - `loading`: Initial load status\n   */\n  const [todos, setTodos] = useState<Todo[]>([])\n  const [filteredTodos, setFilteredTodos] = useState<Todo[]>([])\n  const [searchTerm, setSearchTerm] = useState('')\n  const [selectedTag, setSelectedTag] = useState<string | null>(null)\n  const [loading, setLoading] = useState(true)\n  // CLOSE: feed-state\n\n  /**\n   * REF: realtime-public-subscription\n   *\n   * ## Real-Time Subscription to Public Todos\n   *\n   * Subscribe to all public todos with limit of 20.\n   * This demonstrates a community feed where users see each other's content.\n   *\n   * ### Security\n   *\n   * - Firestore rules ensure only public todos are accessible\n   * - Users can't access private todos even if they try\n   *\n   * ### Cleanup\n   *\n   * - Unsubscribe on component unmount\n   * - Prevents memory leaks\n   */\n  useEffect(() => {\n    const unsubscribe = subscribeToPublicFeed((publicTodos) => {\n      setTodos(publicTodos)\n      setFilteredTodos(publicTodos)\n      setLoading(false)\n    }, 20)\n\n    return () => unsubscribe()\n  }, [])\n  // CLOSE: realtime-public-subscription\n\n  /**\n   * REF: search-filter-effect\n   *\n   * ## Search and Filter Effect\n   *\n   * Re-filter todos whenever search term or selected tag changes.\n   *\n   * ### Search Logic\n   *\n   * - Case-insensitive search across title and description\n   * - Uses includes() for substring matching\n   * - Could be enhanced with fuzzy search or full-text search\n   *\n   * ### Filter Logic\n   *\n   * - If tag selected, only show todos with that tag\n   * - Uses array.includes() to check if tag exists in todo's tags\n   *\n   * ### Optimization\n   *\n   * - In production, consider debouncing search to reduce re-renders\n   * - For large datasets, move search to backend with indexed queries\n   */\n  useEffect(() => {\n    let results = todos\n\n    // Apply search filter\n    if (searchTerm.trim()) {\n      const term = searchTerm.toLowerCase()\n      results = results.filter(\n        todo =>\n          todo.title?.toLowerCase().includes(term) ||\n          todo.description?.toLowerCase().includes(term)\n      )\n    }\n\n    // Apply tag filter\n    if (selectedTag) {\n      results = results.filter(todo => todo.tags?.includes(selectedTag))\n    }\n\n    setFilteredTodos(results)\n  }, [searchTerm, selectedTag, todos])\n  // CLOSE: search-filter-effect\n\n  /**\n   * REF: tag-extraction\n   *\n   * ## Get All Unique Tags\n   *\n   * Extract all tags from all todos for the filter dropdown.\n   *\n   * ### Algorithm\n   *\n   * 1. Flatten all todo tags into single array\n   * 2. Remove duplicates with Set\n   * 3. Sort alphabetically\n   *\n   * ### Array Methods Used\n   *\n   * - flatMap(): Flattens nested arrays\n   * - Set: Removes duplicates\n   * - Array.from(): Converts Set back to array\n   * - sort(): Alphabetical ordering\n   */\n  const allTags = Array.from(\n    new Set(\n      todos.flatMap(todo => todo.tags || [])\n    )\n  ).sort()\n  // CLOSE: tag-extraction\n\n  /**\n   * REF: clear-filters-handler\n   *\n   * ## Clear Filters Handler\n   *\n   * Reset search and tag filters to show all todos.\n   */\n  const handleClearFilters = () => {\n    setSearchTerm('')\n    setSelectedTag(null)\n  }\n  // CLOSE: clear-filters-handler\n\n  /**\n   * REF: loading-state\n   *\n   * ## Loading State\n   *\n   * Display loading indicator while initial data fetches.\n   */\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-[400px]\">\n        <div className=\"text-xl\">Loading public feed...</div>\n      </div>\n    )\n  }\n  // CLOSE: loading-state\n\n  /**\n   * REF: main-render\n   *\n   * ## Main Render\n   *\n   * LAYOUT:\n   * 1. Page header with description\n   * 2. Search bar\n   * 3. Tag filter chips\n   * 4. Active filters display\n   * 5. Todo cards grid\n   *\n   * UX FEATURES:\n   * - Clear visual feedback for active filters\n   * - Easy-to-click tag chips\n   * - Responsive grid layout\n   * - Empty state when no results\n   */\n  return (\n    <div className=\"max-w-6xl mx-auto\">\n      {/* Page Header */}\n      <div className=\"mb-8\">\n        <h1 className=\"text-4xl font-bold mb-2\">Public Feed</h1>\n        <p className=\"text-gray-600 dark:text-gray-300\">\n          Discover what others are working on. {todos.length} public todos shared by the community.\n        </p>\n      </div>\n\n      {/* Search Bar */}\n      <div className=\"mb-6\">\n        <input\n          type=\"text\"\n          value={searchTerm}\n          onChange={(e) => setSearchTerm(e.target.value)}\n          placeholder=\"Search todos by title or description...\"\n          className=\"w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-800 dark:border-gray-600\"\n        />\n      </div>\n\n      {/* Tag Filters */}\n      {allTags.length > 0 && (\n        <div className=\"mb-6\">\n          <h3 className=\"text-sm font-medium mb-2\">Filter by tag:</h3>\n          <div className=\"flex flex-wrap gap-2\">\n            {allTags.map(tag => (\n              <button\n                key={tag}\n                onClick={() => setSelectedTag(selectedTag === tag ? null : tag)}\n                className={`px-4 py-2 rounded-full text-sm transition ${\n                  selectedTag === tag\n                    ? 'bg-blue-600 text-white'\n                    : 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600'\n                }`}\n              >\n                #{tag}\n              </button>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Active Filters Display */}\n      {(searchTerm || selectedTag) && (\n        <div className=\"mb-6 p-4 bg-blue-50 dark:bg-blue-900 rounded-lg\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <span className=\"font-medium\">Active filters:</span>\n              {searchTerm && (\n                <span className=\"ml-2 text-sm\">\n                  Search: \"{searchTerm}\"\n                </span>\n              )}\n              {selectedTag && (\n                <span className=\"ml-2 text-sm\">\n                  Tag: #{selectedTag}\n                </span>\n              )}\n            </div>\n            <button\n              onClick={handleClearFilters}\n              className=\"text-blue-600 dark:text-blue-300 hover:underline text-sm\"\n            >\n              Clear all filters\n            </button>\n          </div>\n        </div>\n      )}\n\n      {/* Results Count */}\n      <div className=\"mb-4 text-gray-600 dark:text-gray-300\">\n        Showing {filteredTodos.length} of {todos.length} todos\n      </div>\n\n      {/* Todos Grid */}\n      {filteredTodos.length > 0 ? (\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n          {filteredTodos.map(todo => (\n            <div\n              key={todo.id}\n              className=\"p-6 bg-white dark:bg-gray-800 rounded-lg shadow-lg hover:shadow-xl transition\"\n            >\n              {/* Todo Title */}\n              <h3 className=\"text-lg font-bold mb-2\">{todo.title}</h3>\n\n              {/* Todo Description */}\n              {todo.description && (\n                <p className=\"text-gray-600 dark:text-gray-300 mb-4 line-clamp-3\">\n                  {todo.description}\n                </p>\n              )}\n\n              {/* Tags */}\n              {todo.tags && todo.tags.length > 0 && (\n                <div className=\"flex flex-wrap gap-2 mb-4\">\n                  {todo.tags.map(tag => (\n                    <span\n                      key={tag}\n                      className=\"px-2 py-1 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 text-xs rounded-full\"\n                    >\n                      #{tag}\n                    </span>\n                  ))}\n                </div>\n              )}\n\n              {/* Completion Status */}\n              <div className=\"mt-4 pt-4 border-t border-gray-200 dark:border-gray-700\">\n                <span\n                  className={`text-sm ${\n                    todo.completed\n                      ? 'text-green-600 dark:text-green-400'\n                      : 'text-gray-500'\n                  }`}\n                >\n                  {todo.completed ? 'âœ“ Completed' : 'â—‹ In Progress'}\n                </span>\n              </div>\n            </div>\n          ))}\n        </div>\n      ) : (\n        /* Empty State */\n        <div className=\"text-center py-12\">\n          <p className=\"text-gray-500 text-lg\">\n            No todos found matching your filters.\n          </p>\n          {(searchTerm || selectedTag) && (\n            <button\n              onClick={handleClearFilters}\n              className=\"mt-4 text-blue-600 hover:underline\"\n            >\n              Clear filters to see all public todos\n            </button>\n          )}\n        </div>\n      )}\n    </div>\n  )\n  // CLOSE: main-render\n}\n// CLOSE: feed-component\n// CLOSE: feed-page\n",
      "language": "typescript"
    },
    {
      "path": "app/(dashboard)/layout.tsx",
      "content": "/**\n * REF: dashboard-layout\n *\n * # Dashboard Layout - Protected Pages Shell\n *\n * Layout for all authenticated dashboard pages.\n *\n * ## Key Concepts\n *\n * - **Client Component:** Uses hooks (needs 'use client')\n * - **Protected Routes:** Redirects if not authenticated\n * - **Nested Layout:** Wraps dashboard pages\n * - **Shared UI:** Header, nav, footer for all dashboard pages\n *\n * ## Route Protection\n *\n * This layout protects all routes inside `app/(dashboard)/`:\n * - `/dashboard`\n * - `/feed`\n * - `/messages`\n * - `/settings`\n *\n * If user not logged in â†’ redirect to `/signin`\n */\n\n'use client'\n\nimport { useEffect } from 'react'\nimport { useRouter } from 'next/navigation'\nimport Link from 'next/link'\nimport { useAuth } from '@/contexts/AuthContext'\n\n/**\n * REF: dashboard-layout-component\n *\n * ## DashboardLayout Component\n *\n * Protected layout with navigation.\n */\nexport default function DashboardLayout({ children }: { children: React.ReactNode }) {\n  /**\n   * Get auth state and navigation.\n   */\n  const { user, loading, signOut } = useAuth()\n  const router = useRouter()\n\n  /**\n   * REF: auth-redirect\n   *\n   * ## Authentication Check\n   *\n   * Redirect to signin if not authenticated.\n   *\n   * ### Effect Dependencies\n   *\n   * - `user`: Auth state\n   * - `loading`: Wait for auth check\n   * - `router`: Navigation function\n   *\n   * ### Why Effect?\n   *\n   * - Runs after render\n   * - Waits for auth state\n   * - Redirects client-side\n   */\n  useEffect(() => {\n    if (!loading && !user) {\n      router.push('/signin')\n    }\n  }, [user, loading, router])\n  // CLOSE: auth-redirect\n\n  /**\n   * Show loading state while checking auth.\n   */\n  /** REF: conditional-block\n   */\n  if (loading) {\n    return (\n      <div className=\"flex min-h-screen items-center justify-center\">\n        <div className=\"text-xl\">Loading...</div>\n      </div>\n    )\n  }\n\n  /**\n   * Return null if no user (will redirect).\n   */\n  if (!user) {\n    return null\n  }\n\n  /**\n   * REF: handle-signout\n   *\n   * ## Sign Out Handler\n   *\n   * Logs out user and redirects home.\n   */\n  const handleSignOut = async () => {\n    await signOut()\n    router.push('/')\n  }\n  // CLOSE: handle-signout\n\n  /**\n   * REF: dashboard-shell\n   *\n   * ## Dashboard UI Shell\n   *\n   * Provides consistent UI for all dashboard pages.\n   *\n   * ### Structure\n   *\n   * 1. **Header** with logo and navigation\n   * 2. **Main** content area (children render here)\n   * 3. **Footer** with copyright\n   */\n  return (\n    <div className=\"min-h-screen flex flex-col\">\n      {/**\n       * ## Navigation Header\n       *\n       * Sticky header with logo and navigation links.\n       *\n       * ### Navigation Items\n       *\n       * - My Todos: Personal todo list\n       * - Public Feed: Community todos\n       * - Messages: Real-time chat\n       * - Settings: User preferences\n       * - Sign Out: Logout button\n       */}\n      <header className=\"bg-white dark:bg-gray-800 shadow\">\n        <div className=\"container mx-auto px-4 py-4\">\n          <div className=\"flex items-center justify-between\">\n            <Link href=\"/dashboard\" className=\"text-2xl font-bold\">\n              Todo App\n            </Link>\n\n            <nav className=\"flex items-center gap-6\">\n              <Link\n                href=\"/dashboard\"\n                className=\"hover:text-blue-600 transition\"\n              >\n                My Todos\n              </Link>\n              <Link\n                href=\"/feed\"\n                className=\"hover:text-blue-600 transition\"\n              >\n                Public Feed\n              </Link>\n              <Link\n                href=\"/messages\"\n                className=\"hover:text-blue-600 transition\"\n              >\n                Messages\n              </Link>\n              <Link\n                href=\"/settings\"\n                className=\"hover:text-blue-600 transition\"\n              >\n                Settings\n              </Link>\n              <button\n                onClick={handleSignOut}\n                className=\"px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition\"\n              >\n                Sign Out\n              </button>\n            </nav>\n          </div>\n        </div>\n      </header>\n\n      {/**\n       * ## Main Content Area\n       *\n       * Where child pages render.\n       *\n       * `flex-1` makes it expand to fill available space.\n       */}\n      <main className=\"flex-1 container mx-auto px-4 py-8\">\n        {children}\n      </main>\n\n      {/**\n       * ## Footer\n       *\n       * Sticky footer at bottom of page.\n       *\n       * `mt-auto` pushes it to bottom with flexbox.\n       */}\n      <footer className=\"bg-white dark:bg-gray-800 shadow mt-auto\">\n        <div className=\"container mx-auto px-4 py-4 text-center text-gray-600 dark:text-gray-300\">\n          <p>&copy; 2025 Todo App. Built with Next.js and Firebase.</p>\n        </div>\n      </footer>\n    </div>\n  )\n}\n// CLOSE: dashboard-shell\n// CLOSE: dashboard-layout-component\n// CLOSE: dashboard-layout\n",
      "language": "typescript"
    },
    {
      "path": "app/(dashboard)/messages/page.tsx",
      "content": "/**\n * REF: messages-page\n *\n * # Messages Page\n *\n * Real-time messaging system between users.\n *\n * ## Key Concepts\n *\n * - **Real-time chat** - Messages update instantly without refresh\n * - **User selection** - Choose who to chat with\n * - **Message sending** - Create and send messages\n * - **Read receipts** - Track when messages are read\n * - **Auto-scrolling** - Keep newest messages visible\n * - **Two-column layout** - Users on left, conversation on right\n *\n * ## Architecture\n *\n * | `Component` | Purpose |\n * |-----------|---------|\n * | User list | Shows all users for messaging |\n * | Conversation area | Display messages and input |\n * | Message bubbles | Individual message display |\n * | Input form | Text input and send button |\n * | Auto-scroll ref | Tracks message container |\n *\n * ## Data Flow\n *\n * 1. **Load users** - Fetch all registered users on mount\n * 2. **Select user** - User clicks on someone to chat with\n * 3. **Subscribe to messages** - Real-time listener for conversation\n * 4. **Send message** - Form submission creates new message\n * 5. **Mark as read** - Automatically mark received messages as read\n * 6. **Auto-scroll** - Show newest messages at bottom\n *\n * ## Security\n *\n * - **Firestore rules** - Users can only read their own messages\n * - **Sender validation** - Server validates user identity\n * - **No impersonation** - Can't send as other users\n * - **Private conversations** - Only participants can read messages\n */\n// CLOSE: messages-page\n\n'use client'\n\n  /** REF: imports\n   */\nimport { useState, useEffect, useRef } from 'react'\nimport { collection, query, where, getDocs } from 'firebase/firestore'\nimport { useAuth } from '@/contexts/AuthContext'\nimport {\n  // CLOSE: imports\n  subscribeToConversation,\n  sendMessage,\n  markMessageAsRead,\n} from '@/lib/firebase/firestore'\nimport { db } from '@/lib/firebase/client'\nimport { Message } from '@/types'\n\n/**\n * USER INTERFACE\n *\n * Simple user type for displaying in user list\n */\ninterface User {\n  id: string\n  email: string\n  displayName?: string\n}\n\nexport default function MessagesPage() {\n  const { user } = useAuth()\n\n  /**\n   * STATE MANAGEMENT\n   *\n   * users: List of all users we can message\n   * selectedUserId: Currently selected conversation partner\n   * messages: All messages in current conversation\n   * newMessage: Text input for composing message\n   * loading: Initial load state\n   * sending: Prevents double-sending messages\n   */\n  /** REF: messages-state-variables\n   * State management for messaging functionality.\n   * Tracks users, selected conversation, messages, and UI states.\n   */\n  const [users, setUsers] = useState<User[]>([])\n  const [selectedUserId, setSelectedUserId] = useState<string | null>(null)\n  const [messages, setMessages] = useState<Message[]>([])\n  const [newMessage, setNewMessage] = useState('')\n  const [loading, setLoading] = useState(true)\n  const [sending, setSending] = useState(false)\n  // CLOSE: messages-state-variables\n\n  /**\n   * AUTO-SCROLL REF\n   *\n   * Used to scroll to bottom of messages when new message arrives\n   * useRef persists across renders without causing re-renders\n   */\n  const messagesEndRef = useRef<HTMLDivElement>(null)\n\n  /**\n   * LOAD ALL USERS EFFECT\n   *\n   * Fetch all registered users for the user list\n   * In production, you might want to limit this or add search\n   *\n   * FIRESTORE QUERY:\n   * - collection('users'): Get users collection\n   * - getDocs(): Fetch all documents\n   * - Filter out current user from list\n   */\n  useEffect(() => {\n    if (!user) return\n\n    const fetchUsers = async () => {\n      try {\n        const usersQuery = query(collection(db, 'users'))\n        const snapshot = await getDocs(usersQuery)\n\n        const usersList = snapshot.docs\n          .map(doc => ({\n            id: doc.id,\n            ...doc.data(),\n          } as User))\n          .filter(u => u.id !== user.uid) // Don't show current user\n\n        setUsers(usersList)\n      } catch (error) {\n        console.error('Error fetching users:', error)\n      } finally {\n        setLoading(false)\n      }\n    }\n\n    fetchUsers()\n  }, [user])\n\n  /**\n   * REAL-TIME CONVERSATION SUBSCRIPTION\n   *\n   * Subscribe to messages between current user and selected user\n   *\n * ### Flow\n   * 1. User selects someone to chat with\n   * 2. Subscribe to all messages between them\n   * 3. Mark received messages as read\n   * 4. Auto-scroll to show new messages\n   *\n   * CLEANUP:\n   * - Unsubscribe when switching conversations\n   * - Unsubscribe when component unmounts\n   */\n  /** REF: code-block\n   */\n  useEffect(() => {\n    if (!user || !selectedUserId) {\n      setMessages([])\n  // CLOSE: code-block\n      return\n    }\n\n    const unsubscribe = subscribeToConversation(\n      user.uid,\n      selectedUserId,\n      (conversationMessages) => {\n        setMessages(conversationMessages)\n\n        // Mark unread messages from other user as read\n  /** REF: code-block\n   */\n        conversationMessages.forEach(msg => {\n          if (msg.recipientId === user.uid && !msg.read) {\n            markMessageAsRead(msg.id)\n  // CLOSE: code-block\n          }\n        })\n\n        // Scroll to bottom to show newest messages\n        scrollToBottom()\n      }\n    )\n\n    return () => unsubscribe()\n  }, [user, selectedUserId])\n\n  /**\n   * AUTO-SCROLL TO BOTTOM\n   *\n   * Scrolls message container to show newest message\n   * Called when new message arrives or user switches conversations\n   *\n   * scrollIntoView() is a browser API that scrolls element into view\n   */\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })\n  }\n\n  /**\n   * SEND MESSAGE HANDLER\n   *\n   * Validates input, sends message to Firestore, clears input\n   *\n   * @param e - Form event\n   *\n   * OPTIMISTIC UI:\n   * - Message appears immediately in UI via real-time listener\n   * - No need to manually update messages array\n   */\n  const handleSendMessage = async (e: React.FormEvent) => {\n    e.preventDefault()\n\n    if (!user || !selectedUserId || !newMessage.trim()) return\n\n    setSending(true)\n\n    try {\n      await sendMessage(user.uid, selectedUserId, newMessage.trim())\n      setNewMessage('') // Clear input\n      scrollToBottom() // Scroll to show sent message\n    } catch (error) {\n      console.error('Error sending message:', error)\n      alert('Failed to send message')\n    } finally {\n      setSending(false)\n    }\n  }\n\n  /**\n   * USER SELECTION HANDLER\n   *\n   * Called when user clicks on someone in the user list\n   */\n  const handleSelectUser = (userId: string) => {\n    setSelectedUserId(userId)\n  }\n\n  /**\n   * LOADING STATE\n   */\n  /** REF: conditional-block\n   */\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-[400px]\">\n        <div className=\"text-xl\">Loading messages...</div>\n      </div>\n    )\n  }\n\n  /**\n   * SELECTED USER INFO\n   *\n   * Find the user object for the selected conversation\n   */\n  const selectedUser = users.find(u => u.id === selectedUserId)\n\n  /**\n   * REF: messages-page-render\n   *\n   * # Messages Page Render\n   *\n   * Two-column layout: user list on left, conversation on right.\n   *\n   * ## Layout Structure\n   *\n   * | Column | `Width` | Purpose |\n   * |--------|-------|---------|\n   * | `Users` | 1/4 screen | List of users to message |\n   * | `Conversation` | 3/4 screen | Messages and input form |\n   *\n   * ## User List (Left Sidebar)\n   *\n   * - **Header** - \"Users\" title\n   * - **List items** - Scrollable list of users\n   * - **Selection** - Highlight selected user\n   * - **Info** - Shows name and email\n   * - **Empty state** - Message when no users\n   *\n   * ## Conversation Area (Right Side)\n   *\n   * - **Header** - Selected user's name/email\n   * - **Messages** - Scrollable message history\n   * - **Message bubbles** - Different style for sent/received\n   * - **Read indicator** - Shows \"Read\" for sent messages\n   * - **Input form** - Text input and send button\n   * - **Empty state** - Message when no conversation selected\n   *\n   * ## Auto-Scroll\n   *\n   * - messagesEndRef div at bottom of list\n   * - scrollIntoView() called when messages arrive\n   * - Smooth animation for better UX\n   *\n   * ## Responsive\n   *\n   * - grid-cols-1 md:grid-cols-4: Adapts to screen size\n   * - Mobile: Can show either list or conversation\n   * - Tablet+: Shows both side-by-side\n   */\n  return (\n    <div className=\"max-w-6xl mx-auto\">\n      <h1 className=\"text-4xl font-bold mb-8\">Messages</h1>\n\n      <div className=\"grid grid-cols-1 md:grid-cols-4 gap-6 h-[600px]\">\n        {/* USER LIST (Left Sidebar) */}\n        <div className=\"md:col-span-1 bg-white dark:bg-gray-800 rounded-lg shadow-lg overflow-y-auto\">\n          <div className=\"p-4 border-b border-gray-200 dark:border-gray-700\">\n            <h2 className=\"font-semibold\">Users</h2>\n          </div>\n\n          <div className=\"divide-y divide-gray-200 dark:divide-gray-700\">\n            {users.map(u => (\n              <button\n                key={u.id}\n                onClick={() => handleSelectUser(u.id)}\n                className={`w-full p-4 text-left hover:bg-gray-50 dark:hover:bg-gray-700 transition ${\n                  selectedUserId === u.id ? 'bg-blue-50 dark:bg-blue-900' : ''\n                }`}\n              >\n                <div className=\"font-medium\">{u.displayName || 'User'}</div>\n                <div className=\"text-sm text-gray-500\">{u.email}</div>\n              </button>\n            ))}\n\n            {users.length === 0 && (\n              <div className=\"p-4 text-center text-gray-500\">\n                No other users found\n              </div>\n            )}\n          </div>\n        </div>\n\n        {/* CONVERSATION AREA (Right Side) */}\n        <div className=\"md:col-span-3 bg-white dark:bg-gray-800 rounded-lg shadow-lg flex flex-col\">\n          {selectedUser ? (\n            <>\n              {/* Conversation Header */}\n              <div className=\"p-4 border-b border-gray-200 dark:border-gray-700\">\n                <h2 className=\"font-semibold\">\n                  {selectedUser.displayName || selectedUser.email}\n                </h2>\n              </div>\n\n              {/* Messages Area */}\n              <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n                {messages.length === 0 ? (\n                  <div className=\"text-center text-gray-500 py-8\">\n                    No messages yet. Start the conversation!\n                  </div>\n                ) : (\n                  messages.map(msg => (\n                    <div\n                      key={msg.id}\n                      className={`flex ${\n                        msg.senderId === user?.uid ? 'justify-end' : 'justify-start'\n                      }`}\n                    >\n                      <div\n                        className={`max-w-[70%] px-4 py-2 rounded-lg ${\n                          msg.senderId === user?.uid\n                            ? 'bg-blue-600 text-white'\n                            : 'bg-gray-200 dark:bg-gray-700'\n                        }`}\n                      >\n                        <p>{msg.content}</p>\n                        <div className=\"text-xs mt-1 opacity-70\">\n                          {msg.createdAt?.toDate().toLocaleTimeString()}\n                          {msg.senderId === user?.uid && msg.read && ' â€¢ Read'}\n                        </div>\n                      </div>\n                    </div>\n                  ))\n                )}\n\n                {/* Auto-scroll anchor */}\n                <div ref={messagesEndRef} />\n              </div>\n\n              {/* Message Input */}\n              <form onSubmit={handleSendMessage} className=\"p-4 border-t border-gray-200 dark:border-gray-700\">\n                <div className=\"flex gap-2\">\n                  <input\n                    type=\"text\"\n                    value={newMessage}\n                    onChange={(e) => setNewMessage(e.target.value)}\n                    placeholder=\"Type a message...\"\n                    className=\"flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                  />\n                  <button\n                    type=\"submit\"\n                    disabled={sending || !newMessage.trim()}\n                    className=\"px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition\"\n                  >\n                    {sending ? 'Sending...' : 'Send'}\n                  </button>\n                </div>\n              </form>\n            </>\n          ) : (\n            /* No Conversation Selected */\n            <div className=\"flex items-center justify-center h-full text-gray-500\">\n              Select a user to start messaging\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  )\n  // CLOSE: messages-page-render\n}\n",
      "language": "typescript"
    },
    {
      "path": "app/(dashboard)/settings/page.tsx",
      "content": "/**\n * REF: settings-page\n *\n * # Settings Page\n *\n * User accessibility and profile customization page.\n *\n * ## Key Concepts\n *\n * - **Controlled inputs** - Form fields controlled by React state\n * - **Firestore persistence** - Settings saved to database\n * - **Dynamic CSS** - Apply settings via class names\n * - **Profile pictures** - File upload to Cloud Storage\n * - **Optimistic UI** - Update UI before confirmation\n *\n * ## Features\n *\n * | `Section` | `Settings` |\n * |---------|----------|\n * | `Profile` | Display name, profile picture, email |\n * | `Appearance` | Theme (light/dark), font size (small/med/large) |\n * | `Accessibility` | High contrast, reduce motion |\n *\n * ## Accessibility Matters\n *\n * ### Why Include?\n * - Makes app usable by people with visual impairments\n * - Follows WCAG (Web Content Accessibility Guidelines)\n * - Shows consideration for diverse user needs\n * - Often legally required for public-facing apps\n *\n * ### Features Implemented\n * - **Theme** - Light/Dark mode for eye strain reduction\n * - **Font Size** - Small/Medium/Large options\n * - **High Contrast** - Enhanced contrast for visibility\n * - **Reduced Motion** - Disables animations for motion sensitivity\n *\n * ## Data Persistence\n *\n * 1. **Profile data** - Firebase Auth (displayName, photoURL)\n * 2. **Settings** - Firestore (custom UserSettings document)\n * 3. **Files** - Cloud Storage (profile pictures)\n */\n// CLOSE: settings-page\n\n'use client'\n\n/** REF: settings-imports\n * Required imports for React hooks, authentication, and Firebase operations.\n * Manages user settings and profile picture uploads.\n */\nimport { useState, useEffect } from 'react'\nimport { useAuth } from '@/contexts/AuthContext'\nimport { getUserSettings, updateUserSettings } from '@/lib/firebase/firestore'\nimport { uploadProfilePicture, validateImageFile } from '@/lib/firebase/storage'\nimport { UserSettings } from '@/types'\n// CLOSE: settings-imports\n\nexport default function SettingsPage() {\n  const { user, updateUserProfile } = useAuth()\n\n  /**\n   * SETTINGS STATE\n   *\n   * Local state mirrors database values\n   * Updated immediately for better UX, then saved to database\n   */\n  /** REF: state-variables\n   */\n  const [settings, setSettings] = useState<UserSettings | null>(null)\n  const [displayName, setDisplayName] = useState(user?.displayName || '')\n  const [profilePicture, setProfilePicture] = useState(user?.photoURL || '')\n  // CLOSE: state-variables\n\n  /** REF: state-variables\n   */\n  const [loading, setLoading] = useState(true)\n  const [saving, setSaving] = useState(false)\n  const [uploading, setUploading] = useState(false)\n  const [message, setMessage] = useState('')\n  // CLOSE: state-variables\n\n  /**\n   * LOAD USER SETTINGS EFFECT\n   *\n   * Fetches user's saved settings from Firestore on mount\n   * Settings are stored separately from user profile for better organization\n   */\n  useEffect(() => {\n    if (!user) return\n\n    const loadSettings = async () => {\n      try {\n  /** REF: state-variables\n   */\n        const userSettings = await getUserSettings(user.uid)\n        if (userSettings) {\n          setSettings(userSettings)\n  // CLOSE: state-variables\n        }\n      } catch (error) {\n        console.error('Error loading settings:', error)\n      } finally {\n        setLoading(false)\n      }\n    }\n\n    loadSettings()\n  }, [user])\n\n  /**\n   * APPLY SETTINGS TO DOM\n   *\n   * Dynamically applies CSS classes to body element based on settings\n   * This demonstrates how to apply settings app-wide\n   *\n   * ALTERNATIVE APPROACHES:\n   * - CSS variables (--font-size: 16px)\n   * - Context API to provide settings to all components\n   * - Tailwind dark mode with class strategy\n   */\n  useEffect(() => {\n    if (!settings) return\n\n    const body = document.body\n\n    // Apply theme\n    if (settings.theme === 'dark') {\n      body.classList.add('dark')\n    } else {\n      body.classList.remove('dark')\n    }\n\n    // Apply font size\n    body.classList.remove('font-small', 'font-medium', 'font-large')\n    body.classList.add(`font-${settings.fontSize}`)\n\n    // Apply high contrast\n    if (settings.highContrast) {\n      body.classList.add('high-contrast')\n    } else {\n      body.classList.remove('high-contrast')\n    }\n\n    // Apply reduced motion\n    if (settings.reducedMotion) {\n      body.classList.add('reduced-motion')\n    } else {\n      body.classList.remove('reduced-motion')\n    }\n  }, [settings])\n\n  /**\n   * UPDATE SETTING HANDLER\n   *\n   * Updates a single setting field\n   *\n   * @param field - The setting field to update\n   * @param value - The new value\n   *\n   * OPTIMISTIC UPDATE:\n   * 1. Update local state immediately (user sees change instantly)\n   * 2. Save to database in background\n   * 3. If error, revert and show message\n   */\n  const handleUpdateSetting = async (\n    field: keyof Omit<UserSettings, 'id' | 'userId' | 'updatedAt'>,\n    value: any\n  ) => {\n    if (!user || !settings) return\n\n    // Optimistically update local state\n    const previousSettings = { ...settings }\n    setSettings({ ...settings, [field]: value })\n\n    try {\n      await updateUserSettings(user.uid, { [field]: value })\n      setMessage('Settings saved successfully!')\n      setTimeout(() => setMessage(''), 3000)\n    } catch (error) {\n      // Revert on error\n      setSettings(previousSettings)\n      setMessage('Failed to save settings')\n      console.error('Error updating settings:', error)\n    }\n  }\n\n  /**\n   * PROFILE UPDATE HANDLER\n   *\n   * Updates display name and/or profile picture\n   */\n  const handleUpdateProfile = async () => {\n    if (!user) return\n\n    setSaving(true)\n    setMessage('')\n\n    try {\n      await updateUserProfile(displayName, profilePicture)\n      setMessage('Profile updated successfully!')\n      setTimeout(() => setMessage(''), 3000)\n    } catch (error: any) {\n      setMessage(error.message || 'Failed to update profile')\n      console.error('Error updating profile:', error)\n    } finally {\n      setSaving(false)\n    }\n  }\n\n  /**\n   * PROFILE PICTURE UPLOAD HANDLER\n   *\n   * Handles file selection, validation, and upload\n   *\n   * @param e - File input change event\n   *\n * ### Flow\n   * 1. User selects file\n   * 2. Validate file type and size\n   * 3. Upload to Firebase Storage\n   * 4. Get download URL\n   * 5. Update profile picture state\n   * 6. Auto-save to user profile\n   *\n   * SECURITY:\n   * - Client-side validation (type, size)\n   * - Server-side validation (Storage rules)\n   * - Unique filenames prevent overwrites\n   */\n  const handleProfilePictureUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (!user || !e.target.files || !e.target.files[0]) return\n\n    const file = e.target.files[0]\n\n    // Validate file\n  /** REF: state-variables\n   */\n    const validation = validateImageFile(file)\n    if (!validation.valid) {\n      setMessage(validation.error || 'Invalid file')\n  // CLOSE: state-variables\n      return\n    }\n\n    setUploading(true)\n    setMessage('Uploading...')\n\n    try {\n      // Upload to Storage\n      const result = await uploadProfilePicture(user.uid, file)\n\n      // Update state and profile\n      setProfilePicture(result.fileUrl)\n      await updateUserProfile(displayName, result.fileUrl)\n\n      setMessage('Profile picture updated!')\n      setTimeout(() => setMessage(''), 3000)\n    } catch (error: any) {\n      setMessage(error.message || 'Failed to upload image')\n      console.error('Error uploading profile picture:', error)\n    } finally {\n      setUploading(false)\n    }\n  }\n\n  /**\n   * LOADING STATE\n   */\n  /** REF: conditional-block\n   */\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-[400px]\">\n        <div className=\"text-xl\">Loading settings...</div>\n      </div>\n    )\n  }\n\n  /** REF: conditional-block\n   */\n  if (!settings) {\n    return (\n      <div className=\"flex items-center justify-center min-h-[400px]\">\n        <div className=\"text-xl\">Settings not found</div>\n      </div>\n    )\n  }\n\n  /**\n   * REF: settings-page-render\n   *\n   * # Settings Page Render\n   *\n   * Three-section layout for profile, appearance, and accessibility settings.\n   *\n   * ## Sections\n   *\n   * 1. **Profile Section**\n   *    - Display name input\n   *    - Profile picture upload\n   *    - Email (read-only)\n   *    - Update button\n   *\n   * 2. **Appearance Section**\n   *    - Theme selector (Light/Dark)\n   *    - Font size buttons (Small/Medium/Large)\n   *    - High contrast toggle\n   *\n   * 3. **Accessibility Section**\n   *    - Reduce motion toggle\n   *\n   * ## Form Pattern\n   *\n   * - **No form submission** - Each setting saves independently\n   * - **Instant feedback** - Changes applied immediately\n   * - **Optimistic UI** - State updates before database\n   * - **Error handling** - Shows message if save fails\n   *\n   * ## UI Components\n   *\n   * | `Component` | Purpose |\n   * |-----------|---------|\n   * | Message banner | Shows success/error feedback |\n   * | Text inputs | For editable fields |\n   * | File input | For picture upload (hidden) |\n   * | `Buttons` | For theme/size/toggle selections |\n   * | Toggle switches | For on/off settings |\n   *\n   * ## Visual Design\n   *\n   * - **Cards** - White backgrounds with shadows\n   * - **Spacing** - mb-6 between sections\n   * - **Dark mode** - dark: variants throughout\n   * - **Disabled states** - Opacity and cursor changes\n   */\n  return (\n    <div className=\"max-w-3xl mx-auto\">\n      <h1 className=\"text-4xl font-bold mb-8\">Settings</h1>\n\n      {/* Message Banner */}\n      {message && (\n        <div className={`mb-6 p-4 rounded-lg ${\n          message.includes('success') || message.includes('updated')\n            ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'\n            : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'\n        }`}>\n          {message}\n        </div>\n      )}\n\n      {/* Profile Section */}\n      <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6\">\n        <h2 className=\"text-2xl font-bold mb-4\">Profile</h2>\n\n        <div className=\"space-y-4\">\n          {/* Profile Picture */}\n          <div>\n            <label className=\"block text-sm font-medium mb-2\">\n              Profile Picture\n            </label>\n            <div className=\"flex items-center gap-4\">\n              {profilePicture ? (\n                <img\n                  src={profilePicture}\n                  alt=\"Profile\"\n                  className=\"w-20 h-20 rounded-full object-cover\"\n                />\n              ) : (\n                <div className=\"w-20 h-20 rounded-full bg-gray-300 dark:bg-gray-600 flex items-center justify-center text-2xl\">\n                  {displayName?.charAt(0) || user?.email?.charAt(0) || '?'}\n                </div>\n              )}\n\n              <div>\n                <input\n                  type=\"file\"\n                  accept=\"image/*\"\n                  onChange={handleProfilePictureUpload}\n                  disabled={uploading}\n                  className=\"hidden\"\n                  id=\"profile-picture-upload\"\n                />\n                <label\n                  htmlFor=\"profile-picture-upload\"\n                  className={`px-4 py-2 bg-blue-600 text-white rounded-lg cursor-pointer hover:bg-blue-700 transition inline-block ${\n                    uploading ? 'opacity-50 cursor-not-allowed' : ''\n                  }`}\n                >\n                  {uploading ? 'Uploading...' : 'Change Picture'}\n                </label>\n                <p className=\"text-sm text-gray-500 mt-1\">\n                  Max 5MB, PNG/JPG/GIF\n                </p>\n              </div>\n            </div>\n          </div>\n\n          {/* Display Name */}\n          <div>\n            <label htmlFor=\"displayName\" className=\"block text-sm font-medium mb-2\">\n              Display Name\n            </label>\n            <input\n              id=\"displayName\"\n              type=\"text\"\n              value={displayName}\n              onChange={(e) => setDisplayName(e.target.value)}\n              className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n            />\n          </div>\n\n          {/* Email (Read-only) */}\n          <div>\n            <label className=\"block text-sm font-medium mb-2\">\n              Email\n            </label>\n            <input\n              type=\"email\"\n              value={user?.email || ''}\n              disabled\n              className=\"w-full px-4 py-2 border border-gray-300 rounded-lg bg-gray-100 dark:bg-gray-700 dark:border-gray-600 cursor-not-allowed\"\n            />\n          </div>\n\n          <button\n            onClick={handleUpdateProfile}\n            disabled={saving}\n            className=\"px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition\"\n          >\n            {saving ? 'Saving...' : 'Update Profile'}\n          </button>\n        </div>\n      </div>\n\n      {/* Appearance Settings */}\n      <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6\">\n        <h2 className=\"text-2xl font-bold mb-4\">Appearance</h2>\n\n        <div className=\"space-y-4\">\n          {/* Theme */}\n          <div>\n            <label className=\"block text-sm font-medium mb-2\">\n              Theme\n            </label>\n            <div className=\"flex gap-4\">\n              <button\n                onClick={() => handleUpdateSetting('theme', 'light')}\n                className={`px-6 py-3 rounded-lg border-2 transition ${\n                  settings.theme === 'light'\n                    ? 'border-blue-600 bg-blue-50 dark:bg-blue-900'\n                    : 'border-gray-300 dark:border-gray-600'\n                }`}\n              >\n                â˜€ï¸ Light\n              </button>\n              <button\n                onClick={() => handleUpdateSetting('theme', 'dark')}\n                className={`px-6 py-3 rounded-lg border-2 transition ${\n                  settings.theme === 'dark'\n                    ? 'border-blue-600 bg-blue-50 dark:bg-blue-900'\n                    : 'border-gray-300 dark:border-gray-600'\n                }`}\n              >\n                ðŸŒ™ Dark\n              </button>\n            </div>\n          </div>\n\n          {/* Font Size */}\n          <div>\n            <label className=\"block text-sm font-medium mb-2\">\n              Font Size\n            </label>\n            <div className=\"flex gap-4\">\n              {['small', 'medium', 'large'].map(size => (\n                <button\n                  key={size}\n                  onClick={() => handleUpdateSetting('fontSize', size)}\n                  className={`px-6 py-3 rounded-lg border-2 transition capitalize ${\n                    settings.fontSize === size\n                      ? 'border-blue-600 bg-blue-50 dark:bg-blue-900'\n                      : 'border-gray-300 dark:border-gray-600'\n                  }`}\n                >\n                  {size}\n                </button>\n              ))}\n            </div>\n          </div>\n\n          {/* High Contrast */}\n          <div className=\"flex items-center justify-between p-4 border border-gray-300 dark:border-gray-600 rounded-lg\">\n            <div>\n              <h3 className=\"font-medium\">High Contrast</h3>\n              <p className=\"text-sm text-gray-600 dark:text-gray-300\">\n                Increases contrast for better visibility\n              </p>\n            </div>\n            <button\n              onClick={() => handleUpdateSetting('highContrast', !settings.highContrast)}\n              className={`relative inline-flex h-6 w-11 items-center rounded-full transition ${\n                settings.highContrast ? 'bg-blue-600' : 'bg-gray-300 dark:bg-gray-600'\n              }`}\n            >\n              <span\n                className={`inline-block h-4 w-4 transform rounded-full bg-white transition ${\n                  settings.highContrast ? 'translate-x-6' : 'translate-x-1'\n                }`}\n              />\n            </button>\n          </div>\n        </div>\n      </div>\n\n      {/* Accessibility Settings */}\n      <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6\">\n        <h2 className=\"text-2xl font-bold mb-4\">Accessibility</h2>\n\n        <div className=\"space-y-4\">\n          {/* Reduced Motion */}\n          <div className=\"flex items-center justify-between p-4 border border-gray-300 dark:border-gray-600 rounded-lg\">\n            <div>\n              <h3 className=\"font-medium\">Reduce Motion</h3>\n              <p className=\"text-sm text-gray-600 dark:text-gray-300\">\n                Minimizes animations and transitions\n              </p>\n            </div>\n            <button\n              onClick={() => handleUpdateSetting('reducedMotion', !settings.reducedMotion)}\n              className={`relative inline-flex h-6 w-11 items-center rounded-full transition ${\n                settings.reducedMotion ? 'bg-blue-600' : 'bg-gray-300 dark:bg-gray-600'\n              }`}\n            >\n              <span\n                className={`inline-block h-4 w-4 transform rounded-full bg-white transition ${\n                  settings.reducedMotion ? 'translate-x-6' : 'translate-x-1'\n                }`}\n              />\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n  // CLOSE: settings-page-render\n}\n",
      "language": "typescript"
    },
    {
      "path": "app/actions.ts",
      "content": "/**\n * REF: server-actions-file\n *\n * # Server Actions\n *\n * Next.js server-side functions called directly from client components.\n *\n * ## What Are Server Actions?\n *\n * Functions that:\n * - Run on the server (not client)\n * - Can be called directly from components\n * - Are type-safe end-to-end\n * - Use 'use server' directive\n * - Don't need API routes or fetch()\n *\n * ## Server Actions vs API Routes\n *\n * | `Aspect` | Server Actions | API Routes |\n * |--------|----------------|-----------|\n * | Code style | Function calls | HTTP endpoints |\n * | Type safety | `Excellent` | Manual validation |\n * | `Boilerplate` | `Minimal` | More setup |\n * | Learning curve | `Easy` | `Medium` |\n * | Use cases | Forms, mutations | Public APIs |\n *\n * ## With Firebase\n *\n * Server Actions can:\n * - Use Firebase Admin SDK\n * - Access full database\n * - Bypass client SDK limitations\n * - Perform complex operations\n * - Validate server-side\n *\n * ## Benefits\n *\n * - **No fetch()** - Call like regular functions\n * - **Type-safe** - Full TypeScript support\n * - **Progressive enhancement** - Works without JavaScript\n * - **Simpler** - No need for separate API routes\n * - **Secure** - Server logic hidden from client\n *\n * ## Security Considerations\n *\n * - Always validate input\n * - Check user authorization\n * - Don't trust formData\n * - Use server-side validation\n * - Verify user identity\n */\n// CLOSE: server-actions-file\n\n'use server'\n\nimport { adminDb } from '@/lib/firebase/admin'\nimport { revalidatePath } from 'next/cache'\n\n/**\n * REF: create-todo-action\n *\n * # Create Todo Server Action\n *\n * Creates a todo using Firebase Admin SDK on the server.\n *\n * ## Function Signature\n *\n * ```typescript\n * async function createTodoAction(formData: FormData)\n * â†’ { success: true, id: string } | { error: string }\n * ```\n *\n * ## Parameters\n *\n * **FormData fields:**\n * - title: Required, todo title\n * - description: Optional, todo details\n * - userId: Required, owner of todo\n * - isPublic: Optional, visibility setting\n *\n * ## Return Values\n *\n * **Success:**\n * ```javascript\n * { success: true, id: \"docId123\" }\n * ```\n *\n * **Error:**\n * ```javascript\n * { error: \"Title is required\" }\n * ```\n *\n * ## Client-Side Usage\n *\n * ```tsx\n * import { createTodoAction } from '@/app/actions'\n *\n * function TodoForm() {\n *   return (\n *     <form action={createTodoAction}>\n *       <input name=\"title\" required />\n *       <input name=\"description\" />\n *       <input name=\"userId\" type=\"hidden\" value={userId} />\n *       <button type=\"submit\">Create</button>\n *     </form>\n *   )\n * }\n * ```\n *\n * No fetch() needed! Form automatically submits to server action.\n *\n * ## Server-Side Logic\n *\n * 1. Extract formData fields\n * 2. Validate inputs\n * 3. Verify userId\n * 4. Create in Firestore (Admin SDK)\n * 5. Revalidate cache\n * 6. Return success/error\n *\n * @param formData - Form submission data\n * @returns Success with ID or error message\n */\nexport async function createTodoAction(formData: FormData) {\n  try {\n    const title = formData.get('title') as string\n    const description = formData.get('description') as string\n    const userId = formData.get('userId') as string\n    const isPublic = formData.get('isPublic') === 'on'\n\n    // Validate\n    if (!title?.trim()) {\n      return { error: 'Title is required' }\n    }\n\n    if (!userId) {\n      return { error: 'User ID required' }\n    }\n\n    // Create in Firestore using Admin SDK\n    const todoRef = await adminDb.collection('todos').add({\n      userId,\n      title: title.trim(),\n      description: description?.trim() || '',\n      completed: false,\n      isPublic,\n      tags: [],\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    })\n\n    // Revalidate the dashboard page cache\n    revalidatePath('/dashboard')\n\n    return { success: true, id: todoRef.id }\n  } catch (error: any) {\n    console.error('Server Action error:', error)\n    return { error: error.message || 'Failed to create todo' }\n  }\n}\n// CLOSE: create-todo-action\n\n/**\n * REF: update-todo-action\n *\n * # Update Todo Server Action\n *\n * Updates an existing todo using Firebase Admin SDK.\n *\n * ## Function Signature\n *\n * ```typescript\n * async function updateTodoAction(\n *   todoId: string,\n *   updates: Partial<Todo>\n * ) â†’ { success: true } | { error: string }\n * ```\n *\n * ## Parameters\n *\n * - todoId: ID of todo to update\n * - updates: Object with fields to update\n *   - title?: New title\n *   - description?: New description\n *   - completed?: Toggle done status\n *   - isPublic?: Change visibility\n *\n * ## Usage\n *\n * ```typescript\n * const result = await updateTodoAction(todoId, {\n *   title: 'Updated title',\n *   completed: true\n * })\n *\n * if (result.error) {\n *   alert(result.error)\n * } else {\n *   console.log('Todo updated!')\n * }\n * ```\n *\n * ## Validation\n *\n * - Checks that todoId is provided\n * - Server validates ownership (via Firestore rules)\n * - Automatically adds updatedAt timestamp\n *\n * @param todoId - ID of todo to update\n * @param updates - Partial todo object with fields to update\n * @returns Success or error result\n */\nexport async function updateTodoAction(\n  todoId: string,\n  updates: {\n    title?: string\n    description?: string\n    completed?: boolean\n    isPublic?: boolean\n  }\n) {\n  try {\n    if (!todoId) {\n      return { error: 'Todo ID required' }\n    }\n\n    // Update in Firestore\n    await adminDb.collection('todos').doc(todoId).update({\n      ...updates,\n      updatedAt: new Date(),\n    })\n\n    revalidatePath('/dashboard')\n\n    return { success: true }\n  } catch (error: any) {\n    console.error('Update error:', error)\n    return { error: error.message || 'Failed to update todo' }\n  }\n}\n// CLOSE: update-todo-action\n\n/**\n * REF: delete-todo-action\n *\n * # Delete Todo Server Action\n *\n * Deletes a todo using Firebase Admin SDK.\n *\n * ## Function Signature\n *\n * ```typescript\n * async function deleteTodoAction(todoId: string)\n * â†’ { success: true } | { error: string }\n * ```\n *\n * ## Parameters\n *\n * - todoId: ID of todo to delete\n *\n * ## Return Value\n *\n * ```javascript\n * // Success\n * { success: true }\n *\n * // Error\n * { error: \"Todo ID required\" }\n * ```\n *\n * ## Behavior\n *\n * 1. Validates todoId is provided\n * 2. Deletes from Firestore\n * 3. Revalidates dashboard page cache\n * 4. Returns success/error\n *\n * ## Security\n *\n * - Firestore security rules validate user ownership\n * - Admin SDK can bypass client validation\n * - Server-side permission checks recommended\n *\n * @param todoId - ID of todo to delete\n * @returns Success or error result\n */\nexport async function deleteTodoAction(todoId: string) {\n  try {\n    if (!todoId) {\n      return { error: 'Todo ID required' }\n    }\n\n    // Delete from Firestore\n    await adminDb.collection('todos').doc(todoId).delete()\n\n    revalidatePath('/dashboard')\n\n    return { success: true }\n  } catch (error: any) {\n    console.error('Delete error:', error)\n    return { error: error.message || 'Failed to delete todo' }\n  }\n}\n// CLOSE: delete-todo-action\n\n/**\n * REF: toggle-completion-action\n *\n * # Toggle Completion Server Action\n *\n * Convenience action for toggling todo completion status.\n *\n * ## Function Signature\n *\n * ```typescript\n * async function toggleTodoCompletionAction(\n *   todoId: string,\n *   currentCompleted: boolean\n * ) â†’ { success: true } | { error: string }\n * ```\n *\n * ## Parameters\n *\n * - todoId: ID of todo to toggle\n * - currentCompleted: Current completion status\n *\n * ## Behavior\n *\n * - Calls updateTodoAction() with inverted completed status\n * - Common operation extracted for convenience\n *\n * ## Usage\n *\n * ```typescript\n * const result = await toggleTodoCompletionAction(todoId, todo.completed)\n * ```\n *\n * @param todoId - ID of todo to toggle\n * @param currentCompleted - Current completion status\n * @returns Success or error result\n */\nexport async function toggleTodoCompletionAction(\n  todoId: string,\n  currentCompleted: boolean\n) {\n  return updateTodoAction(todoId, { completed: !currentCompleted })\n}\n// CLOSE: toggle-completion-action\n\n/**\n * REF: use-transition-pattern\n *\n * # Using Server Actions with useTransition\n *\n * For better UX with loading states in client components.\n *\n * ## Pattern\n *\n * ```tsx\n * import { useTransition } from 'react'\n * import { createTodoAction } from '@/app/actions'\n *\n * function TodoForm() {\n *   const [isPending, startTransition] = useTransition()\n *\n *   const handleSubmit = async (formData: FormData) => {\n *     startTransition(async () => {\n *       const result = await createTodoAction(formData)\n *\n *       if (result.error) {\n *         alert(result.error)\n *       }\n *     })\n *   }\n *\n *   return (\n *     <form action={handleSubmit}>\n *       <input name=\"title\" />\n *       <button disabled={isPending}>\n *         {isPending ? 'Creating...' : 'Create'}\n *       </button>\n *     </form>\n *   )\n * }\n * ```\n *\n * ## Benefits\n *\n * - isPending shows loading state\n * - UI disables while action runs\n * - Smooth user experience\n * - Automatic error handling\n */\n// CLOSE: use-transition-pattern\n\n/**\n * REF: event-handler-pattern\n *\n * # Calling Server Actions from Event Handlers\n *\n * Server actions can be called directly from event handlers, not just forms.\n *\n * ## Pattern\n *\n * ```tsx\n * const handleDelete = async () => {\n *   const result = await deleteTodoAction(todoId)\n *\n *   if (result.error) {\n *     alert(result.error)\n *   }\n * }\n *\n * <button onClick={handleDelete}>Delete</button>\n * ```\n *\n * ## Advantages\n *\n * - Direct function calls\n * - Type-safe parameters\n * - Immediate feedback\n * - No fetch() needed\n */\n// CLOSE: event-handler-pattern\n\n/**\n * REF: admin-sdk-benefits\n *\n * # Firebase Admin SDK Benefits\n *\n * Running on server with Admin SDK provides special capabilities.\n *\n * ## Advantages\n *\n * | `Capability` | Description |\n * |------------|-------------|\n * | Bypass rules | Can bypass security rules (carefully!) |\n * | Privileged ops | Perform operations clients can't |\n * | `Transactions` | Complex multi-step operations |\n * | External APIs | Call services from server |\n * | Full access | Access all Firebase services |\n *\n * ## Use Carefully\n *\n * - Admin SDK ignores security rules\n * - Always validate user authorization\n * - Implement server-side permission checks\n * - Don't trust client-provided data\n */\n// CLOSE: admin-sdk-benefits\n\n/**\n * REF: security-best-practices\n *\n * # Security Best Practices\n *\n * Server Actions are public endpoints and need careful security.\n *\n * ## Essential Rules\n *\n * 1. **Always validate input**\n *    - Check all formData fields\n *    - Reject invalid types\n *    - Enforce constraints\n *\n * 2. **Check user authorization**\n *    - Verify user identity\n *    - Check permissions\n *    - Validate ownership\n *\n * 3. **Don't trust formData**\n *    - Client-side validation is optional\n *    - Always validate server-side\n *    - Assume data is compromised\n *\n * 4. **Use server-side validation**\n *    - Implement comprehensive checks\n *    - Return clear error messages\n *    - Log suspicious activity\n *\n * ## Example Improvement\n *\n * Current code accepts userId from formData.\n * Should verify it matches authenticated user:\n *\n * ```typescript\n * // Get actual user from auth context\n * const { userId } = await verifyAuth()\n *\n * // Don't use userId from formData\n * if (formDataUserId !== userId) {\n *   throw new Error('Unauthorized')\n * }\n * ```\n */\n// CLOSE: security-best-practices\n",
      "language": "typescript"
    },
    {
      "path": "app/layout.tsx",
      "content": "/**\n * REF: root-layout\n *\n * # Root Layout - Application Shell\n *\n * The root layout wraps all pages in the application.\n *\n * ## Key Concepts\n *\n * - **Next.js Layout:** Wraps pages with common UI\n * - **Font Optimization:** Next.js optimizes Google Fonts\n * - **Global Providers:** AuthProvider wraps entire app\n * - **Metadata:** SEO tags for the site\n *\n * ## Layout Hierarchy\n *\n * ```\n * app/layout.tsx (this file)\n *   â””â”€â”€ app/page.tsx (landing)\n *   â””â”€â”€ app/(dashboard)/layout.tsx (dashboard shell)\n *       â””â”€â”€ app/(dashboard)/dashboard/page.tsx\n *       â””â”€â”€ app/(dashboard)/feed/page.tsx\n *       â””â”€â”€ etc.\n * ```\n *\n * Layouts nest and compose together.\n */\n\nimport type { Metadata } from 'next'\nimport { Inter } from 'next/font/google'\nimport './globals.css'\nimport { AuthProvider } from '@/contexts/AuthContext'\n\n/**\n * REF: font-optimization\n *\n * ## Font Optimization with Next.js\n *\n * Next.js automatically optimizes Google Fonts:\n * - Downloads at build time\n * - Self-hosts (no external requests)\n * - Subsetting (only needed characters)\n * - Preloading (faster page loads)\n *\n * ### Inter Font\n *\n * Modern, clean sans-serif font.\n * `subsets: ['latin']` includes only Latin characters.\n */\nconst inter = Inter({ subsets: ['latin'] })\n// CLOSE: font-optimization\n\n/**\n * REF: metadata-export\n *\n * ## Metadata for SEO\n *\n * Static metadata applied to all pages.\n *\n * ### Can Override Per Page\n *\n * ```typescript\n * // In app/dashboard/page.tsx\n * export const metadata = {\n *   title: 'Dashboard - Todo App'\n * }\n * ```\n *\n * Child pages can override parent metadata.\n */\nexport const metadata: Metadata = {\n  title: 'Todo App - Next.js + Firebase',\n  description: 'A full-stack todo application with real-time features',\n}\n// CLOSE: metadata-export\n\n/**\n * REF: root-layout-component\n *\n * ## RootLayout Component\n *\n * The outermost layout component.\n *\n * ### Structure\n *\n * - `<html>`: Root HTML element\n * - `<body>`: Body with font applied\n * - `<AuthProvider>`: Makes auth available everywhere\n * - `{children}`: Nested pages render here\n *\n * ### Why AuthProvider Here?\n *\n * Wrap at root level so:\n * - All components can use `useAuth()`\n * - No need to pass user as props\n * - Single auth state for entire app\n */\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body className={inter.className}>\n        <AuthProvider>{children}</AuthProvider>\n      </body>\n    </html>\n  )\n}\n// CLOSE: root-layout-component\n// CLOSE: root-layout\n",
      "language": "typescript"
    },
    {
      "path": "app/page.tsx",
      "content": "/**\n * REF: landing-page-component\n *\n * # Landing Page - Application Home\n *\n * The main landing page that welcomes users and provides navigation to auth pages.\n *\n * ## Key Concepts\n *\n * - **Server Component** - No 'use client' directive (default in App Router)\n * - **Client-side navigation** - Next.js Link component\n * - **Responsive design** - Grid layouts that adapt to screen size\n * - **Tailwind CSS** - Utility-first CSS framework\n * - **Dark mode support** - All colors use dark: variants\n *\n * ## Page Structure\n *\n * 1. **Hero section** - Title and description\n * 2. **Call-to-action buttons** - Sign In/Sign Up links\n * 3. **Feature cards** - 4 key app features\n * 4. **Responsive layout** - Adapts to mobile/tablet/desktop\n *\n * ## Server Component Benefits\n *\n * As a server component (no 'use client'):\n * - **Rendered on server** - Faster initial page load\n * - **No JavaScript needed** - Pure HTML output\n * - **Better SEO** - Content in HTML for crawlers\n * - **Smaller bundle** - No client-side JavaScript overhead\n *\n * ## Performance Optimization\n *\n * - No client-side hooks or state\n * - Static content (no fetching needed)\n * - Can be cached at CDN\n * - Link prefetching happens client-side\n */\n// CLOSE: landing-page-component\n\nimport Link from 'next/link'\n\n/**\n * REF: home-component\n *\n * # Home Component\n *\n * Main landing page component serving the root (/) route.\n *\n * ## Server Component Implementation\n *\n * This is a server component by default (no 'use client'):\n * - Rendered entirely on server\n * - All content sent as HTML\n * - Links provide client-side navigation\n * - No React hooks needed\n *\n * ## Next.js Link Component\n *\n * Benefits over traditional `<a>` tags:\n * - **Client-side navigation** - No full page reload\n * - **Automatic prefetching** - Linked pages pre-loaded\n * - **Route validation** - Errors caught at build time\n * - **Optimized performance** - No unnecessary requests\n */\nexport default function Home() {\n  /**\n   * REF: page-render\n   *\n   * # Page Render\n   *\n   * Returns JSX for the complete landing page layout.\n   *\n   * ## Page Structure\n   *\n   * 1. **Main container** - Full-screen centered flex layout\n   * 2. **Hero section** - Title and brief description\n   * 3. **CTA buttons** - Sign In and Sign Up navigation\n   * 4. **Feature grid** - 4 cards showcasing app features\n   * 5. **Responsive design** - Adapts to all screen sizes\n   *\n   * ## Layout Techniques\n   *\n   * - **Flexbox** - Full-screen centering\n   * - **Grid** - Feature cards (1 column mobile, 2 columns tablet+)\n   * - **Max-width** - Content container for readability\n   * - **Padding** - Spacing and margins\n   *\n   * ## Color System\n   *\n   * - **Light mode** - White backgrounds, dark text\n   * - **Dark mode** - Dark backgrounds, light text\n   * - **Interactive** - Blue for primary, gray for secondary\n   */\n  return (\n    /**\n     * ## Main Container\n     *\n     * Full-screen centered layout using Flexbox.\n     *\n     * ### Tailwind Classes\n     *\n     * - `flex min-h-screen`: Full viewport height with flex\n     * - `flex-col`: Vertical stacking\n     * - `items-center justify-center`: Center content\n     * - `p-24`: Large padding all around\n     */\n    <main className=\"flex min-h-screen flex-col items-center justify-center p-24\">\n      {/**\n       * ## Content Container\n       *\n       * Max-width container with centered text.\n       *\n       * Keeps content readable (not too wide).\n       */}\n      <div className=\"max-w-2xl text-center\">\n        {/**\n         * ## Hero Title\n         *\n         * Main heading for the landing page.\n         *\n         * - `text-5xl`: Very large text\n         * - `font-bold`: Bold weight\n         * - `mb-6`: Margin bottom\n         */}\n        <h1 className=\"text-5xl font-bold mb-6\">\n          Welcome to Todo App\n        </h1>\n\n        {/**\n         * ## Description\n         *\n         * Brief overview of the application.\n         *\n         * Uses `dark:` variant for dark mode text color.\n         */}\n        <p className=\"text-xl text-gray-600 dark:text-gray-300 mb-8\">\n          A full-stack todo application built with Next.js and Firebase featuring\n          real-time updates, public feed, and messaging.\n        </p>\n\n        {/**\n         * ## Call-to-Action Buttons\n         *\n         * Primary navigation to authentication pages.\n         *\n         * ### Next.js Link Component\n         *\n         * Using `Link` instead of `<a>`:\n         * - **Client-side navigation:** No page reload\n         * - **Prefetching:** Link targets pre-loaded\n         * - **Better UX:** Faster navigation\n         *\n         * ### Button Styling\n         *\n         * - **Sign In:** Blue background (primary action)\n         * - **Sign Up:** Gray background (secondary action)\n         * - **Hover states:** Darker on hover\n         * - **Dark mode:** Adjusted colors\n         */}\n        <div className=\"flex gap-4 justify-center\">\n          <Link\n            href=\"/signin\"\n            className=\"px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition\"\n          >\n            Sign In\n          </Link>\n          <Link\n            href=\"/signup\"\n            className=\"px-6 py-3 bg-gray-200 dark:bg-gray-700 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600 transition\"\n          >\n            Sign Up\n          </Link>\n        </div>\n\n        {/**\n         * ## Feature Grid\n         *\n         * Showcases main application features.\n         *\n         * ### Responsive Layout\n         *\n         * - **Mobile:** Single column (`grid-cols-1`)\n         * - **Tablet+:** Two columns (`md:grid-cols-2`)\n         * - **Gap:** Spacing between cards\n         *\n         * Each card highlights a key feature of the app.\n         */}\n        <div className=\"mt-12 grid grid-cols-1 md:grid-cols-2 gap-6 text-left\">\n          {/**\n           * ### Feature Card: Real-time Todos\n           *\n           * Highlights the core todo CRUD functionality.\n           *\n           * - Real-time updates via Firestore listeners\n           * - Cross-device synchronization\n           * - Instant updates without refresh\n           */}\n          <div className=\"p-6 bg-white dark:bg-gray-800 rounded-lg shadow\">\n            <h3 className=\"font-bold text-lg mb-2\">Real-time Todos</h3>\n            <p className=\"text-gray-600 dark:text-gray-300\">\n              Create, update, and delete todos with instant synchronization across all devices.\n            </p>\n          </div>\n\n          {/**\n           * ### Feature Card: Public Feed\n           *\n           * Community sharing feature.\n           *\n           * - Share todos publicly\n           * - Search across all public todos\n           * - Filter by tags\n           * - Discover what others are working on\n           */}\n          <div className=\"p-6 bg-white dark:bg-gray-800 rounded-lg shadow\">\n            <h3 className=\"font-bold text-lg mb-2\">Public Feed</h3>\n            <p className=\"text-gray-600 dark:text-gray-300\">\n              Share your todos with the community. Search, filter, and discover public todos.\n            </p>\n          </div>\n\n          {/**\n           * ### Feature Card: Messaging\n           *\n           * Real-time chat between users.\n           *\n           * - One-on-one messaging\n           * - Read receipts\n           * - Instant delivery\n           * - Conversation history\n           */}\n          <div className=\"p-6 bg-white dark:bg-gray-800 rounded-lg shadow\">\n            <h3 className=\"font-bold text-lg mb-2\">Messaging</h3>\n            <p className=\"text-gray-600 dark:text-gray-300\">\n              Chat with other users in real-time with delivery receipts.\n            </p>\n          </div>\n\n          {/**\n           * ### Feature Card: Accessibility\n           *\n           * User preference customization.\n           *\n           * - Theme switching (light/dark)\n           * - Font size adjustment\n           * - High contrast mode\n           * - Reduced motion option\n           * - WCAG compliant\n           */}\n          <div className=\"p-6 bg-white dark:bg-gray-800 rounded-lg shadow\">\n            <h3 className=\"font-bold text-lg mb-2\">Accessibility</h3>\n            <p className=\"text-gray-600 dark:text-gray-300\">\n              Customize your experience with theme, font size, contrast, and motion settings.\n            </p>\n          </div>\n        </div>\n      </div>\n    </main>\n  )\n  // CLOSE: page-render\n}\n// CLOSE: home-component\n\n/**\n * REF: responsive-design-pattern\n *\n * # Responsive Design Pattern\n *\n * Uses Tailwind's responsive utilities for mobile-first design.\n *\n * ## Breakpoints\n *\n * ```\n * grid-cols-1 md:grid-cols-2\n * ```\n *\n * | Screen Size | `Classes` | `Layout` |\n * |-------------|---------|--------|\n * | Mobile < 768px | `grid-cols-1` | 1 column |\n * | Tablet 768px+ | `md:grid-cols-2` | 2 columns |\n * | Desktop 1024px+ | (can add `lg:`) | Can further customize |\n *\n * ## Mobile-First Approach\n *\n * - Default: single column (mobile-optimized)\n * - md: prefix applies at 768px and up\n * - Ensures good mobile experience first\n * - Enhances on larger screens\n */\n// CLOSE: responsive-design-pattern\n\n/**\n * REF: dark-mode-support\n *\n * # Dark Mode Support\n *\n * All colors use Tailwind's dark: variants for automatic theme switching.\n *\n * ## Dark Mode Implementation\n *\n * ```tsx\n * className=\"bg-white dark:bg-gray-800\"\n * className=\"text-gray-600 dark:text-gray-300\"\n * ```\n *\n * ## How It Works\n *\n * - dark: prefix applies when dark mode is active\n * - Detected from user's system preference\n * - Can be overridden by settings page\n * - Automatically switches via CSS\n *\n * ## Color Pairs\n *\n * | `Light` | `Dark` | Purpose |\n * |-------|------|---------|\n * | `bg-white` | `bg-gray-800` | Card backgrounds |\n * | `text-gray-600` | `text-gray-300` | Body text |\n * | `bg-blue-600` | (same) | Buttons (primary) |\n * | `bg-gray-200` | `bg-gray-700` | Buttons (secondary) |\n */\n// CLOSE: dark-mode-support\n\n/**\n * REF: nextjs-app-router\n *\n * # Next.js App Router\n *\n * This file is in `app/page.tsx` and uses the App Router pattern.\n *\n * ## Route Mapping\n *\n * - **File path** - app/page.tsx\n * - **Route** - / (root)\n * - **Type** - Server component (no 'use client')\n *\n * ## Component Type\n *\n * | `Aspect` | `Behavior` |\n * |--------|----------|\n * | `Rendering` | Server-side, no client JavaScript |\n * | `SEO` | Excellent (content in HTML) |\n * | `Performance` | Fast initial load |\n * | `Interactivity` | Links provide client-side nav |\n *\n * ## Benefits\n *\n * - No client-side JavaScript for page itself\n * - Links handled by Next.js router (client-side)\n * - Perfect for static landing pages\n * - Can be cached at CDN\n * - Automatic static generation\n */\n// CLOSE: nextjs-app-router\n\n",
      "language": "typescript"
    },
    {
      "path": "components/attachments/AttachmentList.tsx",
      "content": "/**\n * REF: attachment-list-component\n *\n * # AttachmentList Component\n *\n * Displays all attachments for a todo with download and delete actions.\n *\n * ## Key Concepts\n *\n * - **Real-time subscriptions** - Live updates via Firestore onSnapshot\n * - **File downloads** - Direct download links via Firebase Storage\n * - **Delete operations** - Two-step deletion (Storage + Firestore)\n * - **File type detection** - MIME type-based emoji icons\n * - **Size formatting** - Human-readable file sizes\n *\n * ## Real-Time Updates\n *\n * - Uses Firestore onSnapshot for live updates\n * - When attachment added, list updates automatically\n * - When attachment deleted, disappears immediately\n * - No manual refresh needed\n * - Automatic cleanup on unmount\n *\n * ## Features\n *\n * | Feature | Description |\n * |---------|-------------|\n * | Real-time list | Updates instantly when attachments change |\n * | Download links | Direct file downloads from Cloud Storage |\n * | Delete with confirmation | Prevents accidental deletion |\n * | File icons | Visual type indicators (image, PDF, etc.) |\n * | Size display | Human-readable file sizes (KB, MB) |\n * | Empty state | Shows message when no attachments |\n * | Loading state | Shows loading indicator on mount |\n */\n// CLOSE: attachment-list-component\n\n'use client'\n\n/** REF: attachmentlist-imports\n * Required imports for Firebase Firestore, Storage, and React hooks.\n * Manages attachment data and real-time updates.\n */\nimport { useState, useEffect } from 'react'\nimport { collection, query, where, onSnapshot, deleteDoc, doc } from 'firebase/firestore'\nimport { deleteObject, ref } from 'firebase/storage'\nimport { db, storage } from '@/lib/firebase/client'\nimport { TodoAttachment } from '@/types'\n// CLOSE: attachmentlist-imports\n\n/**\n * REF: attachment-list-props\n *\n * # AttachmentList Props Interface\n *\n * Configuration for the attachment list component.\n *\n * ## Props\n *\n * | `Prop` | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `todoId` | `string` | `Yes` | ID of the todo these attachments belong to |\n * | `canDelete` | `boolean` | `No` | Whether current user can delete attachments (default: false) |\n *\n * ## Permissions\n *\n * The canDelete prop controls visibility of delete button:\n * - **true** - Show delete button and allow deletion\n * - **false** - Hide delete button (download only)\n *\n * Note: Server-side security rules should also validate permissions\n */\ninterface AttachmentListProps {\n  todoId: string\n  canDelete?: boolean // Whether current user can delete attachments\n}\n// CLOSE: attachment-list-props\n\nexport default function AttachmentList({ todoId, canDelete = false }: AttachmentListProps) {\n  /**\n   * REF: attachment-list-state\n   *\n   * # Component State\n   *\n   * Managing attachments data and UI states.\n   *\n   * ## State Variables\n   *\n   * | `Variable` | Type | Purpose |\n   * |----------|------|---------|\n   * | `attachments` | `TodoAttachment[]` | List of files for this todo |\n   * | `loading` | `boolean` | Initial data fetch in progress |\n   * | `deleting` | string or null | ID of attachment being deleted |\n   *\n   * ## State Management\n   *\n   * - attachments: Updated by real-time listener\n   * - loading: Set to false after first data arrives\n   * - deleting: Stores ID of item awaiting deletion (prevents double-click)\n   */\n  const [attachments, setAttachments] = useState<TodoAttachment[]>([])\n  const [loading, setLoading] = useState(true)\n  const [deleting, setDeleting] = useState<string | null>(null)\n  // CLOSE: attachment-list-state\n\n  /**\n   * REF: real-time-subscription\n   *\n   * # Real-Time Attachments Subscription\n   *\n   * Sets up live listener for all attachments belonging to this todo.\n   *\n   * ## Why Real-Time?\n   *\n   * - User sees uploads immediately\n   * - Works across devices/tabs\n   * - No refresh button needed\n   * - Automatic synchronization\n   *\n   * ## Firestore Query\n   *\n   * ```\n   * Collection: todoAttachments\n   * Filter: todoId == [todoId]\n   * Listener: Updates whenever data changes\n   * ```\n   *\n   * ## Cleanup\n   *\n   * - unsubscribe() when component unmounts\n   * - Prevents memory leaks\n   * - Called via return function in useEffect\n   *\n   * ## Data Mapping\n   *\n   * Firestore document â†’ TodoAttachment object\n   * - Includes: id, fileName, fileUrl, fileSize, mimeType\n   */\n  useEffect(() => {\n    const q = query(\n      collection(db, 'todoAttachments'),\n      where('todoId', '==', todoId)\n    )\n\n    const unsubscribe = onSnapshot(q, (snapshot) => {\n      const attachmentData = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data(),\n      } as TodoAttachment))\n\n      setAttachments(attachmentData)\n      setLoading(false)\n    })\n\n    return () => unsubscribe()\n  }, [todoId])\n  // CLOSE: real-time-subscription\n\n  /**\n   * REF: delete-attachment-handler\n   *\n   * # Delete Attachment Handler\n   *\n   * Deletes file from both Storage and Firestore.\n   *\n   * ## Parameters\n   *\n   * - attachment: The TodoAttachment object to delete\n   *\n   * ## Two-Step Delete Process\n   *\n   * 1. **Confirmation** - Show confirm dialog to user\n   * 2. **Delete from Storage** - Remove actual file from Cloud Storage\n   * 3. **Delete from Firestore** - Remove metadata document\n   * 4. **UI Update** - Real-time listener removes from list automatically\n   *\n   * ## Error Handling\n   *\n   * | `Scenario` | `Behavior` |\n   * |----------|----------|\n   * | User cancels | Do nothing |\n   * | Storage delete fails | Show error, don't delete Firestore |\n   * | Firestore delete fails | Show error, file may remain in Storage |\n   * | `Success` | Both deleted, UI updates automatically |\n   *\n   * ## Storage Path Extraction\n   *\n   * The file URL from Storage includes path information that must be:\n   * 1. URL-decoded\n   * 2. Stripped of query parameters\n   * 3. Used to reference file for deletion\n   *\n   * @param attachment - TodoAttachment to delete\n   */\n  const handleDelete = async (attachment: TodoAttachment) => {\n    if (!confirm(`Delete ${attachment.fileName}?`)) return\n\n    setDeleting(attachment.id)\n\n    try {\n      // Extract storage path from URL\n      // URL format: https://firebasestorage.googleapis.com/.../todo-attachments%2F...\n      const urlParts = attachment.fileUrl.split('/')\n      const pathPart = urlParts[urlParts.length - 1]\n      const storagePath = decodeURIComponent(pathPart.split('?')[0])\n\n      // Delete from Storage\n      const storageRef = ref(storage, storagePath)\n      await deleteObject(storageRef)\n\n      // Delete metadata from Firestore\n      await deleteDoc(doc(db, 'todoAttachments', attachment.id))\n    } catch (error: any) {\n      console.error('Delete error:', error)\n      alert('Failed to delete attachment')\n    } finally {\n      setDeleting(null)\n    }\n  }\n  // CLOSE: delete-attachment-handler\n\n  /**\n   * REF: format-file-size\n   *\n   * # Format File Size Utility\n   *\n   * Converts bytes to human-readable format.\n   *\n   * ## Algorithm\n   *\n   * | Size Range | `Format` |\n   * |------------|--------|\n   * | < 1024 B | Show bytes (e.g., \"512 B\") |\n   * | 1KB - 1MB | Show KB (e.g., \"256.5 KB\") |\n   * | 1MB+ | Show MB (e.g., \"2.3 MB\") |\n   *\n   * ## Examples\n   *\n   * - 512 bytes â†’ \"512 B\"\n   * - 2048 bytes â†’ \"2.0 KB\"\n   * - 1048576 bytes â†’ \"1.0 MB\"\n   * - 5242880 bytes â†’ \"5.0 MB\"\n   *\n   * ## Implementation Notes\n   *\n   * - toFixed(1) gives 1 decimal place\n   * - Division gives proper unit conversion\n   * - Readable for typical file sizes\n   *\n   * @param bytes - File size in bytes\n   * @returns Formatted string like \"2.5 MB\"\n   */\n  const formatFileSize = (bytes: number): string => {\n    if (bytes < 1024) return `${bytes} B`\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`\n    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`\n  }\n  // CLOSE: format-file-size\n\n  /**\n   * REF: get-file-icon\n   *\n   * # Get File Icon Utility\n   *\n   * Returns emoji icon based on MIME type for visual identification.\n   *\n   * ## MIME Type Mapping\n   *\n   * | `Category` | MIME Type Pattern | `Icon` |\n   * |----------|-------------------|------|\n   * | `Images` | image/* | ðŸ–¼ï¸ |\n   * | `Videos` | video/* | ðŸŽ¥ |\n   * | `Audio` | audio/* | ðŸŽµ |\n   * | `PDF` | application/pdf | ðŸ“„ |\n   * | `Word` | `word` | ðŸ“ |\n   * | `Spreadsheet` | sheet, excel | ðŸ“Š |\n   * | `Archive` | zip, archive | ðŸ“¦ |\n   * | Default | (any other) | ðŸ“Ž |\n   *\n   * ## Detection Strategy\n   *\n   * 1. Check if MIME type starts with known categories\n   * 2. Fall back to substring matching for Office/document types\n   * 3. Use generic paperclip emoji as fallback\n   *\n   * ## Examples\n   *\n   * - \"image/jpeg\" â†’ ðŸ–¼ï¸\n   * - \"application/pdf\" â†’ ðŸ“„\n   * - \"application/vnd.ms-excel\" â†’ ðŸ“Š\n   * - \"application/zip\" â†’ ðŸ“¦\n   * - \"application/custom\" â†’ ðŸ“Ž\n   *\n   * @param mimeType - File MIME type (e.g., \"image/jpeg\")\n   * @returns Emoji representing file type\n   */\n  const getFileIcon = (mimeType: string): string => {\n    if (mimeType.startsWith('image/')) return 'ðŸ–¼ï¸'\n    if (mimeType.startsWith('video/')) return 'ðŸŽ¥'\n    if (mimeType.startsWith('audio/')) return 'ðŸŽµ'\n    if (mimeType.includes('pdf')) return 'ðŸ“„'\n    if (mimeType.includes('word')) return 'ðŸ“'\n    if (mimeType.includes('sheet') || mimeType.includes('excel')) return 'ðŸ“Š'\n    if (mimeType.includes('zip') || mimeType.includes('archive')) return 'ðŸ“¦'\n    return 'ðŸ“Ž'\n  }\n  // CLOSE: get-file-icon\n\n  /**\n   * REF: loading-state\n   *\n   * # Loading State\n   *\n   * Displayed while fetching attachments from Firestore.\n   *\n   * Shows brief loading message during initial data fetch.\n   */\n  if (loading) {\n    return <div className=\"text-sm text-gray-500\">Loading attachments...</div>\n  }\n  // CLOSE: loading-state\n\n  /**\n   * REF: empty-state\n   *\n   * # Empty State\n   *\n   * Displayed when todo has no attachments.\n   *\n   * Provides clear feedback that there are no files.\n   */\n  if (attachments.length === 0) {\n    return <div className=\"text-sm text-gray-500\">No attachments</div>\n  }\n  // CLOSE: empty-state\n\n  /**\n   * REF: attachment-list-render\n   *\n   * # Attachment List Render\n   *\n   * Displays grid of attachment cards with download and delete actions.\n   *\n   * ## Layout Structure\n   *\n   * - Space-Y-2: Vertical spacing between items\n   * - Each card is a flex container\n   * - Left side: File icon, name, size\n   * - Right side: Action buttons\n   *\n   * ## File Info Display\n   *\n   * | `Element` | Purpose |\n   * |---------|---------|\n   * | `Icon` | Visual type identification |\n   * | File name | Truncated with title tooltip |\n   * | File size | Human-readable format |\n   *\n   * ## Actions\n   *\n   * - **Download** - Opens file URL in new tab\n   * - **Delete** - Only shows if canDelete prop is true\n   *\n   * ## Accessibility\n   *\n   * - Title attributes on links for screen readers\n   * - Proper button labels\n   * - Keyboard navigable\n   * - Disabled state for delete during operation\n   *\n   * ## Dark Mode\n   *\n   * - Gray background with dark: variants\n   * - Text colors adapt to dark mode\n   * - Hover states visible in both themes\n   */\n  return (\n    <div className=\"space-y-2\">\n      {attachments.map(attachment => (\n        <div\n          key={attachment.id}\n          className=\"flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-700 rounded-lg border border-gray-200 dark:border-gray-600\"\n        >\n          {/* File Info */}\n          <div className=\"flex items-center gap-3 flex-1 min-w-0\">\n            {/* Icon */}\n            <span className=\"text-2xl flex-shrink-0\">\n              {getFileIcon(attachment.mimeType)}\n            </span>\n\n            {/* Name and Size */}\n            <div className=\"min-w-0 flex-1\">\n              <p className=\"font-medium truncate\" title={attachment.fileName}>\n                {attachment.fileName}\n              </p>\n              <p className=\"text-xs text-gray-500\">\n                {formatFileSize(attachment.fileSize)}\n              </p>\n            </div>\n          </div>\n\n          {/* Actions */}\n          <div className=\"flex items-center gap-2 flex-shrink-0\">\n            {/* Download Button */}\n            <a\n              href={attachment.fileUrl}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className=\"p-2 text-blue-600 hover:bg-blue-50 dark:hover:bg-blue-900 rounded transition\"\n              title={`Download ${attachment.fileName}`}\n            >\n              â¬‡ï¸\n            </a>\n\n            {/* Delete Button (if allowed) */}\n            {canDelete && (\n              <button\n                onClick={() => handleDelete(attachment)}\n                disabled={deleting === attachment.id}\n                className=\"p-2 text-red-600 hover:bg-red-50 dark:hover:bg-red-900 rounded transition disabled:opacity-50 disabled:cursor-not-allowed\"\n                title={`Delete ${attachment.fileName}`}\n              >\n                {deleting === attachment.id ? 'â³' : 'ðŸ—‘ï¸'}\n              </button>\n            )}\n          </div>\n        </div>\n      ))}\n    </div>\n  )\n  // CLOSE: attachment-list-render\n}\n",
      "language": "typescript"
    },
    {
      "path": "components/attachments/AttachmentUpload.tsx",
      "content": "/**\n * REF: attachment-upload-component\n *\n * # AttachmentUpload Component\n *\n * Handles uploading file attachments to todos.\n *\n * ## Key Concepts\n *\n * - **File input handling** - React file input events\n * - **File validation** - Type and size checks\n * - **Upload progress** - User feedback during upload\n * - **Firebase Storage** - Upload file and get URL\n * - **Error handling** - Graceful failure handling\n *\n * ## Upload Flow\n *\n * ```\n * User selects file\n *     â†“\n * Validate file (type, size)\n *     â†“\n * Upload to Firebase Storage\n *     â†“\n * Get download URL\n *     â†“\n * Save metadata to Firestore\n *     â†“\n * Display in AttachmentList (via real-time listener)\n * ```\n *\n * ## Security Layers\n *\n * | `Layer` | `Validation` |\n * |-------|-----------|\n * | Client-side | File type, size check (UX) |\n * | Storage rules | Server-side authentication check |\n * | `Naming` | Unique filenames prevent overwrites |\n *\n * ## Design Pattern\n *\n * - **Hidden file input** - Triggered by button\n * - **Custom button styling** - Better UX than default input\n * - **Progressive disclosure** - Show errors as needed\n */\n// CLOSE: attachment-upload-component\n\n'use client'\n\n/** REF: attachmentupload-imports\n * Required imports for React hooks, auth context, and Firebase services.\n * Handles file upload and Firestore operations.\n */\nimport { useState } from 'react'\nimport { useAuth } from '@/contexts/AuthContext'\nimport { uploadTodoAttachment, validateAttachmentFile } from '@/lib/firebase/storage'\nimport { addDoc, collection } from 'firebase/firestore'\nimport { db } from '@/lib/firebase/client'\n// CLOSE: attachmentupload-imports\n\n/**\n * REF: attachment-upload-props\n *\n * # AttachmentUpload Props Interface\n *\n * Configuration for file upload component.\n *\n * ## Props\n *\n * | `Prop` | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `todoId` | `string` | `Yes` | ID of todo to attach file to |\n * | `onUploadComplete` | `function` | `No` | Callback when upload succeeds |\n *\n * ## Callback Usage\n *\n * The optional callback allows parent to know when upload is done:\n * - Refresh attachment list\n * - Show success message\n * - Update UI state\n *\n * Note: AttachmentList automatically updates via real-time listener\n */\ninterface AttachmentUploadProps {\n  todoId: string\n  onUploadComplete?: () => void\n}\n// CLOSE: attachment-upload-props\n\nexport default function AttachmentUpload({ todoId, onUploadComplete }: AttachmentUploadProps) {\n  const { user } = useAuth()\n\n  /**\n   * REF: upload-component-state\n   *\n   * # Upload Component State\n   *\n   * Managing file upload progress and error handling.\n   *\n   * ## State Variables\n   *\n   * | `Variable` | Type | Purpose |\n   * |----------|------|---------|\n   * | `uploading` | `boolean` | Shows loading state, disables input |\n   * | `error` | `string` | Error message to display to user |\n   *\n   * ## State Flow\n   *\n   * 1. User selects file â†’ uploading = true\n   * 2. Validation fails â†’ error = message, uploading = false\n   * 3. Upload succeeds â†’ error = '', uploading = false\n   * 4. Upload fails â†’ error = message, uploading = false\n   */\n  const [uploading, setUploading] = useState(false)\n  const [error, setError] = useState('')\n  // CLOSE: upload-component-state\n\n  /**\n   * REF: file-selection-handler\n   *\n   * # File Selection Handler\n   *\n   * Triggered when user selects a file from their device.\n   *\n   * ## Flow\n   *\n   * 1. **Extract file** - Get selected file from input event\n   * 2. **Pre-flight checks** - Verify file and user exist\n   * 3. **Validate file** - Check type and size\n   * 4. **Upload** - Send to Firebase Storage\n   * 5. **Save metadata** - Create Firestore document\n   * 6. **Notify parent** - Call onUploadComplete callback\n   * 7. **Reset** - Clear input for next upload\n   *\n   * ## Error Handling\n   *\n   * | Error Type | `Behavior` |\n   * |------------|----------|\n   * | No file selected | Return silently |\n   * | Validation fails | Show error, stop |\n   * | Upload fails | Show error, form usable |\n   * | Database fails | Show error, file in Storage |\n   *\n   * ## Upload Result\n   *\n   * uploadTodoAttachment returns:\n   * - fileName: Original filename\n   * - fileUrl: Public download URL\n   * - fileSize: Size in bytes\n   * - mimeType: File MIME type\n   *\n   * @param e - File input change event\n   */\n  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {\n    // Get the selected file\n    const file = e.target.files?.[0]\n    if (!file || !user) return\n\n    // Reset error state\n    setError('')\n\n    // Validate file\n    const validation = validateAttachmentFile(file)\n    if (!validation.valid) {\n      setError(validation.error || 'Invalid file')\n      return\n    }\n\n    setUploading(true)\n\n    try {\n      /**\n       * Upload to Firebase Storage\n       *\n       * uploadTodoAttachment() handles:\n       * - Creating unique filename\n       * - Uploading file to Storage\n       * - Returning download URL and metadata\n       */\n      const uploadResult = await uploadTodoAttachment(user.uid, todoId, file)\n\n      /**\n       * Save metadata to Firestore\n       *\n       * Why separate Storage and Firestore?\n       * - Storage: Stores actual file bytes\n       * - Firestore: Stores searchable metadata\n       * - Can query attachments by todo ID\n       * - Can delete from both places independently\n       * - Metadata available in real-time listener\n       */\n      await addDoc(collection(db, 'todoAttachments'), {\n        todoId,\n        fileName: uploadResult.fileName,\n        fileUrl: uploadResult.fileUrl,\n        fileSize: uploadResult.fileSize,\n        mimeType: uploadResult.mimeType,\n        uploadedAt: new Date(),\n      })\n\n      // Notify parent component (refreshes attachment list)\n      onUploadComplete?.()\n\n      // Reset the file input\n      e.target.value = ''\n    } catch (err: any) {\n      console.error('Upload error:', err)\n      setError(err.message || 'Failed to upload file')\n    } finally {\n      setUploading(false)\n    }\n  }\n  // CLOSE: file-selection-handler\n\n  /**\n   * REF: upload-component-render\n   *\n   * # Upload Component Render\n   *\n   * Form UI for selecting and uploading files.\n   *\n   * ## Layout Structure\n   *\n   * 1. **Error banner** - Shows validation or upload errors\n   * 2. **File input** - Hidden, triggered by button\n   * 3. **Upload button** - Styled label that opens file picker\n   * 4. **Helper text** - Shows max file size and accepted types\n   *\n   * ## UX Patterns\n   *\n   * ### Hidden File Input\n   * - Native file input is replaced by button\n   * - Better visual control\n   * - Consistent with design system\n   *\n   * ### Button States\n   * - **Normal** - Blue background, clickable\n   * - **Uploading** - Gray background, disabled, shows spinner\n   * - **Error** - Shows message above button\n   *\n   * ### Helper Text\n   * - Shows constraints (5MB max)\n   * - All file types accepted\n   * - Validation happens in code\n   *\n   * ## Accessibility\n   *\n   * - Label associated with hidden input\n   * - Form spacing for readability\n   * - Clear error messages\n   * - Disabled state prevents interaction during upload\n   */\n  return (\n    <div className=\"space-y-2\">\n      {/* Error Display */}\n      {error && (\n        <div className=\"p-3 bg-red-100 border border-red-400 text-red-700 rounded text-sm\">\n          {error}\n        </div>\n      )}\n\n      {/* File Input (Hidden) */}\n      <input\n        type=\"file\"\n        id={`attachment-upload-${todoId}`}\n        onChange={handleFileSelect}\n        disabled={uploading}\n        className=\"hidden\"\n        accept=\"*/*\" // Accept all files, validation happens in code\n      />\n\n      {/* Upload Button (Label styled as button) */}\n      <label\n        htmlFor={`attachment-upload-${todoId}`}\n        className={`inline-flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium transition cursor-pointer ${\n          uploading\n            ? 'bg-gray-300 dark:bg-gray-600 cursor-not-allowed'\n            : 'bg-blue-600 text-white hover:bg-blue-700'\n        }`}\n      >\n        {uploading ? (\n          <>\n            <span className=\"animate-spin\">â³</span>\n            Uploading...\n          </>\n        ) : (\n          <>\n            ðŸ“Ž Attach File\n          </>\n        )}\n      </label>\n\n      {/* Helper Text */}\n      <p className=\"text-xs text-gray-500\">\n        Max file size: 5MB. All file types supported.\n      </p>\n    </div>\n  )\n  // CLOSE: upload-component-render\n}\n",
      "language": "typescript"
    },
    {
      "path": "components/todos/TodoForm.tsx",
      "content": "/**\n * REF: todo-form-component\n *\n * # TodoForm Component\n *\n * Reusable form for creating and editing todos.\n *\n * ## Key React Concepts\n *\n * 1. **Controlled Components** - Form inputs tied to React state\n * 2. **Event Handlers** - Handle user input and submission\n * 3. **Component Props** - Make components reusable\n * 4. **Conditional Rendering** - Show different UI based on state\n *\n * ## Form Best Practices\n *\n * - Controlled inputs (`value` prop) for full React control\n * - Prevent default form submission to handle with JavaScript\n * - Clear form after successful submission\n * - Disable submit while processing (prevent double-submits)\n * - Validate before submission\n */\n\n'use client'\n\nimport { useState, FormEvent } from 'react'\nimport { Todo } from '@/types'\n\n/**\n * REF: todo-form-props\n *\n * ## Component Props Interface\n *\n * Defines props for TodoForm component.\n *\n * ### Properties\n *\n * - `onSubmit`: Callback when form submitted\n * - `initialData?`: Optional data for editing existing todo\n * - `submitButtonText?`: Custom button text\n *\n * ### TypeScript Benefits\n *\n * - Autocomplete in IDEs\n * - Compile-time error checking\n * - Self-documenting code\n */\ninterface TodoFormProps {\n  onSubmit: (data: Partial<Todo>) => Promise<void>\n  initialData?: Partial<Todo>\n  submitButtonText?: string\n}\n// CLOSE: todo-form-props\n\n/**\n * REF: todo-form-function\n *\n * ## TodoForm Function Component\n *\n * Main component function with props destructuring.\n */\nexport default function TodoForm({\n  onSubmit,\n  initialData,\n  submitButtonText = 'Create Todo',\n}: TodoFormProps) {\n  /**\n   * REF: form-state\n   *\n   * ## Form State Management\n   *\n   * Each input field has its own state variable.\n   *\n   * ### State Variables\n   *\n   * - `title`: Todo title text\n   * - `description`: Optional description\n   * - `isPublic`: Public visibility toggle\n   * - `tags`: Array of tag strings\n   * - `tagInput`: Temporary input for adding tags\n   * - `loading`: Submission in progress\n   *\n   * ### Why Separate Variables?\n   *\n   * Could use one object, but separate is simpler:\n   * - Each input's `onChange` directly calls its setter\n   * - Easier to reset individual fields\n   * - Clearer what each state represents\n   */\n  const [title, setTitle] = useState(initialData?.title || '')\n  const [description, setDescription] = useState(initialData?.description || '')\n  const [isPublic, setIsPublic] = useState(initialData?.isPublic || false)\n  const [tags, setTags] = useState<string[]>(initialData?.tags || [])\n  const [tagInput, setTagInput] = useState('')\n  const [loading, setLoading] = useState(false)\n  // CLOSE: form-state\n\n  /**\n   * REF: handle-submit\n   *\n   * ## Form Submit Handler\n   *\n   * Handles form submission with validation.\n   *\n   * ### Flow\n   *\n   * 1. Prevent default browser submission (would reload page)\n   * 2. Validate input\n   * 3. Set loading state\n   * 4. Call parent's `onSubmit` with form data\n   * 5. Clear form on success (if creating new)\n   * 6. Reset loading state\n   *\n   * ### Error Handling\n   *\n   * - Parent component handles errors\n   * - `finally` block ensures loading reset even on error\n   *\n   * ### Controlled Inputs\n   *\n   * All inputs are \"controlled\":\n   * - `value={title}` makes React the source of truth\n   * - `onChange` updates state\n   * - React has full control over input values\n   */\n  const handleSubmit = async (e: FormEvent) => {\n    e.preventDefault() // Prevent page reload\n\n    // Validation\n    if (!title.trim()) {\n      alert('Please enter a title')\n      return\n    }\n\n    setLoading(true)\n\n    try {\n      // Call parent's onSubmit with all form data\n      await onSubmit({\n        title: title.trim(),\n        description: description.trim(),\n        isPublic,\n        tags,\n      })\n\n      // Clear form only if creating new (not editing)\n      if (!initialData) {\n        setTitle('')\n        setDescription('')\n        setIsPublic(false)\n        setTags([])\n      }\n    } catch (error) {\n      // Error handling done by parent component\n      console.error('Form submission error:', error)\n    } finally {\n      // Always reset loading state, even if error occurred\n      setLoading(false)\n    }\n  }\n  // CLOSE: handle-submit\n\n  /**\n   * REF: tag-management\n   *\n   * ## Tag Management Functions\n   *\n   * Handle adding and removing tags.\n   *\n   * ### Array Immutability\n   *\n   * React requires immutable state updates:\n   * ```typescript\n   * // âœ… Correct - creates new array\n   * setTags([...tags, newTag])\n   *\n   * // âŒ Wrong - mutates existing array\n   * tags.push(newTag)\n   * setTags(tags)\n   * ```\n   *\n   * ### Validation\n   *\n   * - Tag must not be empty\n   * - No duplicate tags\n   * - Maximum 10 tags\n   *\n   * ### Normalization\n   *\n   * Tags converted to lowercase for consistency.\n   */\n  const handleAddTag = () => {\n    const newTag = tagInput.trim().toLowerCase()\n\n    if (!newTag) return\n    if (tags.includes(newTag)) {\n      alert('Tag already exists')\n      return\n    }\n    if (tags.length >= 10) {\n      alert('Maximum 10 tags allowed')\n      return\n    }\n\n    setTags([...tags, newTag])\n    setTagInput('')\n  }\n\n  const handleRemoveTag = (tagToRemove: string) => {\n    setTags(tags.filter(tag => tag !== tagToRemove))\n  }\n\n  const handleTagKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      e.preventDefault()\n      handleAddTag()\n    }\n  }\n  // CLOSE: tag-management\n\n  /**\n   * REF: form-render\n   *\n   * ## Form JSX Render\n   *\n   * Renders the complete form UI.\n   *\n   * ### Structure\n   *\n   * 1. Form wrapper with `onSubmit`\n   * 2. Title input (required)\n   * 3. Description textarea (optional)\n   * 4. Public/private toggle\n   * 5. Tags input with chip display\n   * 6. Submit button with loading state\n   *\n   * ### Controlled Inputs\n   *\n   * All inputs are \"controlled\":\n   * - `value={state}`: React controls the value\n   * - `onChange`: Updates state\n   * - Single source of truth\n   */\n  return (\n    <form onSubmit={handleSubmit} className=\"space-y-4\">\n      {/* Title Input */}\n      <div>\n        <label htmlFor=\"title\" className=\"block text-sm font-medium mb-2\">\n          Title <span className=\"text-red-500\">*</span>\n        </label>\n        <input\n          id=\"title\"\n          type=\"text\"\n          value={title}\n          onChange={(e) => setTitle(e.target.value)}\n          required\n          maxLength={500}\n          className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n          placeholder=\"Enter todo title...\"\n        />\n      </div>\n\n      {/* Description Textarea */}\n      <div>\n        <label htmlFor=\"description\" className=\"block text-sm font-medium mb-2\">\n          Description\n        </label>\n        <textarea\n          id=\"description\"\n          value={description}\n          onChange={(e) => setDescription(e.target.value)}\n          maxLength={2000}\n          rows={4}\n          className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n          placeholder=\"Add more details (optional)...\"\n        />\n      </div>\n\n      {/* Public/Private Toggle */}\n      <div className=\"flex items-center gap-2\">\n        <input\n          id=\"isPublic\"\n          type=\"checkbox\"\n          checked={isPublic}\n          onChange={(e) => setIsPublic(e.target.checked)}\n          className=\"w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500\"\n        />\n        <label htmlFor=\"isPublic\" className=\"text-sm font-medium cursor-pointer\">\n          Make this todo public (visible in community feed)\n        </label>\n      </div>\n\n      {/* Tags Input */}\n      <div>\n        <label htmlFor=\"tags\" className=\"block text-sm font-medium mb-2\">\n          Tags\n        </label>\n        <div className=\"flex gap-2 mb-2\">\n          <input\n            id=\"tags\"\n            type=\"text\"\n            value={tagInput}\n            onChange={(e) => setTagInput(e.target.value)}\n            onKeyDown={handleTagKeyDown}\n            maxLength={50}\n            className=\"flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n            placeholder=\"Add a tag...\"\n          />\n          <button\n            type=\"button\"\n            onClick={handleAddTag}\n            className=\"px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600 transition\"\n          >\n            Add Tag\n          </button>\n        </div>\n\n        {/* Display Current Tags */}\n        {tags.length > 0 && (\n          <div className=\"flex flex-wrap gap-2\">\n            {tags.map(tag => (\n              <span\n                key={tag}\n                className=\"inline-flex items-center gap-1 px-3 py-1 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 rounded-full text-sm\"\n              >\n                {tag}\n                <button\n                  type=\"button\"\n                  onClick={() => handleRemoveTag(tag)}\n                  className=\"text-blue-600 hover:text-blue-800 dark:text-blue-300 dark:hover:text-blue-100\"\n                  aria-label={`Remove ${tag} tag`}\n                >\n                  Ã—\n                </button>\n              </span>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Submit Button */}\n      <button\n        type=\"submit\"\n        disabled={loading}\n        className=\"w-full py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition\"\n      >\n        {loading ? 'Saving...' : submitButtonText}\n      </button>\n    </form>\n  )\n}\n// CLOSE: form-render\n// CLOSE: todo-form-function\n// CLOSE: todo-form-component\n",
      "language": "typescript"
    },
    {
      "path": "components/todos/TodoItem.tsx",
      "content": "/**\n * REF: todo-item-component\n *\n * # TodoItem Component\n *\n * Individual todo display with inline actions.\n *\n * ## Key Concepts\n *\n * - **Component state** - Edit mode managed locally\n * - **Conditional rendering** - Different UI for view/edit modes\n * - **Event handling** - Checkbox, buttons, form submissions\n * - **Dynamic styling** - Visual feedback for completion status\n *\n * ## Features\n *\n * | Feature | Description |\n * |---------|-------------|\n * | Toggle completion | Checkbox to mark done/undone |\n * | Inline editing | Edit in place without navigation |\n * | Delete | Remove todo with single click |\n * | Tags display | Show associated categories |\n * | Responsive design | Works on all screen sizes |\n *\n * ## Component States\n *\n * 1. **View mode** - Default display state\n * 2. **Edit mode** - Form for modifying todo\n * 3. **Completed** - Strikethrough and muted styling\n * 4. **Active** - Normal display for tasks in progress\n */\n\n'use client'\n\nimport { useState } from 'react'\nimport { Todo } from '@/types'\n\n/**\n * REF: todo-item-props\n *\n * ## TodoItem Props Interface\n *\n * Contract for single todo display.\n *\n * ### Props\n *\n * | `Prop` | Type | Description |\n * |------|------|-------------|\n * | `todo` | `Todo` | The todo object to display |\n * | `onToggleComplete` | `Function` | Callback for completion toggle |\n * | `onUpdate` | `Function` | Callback for todo updates |\n * | `onDelete` | `Function` | Callback for todo deletion |\n *\n * ### Data Flow\n *\n * ```\n * Dashboard â†’ TodoList â†’ TodoItem\n *    â†‘                      â†“\n *    â†â”€â”€â”€ Callbacks â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n * ```\n */\ninterface TodoItemProps {\n  todo: Todo\n  onToggleComplete: (todoId: string, completed: boolean) => void\n  onUpdate: (todoId: string, updates: Partial<Todo>) => void\n  onDelete: (todoId: string) => void\n}\n// CLOSE: todo-item-props\n\nexport default function TodoItem({\n  todo,\n  onToggleComplete,\n  onUpdate,\n  onDelete,\n}: TodoItemProps) {\n  /**\n   * REF: edit-mode-state\n   *\n   * # Edit Mode State Management\n   *\n   * Local state controlling the edit form display and temporary values.\n   *\n   * ## State Variables\n   *\n   * | `Variable` | Type | Purpose |\n   * |----------|------|---------|\n   * | `isEditing` | `boolean` | Controls whether to show edit form vs view |\n   * | `editTitle` | `string` | Temporary title value during editing |\n   * | `editDescription` | `string` | Temporary description during editing |\n   *\n   * ## Why Local State?\n   *\n   * - Edit is a temporary, local action\n   * - Don't update database until user clicks \"Save\"\n   * - If user clicks \"Cancel\", changes are discarded\n   * - Reduces unnecessary database writes\n   * - Better user experience (no immediate persistence)\n   */\n  const [isEditing, setIsEditing] = useState(false)\n  const [editTitle, setEditTitle] = useState(todo.title)\n  const [editDescription, setEditDescription] = useState(todo.description || '')\n  // CLOSE: edit-mode-state\n\n  /**\n   * REF: toggle-completion-handler\n   *\n   * # Toggle Completion Handler\n   *\n   * Flips the completed status of the todo and notifies parent component.\n   *\n   * ## Behavior\n   *\n   * - Calls parent's onToggleComplete callback\n   * - Passes todoId and new completion status\n   * - Parent handles database persistence\n   * - UI updates via parent's state management\n   */\n  const handleToggle = () => {\n    onToggleComplete(todo.id, !todo.completed)\n  }\n  // CLOSE: toggle-completion-handler\n\n  /**\n   * REF: start-edit-mode\n   *\n   * # Start Edit Mode Handler\n   *\n   * Initializes the edit form with current todo values.\n   *\n   * ## Behavior\n   *\n   * 1. Populate edit fields with current values\n   * 2. Set isEditing to true (shows form)\n   * 3. User can now modify values in input fields\n   *\n   * ## UI Transition\n   *\n   * View mode â†’ Edit mode with form inputs\n   */\n  const handleEdit = () => {\n    setEditTitle(todo.title)\n    setEditDescription(todo.description || '')\n    setIsEditing(true)\n  }\n  // CLOSE: start-edit-mode\n\n  /**\n   * REF: save-edits-handler\n   *\n   * # Save Edits Handler\n   *\n   * Validates and persists edited todo data.\n   *\n   * ## Validation\n   *\n   * - Title must not be empty\n   * - Shows alert if validation fails\n   * - Returns early to prevent save\n   *\n   * ## Data Persistence\n   *\n   * - Calls parent's onUpdate callback\n   * - Sends trimmed title and description\n   * - Exits edit mode on success\n   *\n   * ## Data Flow\n   *\n   * ```\n   * Input validation â†’ onUpdate callback â†’ Parent updates database\n   *                                      â†’ UI re-renders\n   *                                      â†’ Edit mode closes\n   * ```\n   */\n  const handleSave = () => {\n    if (!editTitle.trim()) {\n      alert('Title cannot be empty')\n      return\n    }\n\n    onUpdate(todo.id, {\n      title: editTitle.trim(),\n      description: editDescription.trim(),\n    })\n\n    setIsEditing(false)\n  }\n  // CLOSE: save-edits-handler\n\n  /**\n   * REF: cancel-edit-handler\n   *\n   * # Cancel Edit Handler\n   *\n   * Exits edit mode without persisting changes.\n   *\n   * ## Behavior\n   *\n   * - Discards all temporary edits\n   * - Sets isEditing to false\n   * - Original values remain unchanged\n   * - No database update occurs\n   */\n  const handleCancel = () => {\n    setIsEditing(false)\n  }\n  // CLOSE: cancel-edit-handler\n\n  /**\n   * REF: delete-handler\n   *\n   * # Delete Handler\n   *\n   * Deletes the todo by calling parent callback.\n   *\n   * ## Behavior\n   *\n   * - Calls parent's onDelete callback\n   * - Passes todo ID\n   * - Parent handles deletion logic and database update\n   */\n  const handleDelete = () => {\n    onDelete(todo.id)\n  }\n  // CLOSE: delete-handler\n\n  /**\n   * REF: edit-mode-render\n   *\n   * # Edit Mode Render\n   *\n   * Displays form with input fields for editing todo content.\n   *\n   * ## Form Fields\n   *\n   * | `Field` | Type | Description |\n   * |-------|------|-------------|\n   * | `Title` | text input | Todo title (required) |\n   * | Description | `textarea` | Todo description (optional) |\n   * | Save button | `button` | Persists changes |\n   * | Cancel button | `button` | Discards changes |\n   *\n   * ## Styling\n   *\n   * - Gray background to indicate edit mode\n   * - Focused inputs have blue ring\n   * - Dark mode support with dark: variants\n   *\n   * ## User Flow\n   *\n   * Edit button â†’ Edit mode render â†’ Fill fields â†’ Save/Cancel\n   */\n  if (isEditing) {\n    return (\n      <div className=\"p-4 bg-gray-50 dark:bg-gray-700 rounded-lg border border-gray-200 dark:border-gray-600\">\n        <div className=\"space-y-3\">\n          <input\n            type=\"text\"\n            value={editTitle}\n            onChange={(e) => setEditTitle(e.target.value)}\n            className=\"w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-600 dark:border-gray-500\"\n            placeholder=\"Todo title\"\n          />\n          <textarea\n            value={editDescription}\n            onChange={(e) => setEditDescription(e.target.value)}\n            rows={3}\n            className=\"w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-600 dark:border-gray-500\"\n            placeholder=\"Description (optional)\"\n          />\n          <div className=\"flex gap-2\">\n            <button\n              onClick={handleSave}\n              className=\"px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition\"\n            >\n              Save\n            </button>\n            <button\n              onClick={handleCancel}\n              className=\"px-4 py-2 bg-gray-300 dark:bg-gray-600 rounded hover:bg-gray-400 dark:hover:bg-gray-500 transition\"\n            >\n              Cancel\n            </button>\n          </div>\n        </div>\n      </div>\n    )\n  }\n  // CLOSE: edit-mode-render\n\n  /**\n   * REF: view-mode-render\n   *\n   * # View Mode Render\n   *\n   * Displays the todo in read-only format with inline actions.\n   *\n   * ## Layout Structure\n   *\n   * | `Component` | Purpose |\n   * |-----------|---------|\n   * | `Checkbox` | Toggle completion status |\n   * | `Title` | Main todo text (strikethrough if complete) |\n   * | Description | Optional details (if provided) |\n   * | `Tags` | Category labels (if any) |\n   * | Visibility Badge | Public/Private indicator |\n   * | Action Buttons | Edit and Delete |\n   *\n   * ## Dynamic Styling\n   *\n   * **Completed todos:**\n   * - Strikethrough title and description\n   * - Reduced opacity\n   * - Visual indication of status\n   *\n   * **Public/Private Badge:**\n   * - Green badge for public todos\n   * - Gray badge for private todos\n   * - Emoji icon for quick visual reference\n   *\n   * ## Interactive Elements\n   *\n   * - Checkbox: Triggers completion toggle\n   * - Edit button: Enters edit mode\n   * - Delete button: Removes todo\n   * - Hover effects: Show interactivity on buttons\n   *\n   * ## Responsive Behavior\n   *\n   * - Flex layout adapts to screen size\n   * - Buttons right-aligned\n   * - Long titles wrap naturally\n   * - Tags wrap to new lines if needed\n   */\n  return (\n    <div className=\"p-4 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 hover:shadow-md transition\">\n      <div className=\"flex items-start gap-4\">\n        {/* Completion Checkbox */}\n        <input\n          type=\"checkbox\"\n          checked={todo.completed}\n          onChange={handleToggle}\n          className=\"mt-1 w-5 h-5 text-blue-600 rounded focus:ring-2 focus:ring-blue-500 cursor-pointer\"\n        />\n\n        {/* Todo Content */}\n        <div className=\"flex-1\">\n          {/* Title */}\n          <h4\n            className={`text-lg font-medium ${\n              todo.completed ? 'line-through text-gray-500' : ''\n            }`}\n          >\n            {todo.title}\n          </h4>\n\n          {/* Description */}\n          {todo.description && (\n            <p\n              className={`mt-1 text-gray-600 dark:text-gray-300 ${\n                todo.completed ? 'line-through' : ''\n              }`}\n            >\n              {todo.description}\n            </p>\n          )}\n\n          {/* Tags */}\n          {todo.tags && todo.tags.length > 0 && (\n            <div className=\"flex flex-wrap gap-2 mt-2\">\n              {todo.tags.map(tag => (\n                <span\n                  key={tag}\n                  className=\"px-2 py-1 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 text-xs rounded-full\"\n                >\n                  #{tag}\n                </span>\n              ))}\n            </div>\n          )}\n\n          {/* Public/Private Badge */}\n          <div className=\"mt-2\">\n            <span\n              className={`text-xs px-2 py-1 rounded ${\n                todo.isPublic\n                  ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'\n                  : 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'\n              }`}\n            >\n              {todo.isPublic ? 'ðŸŒ Public' : 'ðŸ”’ Private'}\n            </span>\n          </div>\n        </div>\n\n        {/* Action Buttons */}\n        <div className=\"flex gap-2\">\n          <button\n            onClick={handleEdit}\n            className=\"p-2 text-blue-600 hover:bg-blue-50 dark:hover:bg-blue-900 rounded transition\"\n            aria-label=\"Edit todo\"\n          >\n            âœï¸\n          </button>\n          <button\n            onClick={handleDelete}\n            className=\"p-2 text-red-600 hover:bg-red-50 dark:hover:bg-red-900 rounded transition\"\n            aria-label=\"Delete todo\"\n          >\n            ðŸ—‘ï¸\n          </button>\n        </div>\n      </div>\n    </div>\n  )\n  // CLOSE: view-mode-render\n}\n// CLOSE: todo-item-component\n",
      "language": "typescript"
    },
    {
      "path": "components/todos/TodoList.tsx",
      "content": "/**\n * REF: todo-list-component\n *\n * # TodoList Component\n *\n * Renders a list of todos with actions.\n *\n * ## Key Concepts\n *\n * - **List rendering** - Mapping arrays to UI elements\n * - **Component composition** - Breaking UI into smaller parts\n * - **Props drilling** - Passing functions through components\n * - **Keys in lists** - React reconciliation for efficiency\n *\n * ## Performance Optimizations\n *\n * - TodoItem components for separation of concerns\n * - React keys enable selective re-rendering\n * - Filtered arrays for better organization\n * - Minimal state in this component (stateless)\n */\n\n'use client'\n\nimport { Todo } from '@/types'\nimport TodoItem from './TodoItem'\n\n/**\n * REF: todo-list-props\n *\n * ## TodoList Props Interface\n *\n * Defines the contract between parent and child components.\n *\n * ### Props\n *\n * | `Prop` | Type | Description |\n * |------|------|-------------|\n * | `todos` | `Todo[]` | Array of todo objects to display |\n * | `onToggleComplete` | `Function` | Mark todo as complete/incomplete |\n * | `onUpdate` | `Function` | Update any todo field |\n * | `onDelete` | `Function` | Delete a todo |\n *\n * ### Callback Pattern\n *\n * This implements the \"lifting state up\" pattern:\n * 1. Parent (Dashboard) maintains state\n * 2. Child (TodoList) receives data and callbacks\n * 3. Grandchild (TodoItem) calls callbacks to modify state\n *\n * ### Example Usage\n *\n * ```tsx\n * <TodoList\n *   todos={userTodos}\n *   onToggleComplete={handleToggle}\n *   onUpdate={handleUpdate}\n *   onDelete={handleDelete}\n * />\n * ```\n */\ninterface TodoListProps {\n  todos: Todo[]\n  onToggleComplete: (todoId: string, completed: boolean) => void\n  onUpdate: (todoId: string, updates: Partial<Todo>) => void\n  onDelete: (todoId: string) => void\n}\n// CLOSE: todo-list-props\n\n/**\n * REF: todo-list-function\n *\n * ## TodoList Component Function\n *\n * Stateless functional component that displays todos.\n *\n * ### Component Architecture\n *\n * - **Pure component** - No internal state\n * - **Controlled by parent** - All data from props\n * - **Event delegation** - Passes events to parent\n * - **Separation of concerns** - Display only\n */\nexport default function TodoList({\n  todos,\n  onToggleComplete,\n  onUpdate,\n  onDelete,\n}: TodoListProps) {\n  /**\n   * REF: todo-filtering\n   *\n   * ## Separate Active and Completed Todos\n   *\n   * Filters todos into two categories for better UX.\n   *\n   * ### Why Separate?\n   *\n   * - **Focus on active tasks** - What needs to be done\n   * - **Visual hierarchy** - Active todos more prominent\n   * - **Sense of progress** - See completed items separately\n   * - **Clean interface** - Less cognitive load\n   *\n   * ### Array Filter Method\n   *\n   * ```typescript\n   * // filter() creates new array without modifying original\n   * const filtered = array.filter(item => condition)\n   * ```\n   *\n   * - **Immutable operation** - Original array unchanged\n   * - **Functional programming** - Pure function\n   * - **Type-safe** - TypeScript knows return type\n   */\n  const activeTodos = todos.filter(todo => !todo.completed)\n  const completedTodos = todos.filter(todo => todo.completed)\n  // CLOSE: todo-filtering\n\n  /**\n   * REF: todo-list-render\n   *\n   * ## Component Render\n   *\n   * JSX structure for displaying todos.\n   *\n   * ### Layout Structure\n   *\n   * 1. **Active todos section** - Always visible if any exist\n   * 2. **Completed todos section** - Shown separately below\n   *\n   * ### List Mapping Pattern\n   *\n   * ```tsx\n   * {items.map(item => (\n   *   <Component key={item.id} {...props} />\n   * ))}\n   * ```\n   *\n   * ### Why Keys Matter in React\n   *\n   * | Without Keys | With Keys |\n   * |--------------|-----------|\n   * | React re-renders entire list | React re-renders only changed items |\n   * | Poor performance with large lists | Efficient updates |\n   * | Can lose component state | Preserves component state |\n   * | Animations may break | Smooth animations |\n   *\n   * ### React Reconciliation\n   *\n   * Keys help React's virtual DOM diffing algorithm:\n   * 1. React compares new virtual DOM with previous\n   * 2. Keys identify which items are same/different\n   * 3. Only changed items get re-rendered to real DOM\n   * 4. Massive performance improvement for lists\n   */\n  /** REF: todo-list-container\n   * Main container for todo list with sections for active and completed todos.\n   * Provides spacing and organization for todo items.\n   */\n  return (\n  // CLOSE: todo-list-render\n          <div className=\"space-y-6\">\n      {/* Active Todos Section */}\n      {activeTodos.length > 0 && (\n        <div>\n          <h3 className=\"text-lg font-semibold mb-3\">\n            Active ({activeTodos.length})\n          </h3>\n          {/** REF: active-todos-list\n           * Maps through active todos and renders TodoItem for each.\n           * Displays todo items with full interaction capabilities.\n           */}\n          <div className=\"space-y-2\">\n            {activeTodos.map(todo => (\n              <TodoItem\n                key={todo.id} // CRITICAL: unique key for each item\n                todo={todo}\n                onToggleComplete={onToggleComplete}\n                onUpdate={onUpdate}\n                onDelete={onDelete}\n              />\n            ))}\n          </div>\n          {/* CLOSE: active-todos-list */}\n        </div>\n      )}\n\n            {/* Completed Todos Section */}\n      {completedTodos.length > 0 && (\n        <div>\n          <h3 className=\"text-lg font-semibold mb-3 text-gray-500\">\n            Completed ({completedTodos.length})\n          </h3>\n          {/** REF: completed-todos-list\n           * Maps through completed todos and renders TodoItem for each.\n           * Displays with reduced opacity to distinguish from active items.\n           */}\n          <div className=\"space-y-2 opacity-75\">\n            {completedTodos.map(todo => (\n              <TodoItem\n                key={todo.id}\n                todo={todo}\n                onToggleComplete={onToggleComplete}\n                onUpdate={onUpdate}\n                onDelete={onDelete}\n              />\n            ))}\n          </div>\n          {/* CLOSE: completed-todos-list */}\n        </div>\n      )}\n\n            {/* Empty State */}\n      {todos.length === 0 && (\n        <p className=\"text-center text-gray-500 py-8\">\n          No todos found. Create one to get started!\n        </p>\n      )}\n    </div>\n    // CLOSE: todo-list-container\n  )\n}\n// CLOSE: todo-list-function\n// CLOSE: todo-list-component\n",
      "language": "typescript"
    },
    {
      "path": "components/ui/LoadingSpinner.tsx",
      "content": "/**\n * REF: loading-spinner\n *\n * # LoadingSpinner Component\n *\n * Reusable loading indicator for async operations.\n *\n * ## Key Concepts\n *\n * - **Reusable components** - DRY principle\n * - **Props for customization** - Size and text\n * - **CSS animations** - Tailwind's `animate-spin`\n * - **Accessibility** - ARIA roles\n *\n * ## Usage\n *\n * ```tsx\n * <LoadingSpinner size=\"lg\" text=\"Loading todos...\" />\n * ```\n *\n * ## Why Separate Component?\n *\n * - Consistent loading UI across app\n * - Easy to update in one place\n * - Can swap implementation later\n */\n\n/**\n * REF: spinner-props\n *\n * ## Component Props\n *\n * - `size?`: Spinner size (sm, md, lg)\n * - `text?`: Optional loading message\n * - `className?`: Additional CSS classes\n */\ninterface LoadingSpinnerProps {\n  size?: 'sm' | 'md' | 'lg'\n  text?: string\n  className?: string\n}\n// CLOSE: spinner-props\n\n/**\n * REF: spinner-component\n *\n * ## LoadingSpinner Function\n *\n * Renders animated spinner with optional text.\n */\nexport default function LoadingSpinner({\n  size = 'md',\n  text,\n  className = '',\n}: LoadingSpinnerProps) {\n  /**\n   * REF: size-mapping\n   *\n   * ## Size Classes Mapping\n   *\n   * Maps size prop to Tailwind classes.\n   *\n   * - `sm`: Small (16px)\n   * - `md`: Medium (32px)\n   * - `lg`: Large (48px)\n   */\n  const sizeClasses = {\n    sm: 'w-4 h-4 border-2',\n    md: 'w-8 h-8 border-4',\n    lg: 'w-12 h-12 border-4',\n  }\n  // CLOSE: size-mapping\n\n  /**\n   * REF: spinner-render\n   *\n   * ## Spinner UI\n   *\n   * Animated spinning circle with optional text.\n   *\n   * ### Animation\n   *\n   * - `border-current`: Uses text color for border\n   * - `border-t-transparent`: Top border invisible (creates gap)\n   * - `rounded-full`: Circular shape\n   * - `animate-spin`: Tailwind rotation animation\n   *\n   * ### Accessibility\n   *\n   * - `role=\"status\"`: ARIA role for loading state\n   * - `aria-label`: Screen reader description\n   */\n  return (\n    <div className={`flex flex-col items-center justify-center gap-3 ${className}`}>\n      {/* Spinner */}\n      <div\n        className={`\n          ${sizeClasses[size]}\n          border-current\n          border-t-transparent\n          rounded-full\n          animate-spin\n        `}\n        role=\"status\"\n        aria-label=\"Loading\"\n      />\n\n      {/* Optional Text */}\n      {text && (\n        <p className=\"text-sm text-gray-600 dark:text-gray-300\">\n          {text}\n        </p>\n      )}\n    </div>\n  )\n}\n// CLOSE: spinner-render\n// CLOSE: spinner-component\n// CLOSE: loading-spinner\n",
      "language": "typescript"
    },
    {
      "path": "contexts/AuthContext.tsx",
      "content": "/**\n * REF: auth-context-file\n *\n * # Authentication Context\n *\n * Global authentication state management using React Context API.\n *\n * ## Key Concepts\n *\n * - **React Context:** Share state across component tree\n * - **Firebase Auth:** User authentication and sessions\n * - **Custom Hook:** `useAuth()` for accessing context\n * - **Auth State:** User object and authentication methods\n *\n * ## Why Context API?\n *\n * Instead of prop drilling:\n * ```tsx\n * <App user={user}>\n *   <Dashboard user={user}>\n *     <TodoList user={user} />\n *   </Dashboard>\n * </App>\n * ```\n *\n * Use context:\n * ```tsx\n * <AuthProvider>\n *   <App />  // user available anywhere via useAuth()\n * </AuthProvider>\n * ```\n *\n * **Audio Guide:** `audio/nextjs-firebase/auth-context.mp3`\n */\n\n'use client'\n\nimport { createContext, useContext, useEffect, useState, ReactNode } from 'react'\nimport {\n  User,\n  createUserWithEmailAndPassword,\n  signInWithEmailAndPassword,\n  signOut as firebaseSignOut,\n  onAuthStateChanged,\n  updateProfile,\n} from 'firebase/auth'\nimport { doc, setDoc, getDoc } from 'firebase/firestore'\nimport { auth, db } from '@/lib/firebase/client'\n\n/**\n * REF: auth-context-type\n *\n * ## AuthContext Type Definition\n *\n * Defines the shape of authentication data available to components.\n *\n * ### Properties\n *\n * - `user`: Current user object (or null if not logged in)\n * - `loading`: True while checking auth state\n * - `signUp`: Function to create new account\n * - `signIn`: Function to authenticate user\n * - `signOut`: Function to log out\n * - `updateUserProfile`: Function to update display name/photo\n *\n * ### TypeScript Interface\n *\n * Provides autocomplete and type safety:\n * ```typescript\n * const { user, signIn } = useAuth()\n * // TypeScript knows exact types!\n * ```\n */\ninterface AuthContextType {\n  user: User | null\n  loading: boolean\n  signUp: (email: string, password: string, displayName?: string) => Promise<void>\n  signIn: (email: string, password: string) => Promise<void>\n  signOut: () => Promise<void>\n  updateUserProfile: (displayName?: string, photoURL?: string) => Promise<void>\n}\n// CLOSE: auth-context-type\n\n/**\n * REF: create-auth-context\n *\n * ## Create Auth Context\n *\n * Initialize context with default values.\n *\n * ### Default Values\n *\n * - `user: null` - No user initially\n * - `loading: true` - Loading until auth checked\n * - Functions: Empty async functions (will be replaced by provider)\n *\n * ### Why Default Values?\n *\n * TypeScript requires initial value for context.\n * These are immediately replaced by AuthProvider.\n */\nconst AuthContext = createContext<AuthContextType>({\n  user: null,\n  loading: true,\n  signUp: async () => {},\n  signIn: async () => {},\n  signOut: async () => {},\n  updateUserProfile: async () => {},\n})\n// CLOSE: create-auth-context\n\n/**\n * REF: auth-provider-component\n *\n * ## AuthProvider Component\n *\n * Wraps app to provide authentication state globally.\n *\n * ### Usage\n *\n * In `app/layout.tsx`:\n * ```tsx\n * <AuthProvider>\n *   {children}\n * </AuthProvider>\n * ```\n *\n * Now any component can use `useAuth()` to access auth state.\n *\n * ### State Management\n *\n * Manages two pieces of state:\n * - `user`: Current user (or null)\n * - `loading`: Auth check in progress\n */\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  /**\n   * Local state for user and loading status.\n   */\n  const [user, setUser] = useState<User | null>(null)\n  const [loading, setLoading] = useState(true)\n\n  /**\n   * REF: auth-state-listener\n   *\n   * ## Auth State Listener\n   *\n   * Firebase's `onAuthStateChanged` fires when:\n   * - User signs in\n   * - User signs out\n   * - Page loads (restores session)\n   * - Auth token refreshes\n   *\n   * ### Effect Cleanup\n   *\n   * Returns `unsubscribe` function:\n   * - Called when component unmounts\n   * - Stops listening to auth changes\n   * - Prevents memory leaks\n   *\n   * ### User Profile Creation\n   *\n   * When new user signs in:\n   * 1. Check if Firestore document exists\n   * 2. If not, create user profile\n   * 3. Create default settings\n   */\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, async (user) => {\n      setUser(user)\n      setLoading(false)\n\n      // Create user document if it doesn't exist\n      if (user) {\n        const userRef = doc(db, 'users', user.uid)\n        const userDoc = await getDoc(userRef)\n\n        if (!userDoc.exists()) {\n          await setDoc(userRef, {\n            email: user.email,\n            displayName: user.displayName || '',\n            profilePicture: user.photoURL || '',\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          })\n\n          // Create default user settings\n          const settingsRef = doc(db, 'userSettings', user.uid)\n          await setDoc(settingsRef, {\n            userId: user.uid,\n            theme: 'light',\n            fontSize: 'medium',\n            highContrast: false,\n            reducedMotion: false,\n            updatedAt: new Date(),\n          })\n        }\n      }\n    })\n\n    return unsubscribe\n  }, [])\n  // CLOSE: auth-state-listener\n\n  /**\n   * REF: signup-method\n   *\n   * ## Sign Up Method\n   *\n   * Creates new Firebase user account.\n   *\n   * ### Parameters\n   *\n   * - `email`: User's email\n   * - `password`: User's password (min 6 chars)\n   * - `displayName?`: Optional display name\n   *\n   * ### Flow\n   *\n   * 1. Create auth user with email/password\n   * 2. If displayName provided, update profile\n   * 3. `onAuthStateChanged` fires\n   * 4. User profile created in Firestore\n   */\n  const signUp = async (email: string, password: string, displayName?: string) => {\n    const result = await createUserWithEmailAndPassword(auth, email, password)\n\n    if (displayName && result.user) {\n      await updateProfile(result.user, { displayName })\n    }\n  }\n  // CLOSE: signup-method\n\n  /**\n   * REF: signin-method\n   *\n   * ## Sign In Method\n   *\n   * Authenticates existing user.\n   *\n   * ### Firebase Auth\n   *\n   * - Validates email/password\n   * - Returns user object\n   * - `onAuthStateChanged` fires\n   * - Context updates automatically\n   */\n  const signIn = async (email: string, password: string) => {\n    await signInWithEmailAndPassword(auth, email, password)\n  }\n  // CLOSE: signin-method\n\n  /**\n   * REF: signout-method\n   *\n   * ## Sign Out Method\n   *\n   * Logs out current user.\n   *\n   * ### Effects\n   *\n   * - Clears localStorage auth tokens\n   * - `onAuthStateChanged` fires with null\n   * - Context sets user to null\n   * - User redirected to login\n   */\n  const signOut = async () => {\n    await firebaseSignOut(auth)\n  }\n  // CLOSE: signout-method\n\n  /**\n   * REF: update-profile-method\n   *\n   * ## Update User Profile\n   *\n   * Updates display name and/or photo URL.\n   *\n   * ### Two Updates Required\n   *\n   * 1. **Firebase Auth profile:**\n   *    - Updates `auth.currentUser`\n   *    - For authentication system\n   *\n   * 2. **Firestore user document:**\n   *    - Updates searchable profile\n   *    - For displaying in app\n   *\n   * Both must stay in sync!\n   */\n  const updateUserProfile = async (displayName?: string, photoURL?: string) => {\n    if (!user) return\n\n    const updates: { displayName?: string; photoURL?: string } = {}\n    if (displayName !== undefined) updates.displayName = displayName\n    if (photoURL !== undefined) updates.photoURL = photoURL\n\n    await updateProfile(user, updates)\n\n    // Update Firestore user document\n    const userRef = doc(db, 'users', user.uid)\n    await setDoc(\n      userRef,\n      {\n        displayName: displayName || user.displayName,\n        profilePicture: photoURL || user.photoURL,\n        updatedAt: new Date(),\n      },\n      { merge: true }\n    )\n  }\n  // CLOSE: update-profile-method\n\n  /**\n   * REF: context-value\n   *\n   * ## Create Context Value\n   *\n   * Combine state and methods into context value.\n   *\n   * All components using `useAuth()` get:\n   * - Current user\n   * - Loading status\n   * - Authentication methods\n   */\n  const value = {\n    user,\n    loading,\n    signUp,\n    signIn,\n    signOut,\n    updateUserProfile,\n  }\n  // CLOSE: context-value\n\n  /**\n   * Provide context value to all children.\n   */\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>\n}\n// CLOSE: auth-provider-component\n\n/**\n * REF: use-auth-hook\n *\n * ## useAuth Custom Hook\n *\n * Access authentication context in any component.\n *\n * ### Usage\n *\n * ```tsx\n * function MyComponent() {\n *   const { user, signIn, signOut } = useAuth()\n *\n *   if (!user) return <Login />\n *   return <Dashboard user={user} onSignOut={signOut} />\n * }\n * ```\n *\n * ### Error Handling\n *\n * Throws error if used outside `AuthProvider`:\n * - Catches mistakes early\n * - Clear error message\n * - Helps debugging\n */\nexport function useAuth() {\n  const context = useContext(AuthContext)\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider')\n  }\n  return context\n}\n// CLOSE: use-auth-hook\n// CLOSE: auth-context-file\n",
      "language": "typescript"
    },
    {
      "path": "lib/firebase/admin.ts",
      "content": "/**\n * REF: firebase-admin-setup\n *\n * # Firebase Admin SDK Configuration\n *\n * Server-side Firebase SDK for privileged operations.\n *\n * ## Client SDK vs Admin SDK\n *\n * | Feature | Client SDK | Admin SDK |\n * |---------|------------|-----------|\n * | **Where** | `Browser` | Server only |\n * | **Auth** | User tokens | Service account |\n * | **Security** | Rules enforced | **Bypasses rules** |\n * | **Use for** | User operations | Admin operations |\n *\n * ### When to Use Admin SDK\n *\n * - Server-side operations (API routes, Server Actions)\n * - Bulk operations\n * - Admin tasks\n * - Bypassing security rules (carefully!)\n *\n * ### Security Warning\n *\n * âš ï¸ Admin SDK bypasses all security rules!\n * - Never expose credentials to client\n * - Only use in server-side code\n * - Add your own authorization checks\n *\n * **Audio Guide:** `audio/nextjs-firebase/firebase-admin.mp3`\n */\n\nimport { initializeApp, getApps, cert } from 'firebase-admin/app'\nimport { getAuth } from 'firebase-admin/auth'\nimport { getFirestore } from 'firebase-admin/firestore'\nimport { getStorage } from 'firebase-admin/storage'\n\n/**\n * REF: admin-initialization\n *\n * ## Initialize Firebase Admin SDK\n *\n * Uses singleton pattern like client SDK.\n *\n * ### Service Account Credentials\n *\n * Requires three environment variables:\n * - `FIREBASE_ADMIN_PROJECT_ID`: Your Firebase project ID\n * - `FIREBASE_ADMIN_CLIENT_EMAIL`: Service account email\n * - `FIREBASE_ADMIN_PRIVATE_KEY`: Private key (with `\\n` replaced)\n *\n * ### Getting Credentials\n *\n * 1. Firebase Console â†’ Project Settings\n * 2. Service Accounts tab\n * 3. Generate new private key\n * 4. Download JSON file\n * 5. Extract values to `.env.local`\n *\n * ### Private Key Handling\n *\n * `.replace(/\\\\n/g, '\\n')` converts escaped newlines:\n * - Environment variables escape newlines as `\\\\n`\n * - Need actual newlines for the key to work\n * - This replacement fixes that\n */\nconst apps = getApps()\nconst adminApp =\n  apps.length === 0\n    ? initializeApp({\n        credential: cert({\n          projectId: process.env.FIREBASE_ADMIN_PROJECT_ID,\n          clientEmail: process.env.FIREBASE_ADMIN_CLIENT_EMAIL,\n          privateKey: process.env.FIREBASE_ADMIN_PRIVATE_KEY?.replace(/\\\\n/g, '\\n'),\n        }),\n      })\n    : apps[0]\n// CLOSE: admin-initialization\n\n/**\n * REF: admin-services\n *\n * ## Export Admin Services\n *\n * Prefix with `admin` to distinguish from client SDK.\n *\n * ### Usage Example\n *\n * ```typescript\n * import { adminDb } from '@/lib/firebase/admin'\n *\n * // In API route or Server Action\n * const snapshot = await adminDb.collection('users').get()\n * // Gets ALL users (bypasses security rules!)\n * ```\n *\n * ### Naming Convention\n *\n * - `adminAuth` vs `auth` (client)\n * - `adminDb` vs `db` (client)\n * - `adminStorage` vs `storage` (client)\n *\n * Clear distinction prevents mixing them up!\n */\nexport const adminAuth = getAuth(adminApp)\nexport const adminDb = getFirestore(adminApp)\nexport const adminStorage = getStorage(adminApp)\nexport default adminApp\n// CLOSE: admin-services\n// CLOSE: firebase-admin-setup\n",
      "language": "typescript"
    },
    {
      "path": "lib/firebase/client.ts",
      "content": "/**\n * REF: firebase-client-setup\n *\n * # Firebase Client Configuration\n *\n * This file initializes the Firebase SDK for client-side operations.\n *\n * ## Key Concepts\n *\n * - **Firebase SDK:** Library for Firebase services\n * - **Client-side:** Runs in user's browser (not server)\n * - **Environment Variables:** Secure config storage\n *\n * ## Why NEXT_PUBLIC_ Prefix?\n *\n * In Next.js, only env vars with `NEXT_PUBLIC_` are accessible in browser:\n * - Without prefix â†’ server-side only\n * - With prefix â†’ browser accessible\n * - Safe to expose (Firebase has security rules)\n *\n * ## Singleton Pattern\n *\n * Check if Firebase already initialized:\n * - Prevents \"Firebase app already exists\" errors\n * - Important in Next.js due to hot reloading\n *\n * **Audio Guide:** `audio/nextjs-firebase/firebase-client.mp3`\n */\n\nimport { initializeApp, getApps } from 'firebase/app'\nimport { getAuth } from 'firebase/auth'\nimport { getFirestore } from 'firebase/firestore'\nimport { getStorage } from 'firebase/storage'\n\n/**\n * REF: firebase-config-object\n *\n * ## Firebase Configuration Object\n *\n * These values come from your Firebase project settings.\n *\n * ### How to Get These Values\n *\n * 1. Go to [Firebase Console](https://console.firebase.google.com)\n * 2. Select your project\n * 3. Project Settings â†’ General\n * 4. Scroll to \"Your apps\"\n * 5. Copy config values\n */\nconst firebaseConfig = {\n  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\n}\n// CLOSE: firebase-config-object\n\n/**\n * REF: firebase-init\n *\n * ## Initialize Firebase App (Singleton Pattern)\n *\n * `getApps()` returns array of initialized Firebase apps:\n * - If array is empty â†’ initialize new app\n * - Otherwise â†’ use existing app at index 0\n *\n * ### Why Singleton?\n *\n * Prevents multiple initializations which cause errors:\n * - Next.js hot reloading could re-run this file\n * - Without check â†’ \"Firebase app already exists\" error\n * - With check â†’ Safe to run multiple times\n */\nconst app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApps()[0]\n// CLOSE: firebase-init\n\n/**\n * REF: firebase-services\n *\n * ## Initialize Firebase Services\n *\n * Get instances of Firebase services from the app.\n *\n * ### AUTH Service\n *\n * Handles user authentication:\n * - Sign up, sign in, sign out\n * - Manages user sessions and tokens\n * - Works with Firebase Authentication rules\n *\n * ### DB Service (Firestore)\n *\n * NoSQL document database:\n * - Stores todos, messages, user data\n * - Real-time listeners for live updates\n * - Works with Firestore Security Rules\n *\n * ### STORAGE Service\n *\n * File storage service:\n * - Stores profile pictures and attachments\n * - Works with Firebase Storage Rules\n */\nexport const auth = getAuth(app)\nexport const db = getFirestore(app)\nexport const storage = getStorage(app)\n// CLOSE: firebase-services\n\n/**\n * REF: app-export\n *\n * ## Export App Instance\n *\n * Export the Firebase app instance.\n *\n * **Rarely needed directly** - usually use the services (auth, db, storage).\n *\n * ### When to Use\n *\n * - Firebase Admin SDK initialization\n * - Advanced Firebase features\n * - Testing/debugging\n */\nexport default app\n// CLOSE: app-export\n// CLOSE: firebase-client-setup\n",
      "language": "typescript"
    },
    {
      "path": "lib/firebase/firestore.ts",
      "content": "/**\n * REF: firestore-file-header\n *\n * # Firestore Database Operations\n *\n * Centralized database operations for Firebase Firestore.\n *\n * ## Key Concepts\n *\n * - **Firestore:** NoSQL document database\n * - **Collections:** Groups of documents (like tables)\n * - **Documents:** Individual records (like rows)\n * - **Real-time:** Listen to changes with `onSnapshot`\n *\n * ## Why Helper Functions?\n *\n * - **Reusability:** Don't repeat query logic\n * - **Type safety:** TypeScript types enforced\n * - **Error handling:** Centralized error management\n * - **Consistency:** Same patterns throughout app\n *\n * ## File Organization\n *\n * This file contains 15+ helper functions grouped by:\n * 1. User operations\n * 2. Todo CRUD operations\n * 3. Public feed operations\n * 4. Settings operations\n * 5. Message operations\n * 6. Real-time subscriptions\n *\n * **Audio Guide:** `audio/nextjs-firebase/firestore-operations.mp3`\n */\n\nimport {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  addDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  orderBy,\n  limit,\n  startAfter,\n  onSnapshot,\n  Timestamp,\n  DocumentData,\n  QueryDocumentSnapshot,\n} from 'firebase/firestore'\nimport { db } from './client'\nimport type { Todo, UserSettings, Message, TodoAttachment } from '@/types'\n\n/**\n * REF: firestore-collections\n *\n * ## Collection References\n *\n * Create typed collection references for each Firestore collection.\n *\n * ### Why Export These?\n *\n * - Reuse across functions\n * - Consistent collection names\n * - Type safety\n * - Easy to change collection name (one place)\n *\n * ### Firestore Structure\n *\n * ```\n * firestore/\n * â”œâ”€â”€ users/              # User profiles\n * â”œâ”€â”€ todos/              # Todo items\n * â”œâ”€â”€ userSettings/       # User preferences\n * â”œâ”€â”€ todoAttachments/    # File metadata\n * â””â”€â”€ messages/           # Chat messages\n * ```\n */\nexport const usersCollection = collection(db, 'users')\nexport const todosCollection = collection(db, 'todos')\nexport const userSettingsCollection = collection(db, 'userSettings')\nexport const todoAttachmentsCollection = collection(db, 'todoAttachments')\nexport const messagesCollection = collection(db, 'messages')\n// CLOSE: firestore-collections\n\n/**\n * REF: timestamp-helper\n *\n * ## Timestamp Conversion Helper\n *\n * Converts Firestore `Timestamp` to JavaScript `Date`.\n *\n * ### Usage\n *\n * ```typescript\n * const todo = await getTodo(id)\n * const date = timestampToDate(todo.createdAt)\n * console.log(date.toLocaleDateString())\n * ```\n *\n * **Simple utility** for common operation.\n */\nexport const timestampToDate = (timestamp: Timestamp) => timestamp.toDate()\n// CLOSE: timestamp-helper\n\n/**\n * REF: get-user-by-id\n *\n * ## Get User by ID\n *\n * Fetches a single user document by ID.\n *\n * ### Parameters\n *\n * - `userId`: User's unique identifier\n *\n * ### Returns\n *\n * - User object with ID if exists\n * - `null` if not found\n *\n * ### Firestore Pattern\n *\n * ```typescript\n * getDoc(doc(collection, id))\n * ```\n *\n * Standard pattern for fetching single document.\n */\nexport async function getUserById(userId: string) {\n  const userDoc = await getDoc(doc(usersCollection, userId))\n  return userDoc.exists() ? { id: userDoc.id, ...userDoc.data() } : null\n}\n// CLOSE: get-user-by-id\n\n/**\n * REF: create-update-user\n *\n * ## Create or Update User\n *\n * Updates user document (creates if doesn't exist).\n *\n * ### Parameters\n *\n * - `userId`: User ID (document ID)\n * - `data`: Partial user data to update\n *\n * ### Behavior\n *\n * - If document exists â†’ updates fields\n * - If doesn't exist â†’ creates with provided data\n * - Always sets `updatedAt` to current time\n *\n * ### Use Case\n *\n * Called after user signs in to sync profile data.\n */\nexport async function createOrUpdateUser(userId: string, data: Partial<DocumentData>) {\n  const userRef = doc(usersCollection, userId)\n  await updateDoc(userRef, {\n    ...data,\n    updatedAt: Timestamp.now(),\n  })\n}\n// CLOSE: create-update-user\n\n/**\n * REF: create-todo\n *\n * ## Create Todo\n *\n * Creates a new todo document in Firestore.\n *\n * ### Parameters\n *\n * - `userId`: Owner of the todo\n * - `todoData`: Partial todo data (title, description, etc.)\n *\n * ### Returns\n *\n * Complete todo object with generated `id`.\n *\n * ### Default Values\n *\n * Automatically sets:\n * - `completed: false`\n * - `isPublic: false` (unless specified)\n * - `tags: []` (unless specified)\n * - `createdAt: now()`\n * - `updatedAt: now()`\n *\n * ### Firestore AddDoc\n *\n * `addDoc()` auto-generates unique ID:\n * - Returns `DocumentReference`\n * - Contains generated ID\n * - Add to returned object\n */\nexport async function createTodo(userId: string, todoData: Partial<Todo>) {\n  const todo = {\n    userId,\n    title: todoData.title,\n    description: todoData.description || '',\n    completed: false,\n    isPublic: todoData.isPublic || false,\n    tags: todoData.tags || [],\n    createdAt: Timestamp.now(),\n    updatedAt: Timestamp.now(),\n  }\n  const docRef = await addDoc(todosCollection, todo)\n  return { id: docRef.id, ...todo }\n}\n// CLOSE: create-todo\n\n/**\n * REF: get-user-todos\n *\n * ## Get User's Todos\n *\n * Fetches all todos for a specific user.\n *\n * ### Firestore Query\n *\n * ```typescript\n * query(\n *   collection,\n *   where('userId', '==', userId),\n *   orderBy('createdAt', 'desc')\n * )\n * ```\n *\n * **Filters** by userId, **orders** by newest first.\n *\n * ### Returns\n *\n * Array of todos with IDs included.\n *\n * ### Composite Index Required\n *\n * Firebase will prompt to create index for:\n * - Collection: `todos`\n * - Fields: `userId` (Ascending), `createdAt` (Descending)\n */\nexport async function getUserTodos(userId: string) {\n  const q = query(\n    todosCollection,\n    where('userId', '==', userId),\n    orderBy('createdAt', 'desc')\n  )\n  const snapshot = await getDocs(q)\n  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Todo))\n}\n// CLOSE: get-user-todos\n\n/**\n * REF: update-todo\n *\n * ## Update Todo\n *\n * Updates specific fields of a todo.\n *\n * ### Parameters\n *\n * - `todoId`: Todo to update\n * - `data`: Partial todo data (only changed fields)\n *\n * ### Partial Updates\n *\n * Only sends fields that changed:\n * - More efficient\n * - Prevents overwriting other fields\n * - Automatic `updatedAt` timestamp\n */\nexport async function updateTodo(todoId: string, data: Partial<Todo>) {\n  const todoRef = doc(todosCollection, todoId)\n  await updateDoc(todoRef, {\n    ...data,\n    updatedAt: Timestamp.now(),\n  })\n}\n// CLOSE: update-todo\n\n/**\n * REF: delete-todo\n *\n * ## Delete Todo\n *\n * Permanently removes a todo from Firestore.\n *\n * ### Cascade Delete\n *\n * **Also delete:**\n * - Todo attachments (from Storage and Firestore)\n * - Any related data\n *\n * This function only deletes the todo document.\n * Caller responsible for cleanup.\n */\nexport async function deleteTodo(todoId: string) {\n  await deleteDoc(doc(todosCollection, todoId))\n}\n// CLOSE: delete-todo\n\n/**\n * REF: get-public-todos\n *\n * ## Get Public Todos (Paginated)\n *\n * Fetches public todos with pagination support.\n *\n * ### Parameters\n *\n * - `limitCount`: Number of todos per page (default: 20)\n * - `lastDoc`: Last document from previous page (for pagination)\n *\n * ### Returns\n *\n * Object with:\n * - `todos`: Array of public todos\n * - `lastDoc`: Last document (for next page)\n * - `hasMore`: Whether more todos exist\n *\n * ### Pagination Pattern\n *\n * ```typescript\n * // Page 1\n * const { todos, lastDoc, hasMore } = await getPublicTodos(20)\n *\n * // Page 2\n * const page2 = await getPublicTodos(20, lastDoc)\n * ```\n */\nexport async function getPublicTodos(limitCount = 20, lastDoc?: QueryDocumentSnapshot) {\n  let q = query(\n    todosCollection,\n    where('isPublic', '==', true),\n    orderBy('createdAt', 'desc'),\n    limit(limitCount)\n  )\n\n  if (lastDoc) {\n    q = query(q, startAfter(lastDoc))\n  }\n\n  const snapshot = await getDocs(q)\n  return {\n    todos: snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Todo)),\n    lastDoc: snapshot.docs[snapshot.docs.length - 1],\n    hasMore: snapshot.docs.length === limitCount,\n  }\n}\n// CLOSE: get-public-todos\n\n/**\n * REF: search-public-todos\n *\n * ## Search Public Todos\n *\n * Searches public todos by title and description.\n *\n * ### Limitation\n *\n * **Firestore doesn't support full-text search natively.**\n *\n * This implementation:\n * 1. Fetches all public todos\n * 2. Filters client-side\n *\n * ### For Production\n *\n * Consider using:\n * - **Algolia** for full-text search\n * - **Typesense** for open-source alternative\n * - **ElasticSearch** for advanced features\n *\n * ### Client-Side Filtering\n *\n * Not scalable for large datasets!\n * - Fetches all public todos\n * - Filters in JavaScript\n * - Works for < 1000 items\n */\nexport async function searchPublicTodos(searchTerm: string, limitCount = 20) {\n  const q = query(\n    todosCollection,\n    where('isPublic', '==', true),\n    orderBy('createdAt', 'desc'),\n    limit(limitCount)\n  )\n\n  const snapshot = await getDocs(q)\n  const todos = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Todo))\n\n  // Client-side filtering\n  return todos.filter(\n    todo =>\n      todo.title?.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      todo.description?.toLowerCase().includes(searchTerm.toLowerCase())\n  )\n}\n// CLOSE: search-public-todos\n\n/**\n * REF: filter-by-tag\n *\n * ## Filter Public Todos by Tag\n *\n * Finds public todos containing a specific tag.\n *\n * ### Firestore Array Query\n *\n * ```typescript\n * where('tags', 'array-contains', tag)\n * ```\n *\n * Searches array fields efficiently.\n *\n * ### Composite Index Required\n *\n * Firebase will prompt for index:\n * - Collection: `todos`\n * - Fields: `isPublic`, `tags`, `createdAt`\n *\n * ### Limitation\n *\n * Can only query **one tag** at a time.\n * For multiple tags, use `array-contains-any`.\n */\nexport async function filterPublicTodosByTag(tag: string, limitCount = 20) {\n  const q = query(\n    todosCollection,\n    where('isPublic', '==', true),\n    where('tags', 'array-contains', tag),\n    orderBy('createdAt', 'desc'),\n    limit(limitCount)\n  )\n\n  const snapshot = await getDocs(q)\n  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Todo))\n}\n// CLOSE: filter-by-tag\n\n/**\n * REF: get-user-settings\n *\n * ## Get User Settings\n *\n * Fetches user's accessibility preferences.\n *\n * ### Returns\n *\n * - `UserSettings` object if exists\n * - `null` if not found\n *\n * ### Document ID = User ID\n *\n * Settings document ID matches user ID:\n * - One settings doc per user\n * - Easy to fetch\n * - No query needed\n */\nexport async function getUserSettings(userId: string) {\n  const settingsDoc = await getDoc(doc(userSettingsCollection, userId))\n  return settingsDoc.exists()\n    ? ({ id: settingsDoc.id, ...settingsDoc.data() } as UserSettings)\n    : null\n}\n// CLOSE: get-user-settings\n\n/**\n * REF: update-user-settings\n *\n * ## Update User Settings\n *\n * Updates user's accessibility preferences.\n *\n * ### Parameters\n *\n * - `userId`: User's ID\n * - `settings`: Partial settings to update\n *\n * ### Partial Updates\n *\n * Only update changed fields:\n * ```typescript\n * updateUserSettings(userId, { theme: 'dark' })\n * // Only updates theme, keeps other settings\n * ```\n *\n * ### Auto-Updated Field\n *\n * `updatedAt` automatically set to current time.\n */\nexport async function updateUserSettings(userId: string, settings: Partial<UserSettings>) {\n  const settingsRef = doc(userSettingsCollection, userId)\n  await updateDoc(settingsRef, {\n    ...settings,\n    updatedAt: Timestamp.now(),\n  })\n}\n// CLOSE: update-user-settings\n\n/**\n * REF: message-operations\n *\n * # Message Operations\n *\n * Real-time messaging functionality between users.\n *\n * ## Key Concepts\n *\n * - **Direct messages** - One-to-one communication\n * - **Read status** - Track message delivery and read receipts\n * - **Conversation threads** - Messages between two users\n * - **Unread counts** - Badge notifications\n *\n * ## Security Considerations\n *\n * Messages require authentication and proper access control:\n * - Users can only send messages as themselves\n * - Recipients can mark messages as read\n * - Conversation history is private\n */\n\n/**\n * REF: send-message\n *\n * ## Send Direct Message\n *\n * Creates a new message between two users.\n *\n * ### Parameters\n *\n * | Parameter | Type | Description |\n * |-----------|------|-------------|\n * | `senderId` | `string` | ID of the user sending the message |\n * | `recipientId` | `string` | ID of the user receiving the message |\n * | `content` | `string` | Message text content |\n *\n * ### Returns\n *\n * Message object with generated ID and timestamp.\n *\n * ### Example\n *\n * ```typescript\n * const message = await sendMessage(\n *   currentUser.uid,\n *   otherUser.uid,\n *   \"Hello! How are you?\"\n * )\n * ```\n */\nexport async function sendMessage(senderId: string, recipientId: string, content: string) {\n  const message = {\n    senderId,\n    recipientId,\n    content,\n    read: false,\n    createdAt: Timestamp.now(),\n  }\n  const docRef = await addDoc(messagesCollection, message)\n  return { id: docRef.id, ...message }\n}\n// CLOSE: send-message\n\n/**\n * REF: get-conversation\n *\n * ## Get Conversation History\n *\n * Retrieves all messages between two specific users.\n *\n * ### Implementation Note\n *\n * This queries for messages where senderId is either user,\n * then filters client-side for the specific conversation.\n * For production with many messages, consider:\n * - Composite indexes for efficient querying\n * - Pagination for large conversations\n * - Dedicated conversation collection\n *\n * ### Parameters\n *\n * | Parameter | Type | Description |\n * |-----------|------|-------------|\n * | `userId` | `string` | Current user's ID |\n * | `otherUserId` | `string` | Other participant's ID |\n *\n * ### Returns\n *\n * Array of messages sorted by creation time.\n *\n * ### Example\n *\n * ```typescript\n * const messages = await getConversation(\n *   currentUser.uid,\n *   selectedUser.uid\n * )\n * ```\n */\nexport async function getConversation(userId: string, otherUserId: string) {\n  const q = query(\n    messagesCollection,\n    where('senderId', 'in', [userId, otherUserId]),\n    orderBy('createdAt', 'asc')\n  )\n\n  const snapshot = await getDocs(q)\n  const messages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Message))\n\n  // Filter for conversation between these two users\n  return messages.filter(\n    msg =>\n      (msg.senderId === userId && msg.recipientId === otherUserId) ||\n      (msg.senderId === otherUserId && msg.recipientId === userId)\n  )\n}\n// CLOSE: get-conversation\n\n/**\n * REF: mark-message-read\n *\n * ## Mark Message as Read\n *\n * Updates a message's read status and timestamp.\n *\n * ### Parameters\n *\n * | Parameter | Type | Description |\n * |-----------|------|-------------|\n * | `messageId` | `string` | ID of the message to mark as read |\n *\n * ### Side Effects\n *\n * - Sets `read` field to `true`\n * - Adds `readAt` timestamp\n * - Triggers real-time updates for sender\n *\n * ### Example\n *\n * ```typescript\n * // Mark message as read when user views it\n * await markMessageAsRead(message.id)\n * ```\n */\nexport async function markMessageAsRead(messageId: string) {\n  const messageRef = doc(messagesCollection, messageId)\n  await updateDoc(messageRef, {\n    read: true,\n    readAt: Timestamp.now(),\n  })\n}\n// CLOSE: mark-message-read\n\n/**\n * REF: unread-count\n *\n * ## Get Unread Message Count\n *\n * Counts unread messages for a specific user.\n *\n * ### Parameters\n *\n * | Parameter | Type | Description |\n * |-----------|------|-------------|\n * | `userId` | `string` | ID of the recipient user |\n *\n * ### Returns\n *\n * Number of unread messages.\n *\n * ### Use Cases\n *\n * - Badge notifications in UI\n * - Push notification triggers\n * - Dashboard statistics\n *\n * ### Example\n *\n * ```typescript\n * const unreadCount = await getUnreadMessageCount(user.uid)\n * setBadgeCount(unreadCount)\n * ```\n */\nexport async function getUnreadMessageCount(userId: string) {\n  const q = query(\n    messagesCollection,\n    where('recipientId', '==', userId),\n    where('read', '==', false)\n  )\n\n  const snapshot = await getDocs(q)\n  return snapshot.size\n}\n// CLOSE: unread-count\n// CLOSE: message-operations\n\n/**\n * REF: realtime-subscriptions\n *\n * # Real-time Subscriptions\n *\n * Live data listeners that automatically update when data changes.\n *\n * ## Key Concepts\n *\n * - **onSnapshot listeners** - React to database changes\n * - **Automatic updates** - UI refreshes without polling\n * - **Unsubscribe cleanup** - Prevent memory leaks\n * - **Optimistic UI** - Instant feedback before server confirms\n *\n * ## Performance Considerations\n *\n * - Each listener counts against concurrent connection limit\n * - Unsubscribe when component unmounts\n * - Consider debouncing rapid updates\n * - Use query limits to reduce bandwidth\n */\n\n/**\n * REF: subscribe-user-todos\n *\n * ## Subscribe to User's Todos\n *\n * Sets up real-time listener for a user's todo list.\n *\n * ### Parameters\n *\n * | Parameter | Type | Description |\n * |-----------|------|-------------|\n * | `userId` | `string` | User ID to watch |\n * | `callback` | `Function` | Called with updated todos |\n *\n * ### Returns\n *\n * Unsubscribe function to cleanup listener.\n *\n * ### Example\n *\n * ```typescript\n * useEffect(() => {\n *   const unsubscribe = subscribeToUserTodos(user.uid, (todos) => {\n *     setTodos(todos)\n *   })\n *   return () => unsubscribe() // Cleanup\n * }, [user?.uid])\n * ```\n *\n * ### Real-time Flow\n *\n * 1. User creates/updates/deletes todo\n * 2. Firestore broadcasts change\n * 3. All active listeners receive update\n * 4. Callback fires with new data\n * 5. UI re-renders automatically\n */\nexport function subscribeToUserTodos(userId: string, callback: (todos: Todo[]) => void) {\n  const q = query(\n    todosCollection,\n    where('userId', '==', userId),\n    orderBy('createdAt', 'desc')\n  )\n\n  return onSnapshot(q, snapshot => {\n    const todos = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Todo))\n    callback(todos)\n  })\n}\n// CLOSE: subscribe-user-todos\n\n/**\n * REF: subscribe-conversation\n *\n * ## Subscribe to Conversation\n *\n * Real-time listener for messages between two users.\n *\n * ### Implementation Note\n *\n * Currently fetches ALL messages then filters client-side.\n * This is inefficient for large message volumes.\n *\n * **Production improvements:**\n * - Use composite index for bidirectional query\n * - Implement pagination for message history\n * - Consider conversation rooms/channels pattern\n * - Cache messages locally with IndexedDB\n *\n * ### Parameters\n *\n * | Parameter | Type | Description |\n * |-----------|------|-------------|\n * | `userId` | `string` | Current user ID |\n * | `otherUserId` | `string` | Other participant ID |\n * | `callback` | `Function` | Called with message updates |\n *\n * ### Returns\n *\n * Unsubscribe function for cleanup.\n *\n * ### Example\n *\n * ```typescript\n * useEffect(() => {\n *   if (!selectedUser) return\n *\n *   const unsubscribe = subscribeToConversation(\n *     user.uid,\n *     selectedUser.id,\n *     (messages) => {\n *       setMessages(messages)\n *       scrollToBottom()\n *     }\n *   )\n *   return () => unsubscribe()\n * }, [selectedUser])\n * ```\n */\nexport function subscribeToConversation(\n  userId: string,\n  otherUserId: string,\n  callback: (messages: Message[]) => void\n) {\n  const q = query(messagesCollection, orderBy('createdAt', 'asc'))\n\n  return onSnapshot(q, snapshot => {\n    const messages = snapshot.docs\n      .map(doc => ({ id: doc.id, ...doc.data() } as Message))\n      .filter(\n        msg =>\n          (msg.senderId === userId && msg.recipientId === otherUserId) ||\n          (msg.senderId === otherUserId && msg.recipientId === userId)\n      )\n    callback(messages)\n  })\n}\n// CLOSE: subscribe-conversation\n\n/**\n * REF: subscribe-public-feed\n *\n * ## Subscribe to Public Feed\n *\n * Real-time listener for community todos marked as public.\n *\n * ### Features\n *\n * - Live updates when todos become public\n * - Automatic removal when todos become private\n * - Sorted by newest first\n * - Limited to prevent overwhelming UI\n *\n * ### Parameters\n *\n * | Parameter | Type | Default | Description |\n * |-----------|------|---------|-------------|\n * | `callback` | `Function` | `-` | Called with todo updates |\n * | `limitCount` | `number` | `20` | Maximum todos to fetch |\n *\n * ### Returns\n *\n * Unsubscribe function for cleanup.\n *\n * ### Example\n *\n * ```typescript\n * useEffect(() => {\n *   const unsubscribe = subscribeToPublicFeed((publicTodos) => {\n *     setTodos(publicTodos)\n *     setLoading(false)\n *   }, 20)\n *\n *   return () => unsubscribe()\n * }, [])\n * ```\n *\n * ### Performance Notes\n *\n * - Limit prevents large data transfers\n * - Index on `isPublic` field for efficiency\n * - Consider pagination for browsing all public todos\n */\nexport function subscribeToPublicFeed(callback: (todos: Todo[]) => void, limitCount = 20) {\n  const q = query(\n    todosCollection,\n    where('isPublic', '==', true),\n    orderBy('createdAt', 'desc'),\n    limit(limitCount)\n  )\n\n  return onSnapshot(q, snapshot => {\n    const todos = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Todo))\n    callback(todos)\n  })\n}\n// CLOSE: subscribe-public-feed\n// CLOSE: realtime-subscriptions\n// CLOSE: firestore-file-header\n",
      "language": "typescript"
    },
    {
      "path": "lib/firebase/storage.ts",
      "content": "/**\n * REF: firebase-storage-file\n *\n * # Firebase Storage Utilities\n *\n * Helper functions for file uploads and management.\n *\n * ## Key Concepts\n *\n * - **Firebase Storage:** S3-like object storage from Google\n * - **File uploads:** Browser â†’ Firebase Storage\n * - **Storage paths:** Organized by user and purpose\n * - **Metadata:** Track file info (size, type, URL)\n *\n * ## Storage Organization\n *\n * Files organized by user and type:\n * - `profile-pictures/{userId}/{filename}`\n * - `todo-attachments/{userId}/{todoId}/{filename}`\n *\n * ### Why This Structure?\n *\n * - Easy to find user's files\n * - Easy to delete user data\n * - Security rules can protect by path\n * - Clear ownership\n *\n * **Audio Guide:** `audio/nextjs-firebase/storage-utilities.mp3`\n */\n\nimport {\n  ref,\n  uploadBytes,\n  getDownloadURL,\n  deleteObject,\n  UploadMetadata,\n} from 'firebase/storage'\nimport { storage } from './client'\n\n/**\n * REF: upload-profile-picture\n *\n * ## Upload Profile Picture\n *\n * Uploads user's profile picture to Firebase Storage.\n *\n * ### Parameters\n *\n * - `userId`: User's unique ID (for path organization)\n * - `file`: File object from input element\n *\n * ### Returns\n *\n * Object with file metadata:\n * - `fileName`: Generated unique filename\n * - `fileUrl`: Public download URL\n * - `fileSize`: Size in bytes\n * - `mimeType`: File type (e.g., \"image/png\")\n *\n * ### Storage Path\n *\n * Files stored at: `profile-pictures/{userId}/{timestamp}_{originalname}`\n *\n * **Why timestamp?**\n * - Prevents filename collisions\n * - Unique even if same filename uploaded twice\n * - Natural ordering (newest first)\n */\nexport async function uploadProfilePicture(userId: string, file: File) {\n  const fileName = `${Date.now()}_${file.name}`\n  const storageRef = ref(storage, `profile-pictures/${userId}/${fileName}`)\n\n  const metadata: UploadMetadata = {\n    contentType: file.type,\n  }\n\n  /**\n   * Upload file to Storage and get download URL.\n   *\n   * Steps:\n   * 1. `uploadBytes()` uploads file\n   * 2. `getDownloadURL()` gets public URL\n   * 3. Return metadata for Firestore\n   */\n  const snapshot = await uploadBytes(storageRef, file, metadata)\n  const downloadURL = await getDownloadURL(snapshot.ref)\n\n  return {\n    fileName,\n    fileUrl: downloadURL,\n    fileSize: file.size,\n    mimeType: file.type,\n  }\n}\n// CLOSE: upload-profile-picture\n\n/**\n * REF: upload-todo-attachment\n *\n * ## Upload Todo Attachment\n *\n * Uploads a file attachment for a todo item.\n *\n * ### Parameters\n *\n * - `userId`: Owner of the todo\n * - `todoId`: Todo this attaches to\n * - `file`: File to upload\n *\n * ### Storage Path\n *\n * `todo-attachments/{userId}/{todoId}/{filename}`\n *\n * Organized by:\n * 1. User (for access control)\n * 2. Todo (for grouping)\n * 3. Filename (unique with timestamp)\n *\n * ### Return Value\n *\n * Metadata object to save in Firestore:\n * - Use for displaying attachment list\n * - Track file info without querying Storage\n */\nexport async function uploadTodoAttachment(userId: string, todoId: string, file: File) {\n  const fileName = `${Date.now()}_${file.name}`\n  const storageRef = ref(storage, `todo-attachments/${userId}/${todoId}/${fileName}`)\n\n  const metadata: UploadMetadata = {\n    contentType: file.type,\n  }\n\n  const snapshot = await uploadBytes(storageRef, file, metadata)\n  const downloadURL = await getDownloadURL(snapshot.ref)\n\n  return {\n    fileName,\n    fileUrl: downloadURL,\n    fileSize: file.size,\n    mimeType: file.type,\n  }\n}\n// CLOSE: upload-todo-attachment\n\n/**\n * REF: delete-file\n *\n * ## Delete File from Storage\n *\n * Removes a file from Firebase Storage.\n *\n * ### Parameter\n *\n * - `filePath`: Full storage path to file\n *\n * ### Important\n *\n * Also delete metadata from Firestore!\n * ```typescript\n * await deleteFile(attachment.filePath)\n * await db.collection('attachments').doc(id).delete()\n * ```\n *\n * **Two-step delete** ensures cleanup.\n */\nexport async function deleteFile(filePath: string) {\n  const storageRef = ref(storage, filePath)\n  await deleteObject(storageRef)\n}\n// CLOSE: delete-file\n\n/**\n * REF: validate-image\n *\n * ## Validate Image File\n *\n * Client-side validation for image uploads.\n *\n * ### Validation Rules\n *\n * **Allowed Types:**\n * - JPEG, PNG, GIF, WebP only\n *\n * **Size Limit:**\n * - Maximum 5MB\n *\n * ### Returns\n *\n * Object with `valid` boolean and optional `error` message.\n *\n * ### Usage\n *\n * ```typescript\n * const validation = validateImageFile(file)\n * if (!validation.valid) {\n *   alert(validation.error)\n *   return\n * }\n * // Proceed with upload\n * ```\n *\n * ### Security Note\n *\n * Client validation is **UX only**!\n * - Storage rules enforce server-side\n * - Never trust client validation alone\n */\nexport function validateImageFile(file: File): { valid: boolean; error?: string } {\n  const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp']\n  const maxSize = 5 * 1024 * 1024 // 5MB\n\n  /**\n   * Check file type against allowed list.\n   */\n  if (!validTypes.includes(file.type)) {\n    return { valid: false, error: 'Invalid file type. Please upload an image (JPEG, PNG, GIF, or WebP).' }\n  }\n\n  /**\n   * Check file size against maximum.\n   */\n  if (file.size > maxSize) {\n    return { valid: false, error: 'File size exceeds 5MB limit.' }\n  }\n\n  return { valid: true }\n}\n// CLOSE: validate-image\n\n/**\n * REF: validate-attachment\n *\n * ## Validate Attachment File\n *\n * Client-side validation for todo attachments.\n *\n * ### Validation Rules\n *\n * **Any file type allowed** (documents, images, etc.)\n *\n * **Size Limit:**\n * - Maximum 5MB\n *\n * ### Less Restrictive\n *\n * Unlike `validateImageFile()`:\n * - No MIME type restriction\n * - Attachments can be PDFs, Word docs, etc.\n * - Still limited to 5MB for performance\n *\n * ### Usage\n *\n * ```typescript\n * const validation = validateAttachmentFile(file)\n * if (!validation.valid) {\n *   showError(validation.error)\n *   return\n * }\n * await uploadTodoAttachment(userId, todoId, file)\n * ```\n */\nexport function validateAttachmentFile(file: File): { valid: boolean; error?: string } {\n  const maxSize = 5 * 1024 * 1024 // 5MB\n\n  if (file.size > maxSize) {\n    return { valid: false, error: 'File size exceeds 5MB limit.' }\n  }\n\n  return { valid: true }\n}\n// CLOSE: validate-attachment\n// CLOSE: firebase-storage-file\n",
      "language": "typescript"
    },
    {
      "path": "lib/hooks/useTodos.ts",
      "content": "/**\n * REF: use-todos-hook\n *\n * # useTodos Hook\n *\n * Reusable custom hook that encapsulates all todo-related operations.\n *\n * ## Key Concepts\n *\n * - **Custom React hooks** - Functions that use other hooks\n * - **Logic reusability** - Use in multiple components\n * - **State management** - Todos, loading, errors\n * - **Real-time subscriptions** - Live data from Firestore\n * - **CRUD operations** - Create, Read, Update, Delete\n *\n * ## What is a Custom Hook?\n *\n * A JavaScript function that:\n * - Starts with \"use\" prefix\n * - Can use other React hooks\n * - Returns data and functions\n * - Can be used in multiple components\n *\n * ## Benefits of Custom Hooks\n *\n * | Benefit | Description |\n * |---------|-------------|\n * | `DRY` | Don't Repeat Yourself - share logic |\n * | `Testable` | Test hook independently from UI |\n * | `Composable` | Combine multiple hooks together |\n * | `Separated` | UI focuses on rendering, logic in hook |\n * | `Reusable` | Same hook in different components |\n *\n * ## Usage Example\n *\n * ```typescript\n * function Dashboard() {\n *   const { user } = useAuth()\n *   const { todos, loading, createTodo, updateTodo } = useTodos(user.uid)\n *\n *   if (loading) return <LoadingSpinner />\n *\n *   return (\n *     <div>\n *       <TodoForm onSubmit={createTodo} />\n *       <TodoList todos={todos} onUpdate={updateTodo} />\n *     </div>\n *   )\n * }\n * ```\n *\n * Much cleaner than putting all logic in the component!\n */\n// CLOSE: use-todos-hook\n\nimport { useState, useEffect } from 'react'\nimport {\n  subscribeToUserTodos,\n  createTodo as createTodoFirestore,\n  updateTodo as updateTodoFirestore,\n  deleteTodo as deleteTodoFirestore,\n} from '@/lib/firebase/firestore'\nimport type { Todo } from '@/types'\n\n/**\n * REF: use-todos-return-type\n *\n * # useTodos Return Type\n *\n * Defines the data and functions returned by the hook.\n *\n * ## Return Interface\n *\n * | `Property` | Type | Description |\n * |----------|------|-------------|\n * | `todos` | `Todo[]` | Array of user's todos |\n * | `loading` | `boolean` | True while fetching initial data |\n * | `error` | `string` or `null` | Error message if operation fails |\n * | `createTodo` | `function` | Create new todo |\n * | `updateTodo` | `function` | Update existing todo |\n * | `deleteTodo` | `function` | Delete a todo |\n * | `toggleComplete` | `function` | Toggle completion status |\n *\n * ## What the Hook Encapsulates\n *\n * - **State management** - Todos array, loading, error states\n * - **Real-time subscription** - Firestore onSnapshot listener\n * - **CRUD operations** - Create, Read, Update, Delete\n * - **Error handling** - Catches and reports errors\n * - **Cleanup** - Unsubscribes on unmount\n */\ninterface UseTodosReturn {\n  todos: Todo[]\n  loading: boolean\n  error: string | null\n  createTodo: (todoData: Partial<Todo>) => Promise<void>\n  updateTodo: (todoId: string, updates: Partial<Todo>) => Promise<void>\n  deleteTodo: (todoId: string) => Promise<void>\n  toggleComplete: (todoId: string, completed: boolean) => Promise<void>\n}\n// CLOSE: use-todos-return-type\n\n/**\n * REF: use-todos-function\n *\n * # useTodos Hook Function\n *\n * Main hook that manages all todo-related operations.\n *\n * ## Parameters\n *\n * - userId: ID of user whose todos to manage\n *\n * ## Returns\n *\n * Object with:\n * - todos: Live array of user's todos\n * - loading: Whether data is loading\n * - error: Any error that occurred\n * - createTodo(): Create new todo\n * - updateTodo(): Modify existing todo\n * - deleteTodo(): Remove todo\n * - toggleComplete(): Toggle done status\n *\n * ## How It Works\n *\n * 1. **Initial mount** - Set loading=true, subscribe to user's todos\n * 2. **Data arrives** - Update todos array, set loading=false\n * 3. **Live updates** - Firestore listener updates todos in real-time\n * 4. **CRUD operations** - Call Firestore functions, listener updates UI\n * 5. **Unmount** - Unsubscribe from listener\n *\n * @param userId - ID of user whose todos to manage\n * @returns Object with todos data and operations\n */\nexport function useTodos(userId: string): UseTodosReturn {\n  const [todos, setTodos] = useState<Todo[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n\n  /**\n   * REF: real-time-subscription-effect\n   *\n   * # Real-Time Subscription Effect\n   *\n   * Subscribe to user's todos when hook mounts, clean up on unmount.\n   *\n   * ## How It Works\n   *\n   * 1. **Mount** - useEffect runs, calls subscribeToUserTodos()\n   * 2. **Subscribe** - Firestore onSnapshot listener starts\n   * 3. **Updates** - Whenever todos change, callback fires\n   * 4. **Unmount** - useEffect cleanup runs, unsubscribe() called\n   *\n   * ## Automatic Cleanup\n   *\n   * - Effect cleanup function prevents memory leaks\n   * - Unsubscribe when component unmounts\n   * - Unsubscribe when userId changes (dependency)\n   * - No dangling listeners\n   *\n   * ## Real-Time Behavior\n   *\n   * - User creates todo â†’ Listener fires â†’ todos array updates â†’ UI re-renders\n   * - User edits todo â†’ Listener fires â†’ todos array updates â†’ UI re-renders\n   * - User deletes todo â†’ Listener fires â†’ todos array updates â†’ UI re-renders\n   * - All happens automatically without manual refresh\n   *\n   * ## Dependencies\n   *\n   * - [userId]: Only re-subscribe if userId changes\n   * - Important for apps with multiple users\n   */\n  useEffect(() => {\n    const unsubscribe = subscribeToUserTodos(userId, (updatedTodos) => {\n      setTodos(updatedTodos)\n      setLoading(false)\n      setError(null)\n    })\n\n    return () => unsubscribe()\n  }, [userId])\n  // CLOSE: real-time-subscription-effect\n\n  /**\n   * REF: create-todo-operation\n   *\n   * # Create Todo Operation\n   *\n   * Wrapper around Firestore createTodo with error handling.\n   *\n   * ## Behavior\n   *\n   * 1. Clear any previous errors\n   * 2. Call createTodoFirestore()\n   * 3. Real-time listener automatically updates todos array\n   * 4. Catch and store error if operation fails\n   *\n   * ## Error Handling\n   *\n   * - Errors are stored in state for UI display\n   * - Error is also re-thrown for caller to handle\n   * - Allows component to show success/error UI\n   */\n  const createTodo = async (todoData: Partial<Todo>) => {\n    try {\n      setError(null)\n      await createTodoFirestore(userId, todoData)\n      // Real-time subscription updates todos automatically\n    } catch (err: any) {\n      setError(err.message || 'Failed to create todo')\n      throw err\n    }\n  }\n  // CLOSE: create-todo-operation\n\n  /**\n   * REF: update-todo-operation\n   *\n   * # Update Todo Operation\n   *\n   * Wrapper around Firestore updateTodo with error handling.\n   *\n   * ## Behavior\n   *\n   * 1. Clear previous errors\n   * 2. Call updateTodoFirestore()\n   * 3. Real-time listener automatically updates todos array\n   * 4. Catch and store error if operation fails\n   */\n  const updateTodo = async (todoId: string, updates: Partial<Todo>) => {\n    try {\n      setError(null)\n      await updateTodoFirestore(todoId, updates)\n    } catch (err: any) {\n      setError(err.message || 'Failed to update todo')\n      throw err\n    }\n  }\n  // CLOSE: update-todo-operation\n\n  /**\n   * REF: delete-todo-operation\n   *\n   * # Delete Todo Operation\n   *\n   * Wrapper around Firestore deleteTodo with error handling.\n   *\n   * ## Behavior\n   *\n   * 1. Clear previous errors\n   * 2. Call deleteTodoFirestore()\n   * 3. Real-time listener automatically removes from todos array\n   * 4. Catch and store error if operation fails\n   */\n  const deleteTodo = async (todoId: string) => {\n    try {\n      setError(null)\n      await deleteTodoFirestore(todoId)\n    } catch (err: any) {\n      setError(err.message || 'Failed to delete todo')\n      throw err\n    }\n  }\n  // CLOSE: delete-todo-operation\n\n  /**\n   * REF: toggle-completion-operation\n   *\n   * # Toggle Completion Operation\n   *\n   * Convenience method for toggling done status.\n   *\n   * ## Behavior\n   *\n   * - Calls updateTodo with inverted completion status\n   * - Useful for UI buttons that toggle state\n   * - Common operation extracted to avoid duplication\n   *\n   * ## Example\n   *\n   * ```typescript\n   * // Instead of:\n   * await updateTodo(todoId, { completed: !todo.completed })\n   *\n   * // Can do:\n   * await toggleComplete(todoId, todo.completed)\n   * ```\n   */\n  const toggleComplete = async (todoId: string, completed: boolean) => {\n    await updateTodo(todoId, { completed: !completed })\n  }\n  // CLOSE: toggle-completion-operation\n\n  /**\n   * REF: hook-return-value\n   *\n   * # Hook Return Value\n   *\n   * Returns all data and functions needed by consuming components.\n   *\n   * ## Returned Object\n   *\n   * - todos: Current todos array (updates in real-time)\n   * - loading: Whether initial data is loading\n   * - error: Error message if operation failed\n   * - createTodo: Function to create new todo\n   * - updateTodo: Function to update existing todo\n   * - deleteTodo: Function to delete todo\n   * - toggleComplete: Function to toggle completion\n   */\n  return {\n    todos,\n    loading,\n    error,\n    createTodo,\n    updateTodo,\n    deleteTodo,\n    toggleComplete,\n  }\n  // CLOSE: hook-return-value\n}\n\n/**\n * BENEFITS OF CUSTOM HOOKS\n *\n * 1. **Reusability:**\n * Use in multiple components without duplicating logic\n *\n * 2. **Testability:**\n * Test hook logic separately from UI\n *\n * 3. **Composition:**\n * Combine multiple hooks\n *\n * 4. **Separation of Concerns:**\n * UI components focus on rendering\n * Hooks handle data and logic\n */\n\n/**\n * ADVANCED PATTERNS\n *\n * Add pagination:\n * ```typescript\n * export function useTodos(userId: string, limit = 20) {\n *   const [page, setPage] = useState(0)\n *\n *   const loadMore = () => setPage(page + 1)\n *\n *   // Fetch with limit and offset\n *   // ...\n *\n *   return { todos, loading, loadMore, hasMore }\n * }\n * ```\n *\n * Add filtering:\n * ```typescript\n * export function useTodos(userId: string, filter?: {\n *   completed?: boolean\n *   tag?: string\n * }) {\n *   // Apply filter to query\n *   // ...\n * }\n * ```\n *\n * Add caching:\n * ```typescript\n * const cache = new Map()\n *\n * export function useTodos(userId: string) {\n *   if (cache.has(userId)) {\n *     setTodos(cache.get(userId))\n *   }\n *\n *   // Then subscribe for updates\n * }\n * ```\n */\n\n/**\n * OTHER USEFUL HOOKS\n *\n * useDebounce:\n * ```typescript\n * export function useDebounce<T>(value: T, delay: number): T {\n *   const [debouncedValue, setDebouncedValue] = useState(value)\n *\n *   useEffect(() => {\n *     const timer = setTimeout(() => setDebouncedValue(value), delay)\n *     return () => clearTimeout(timer)\n *   }, [value, delay])\n *\n *   return debouncedValue\n * }\n * ```\n *\n * useLocalStorage:\n * ```typescript\n * export function useLocalStorage<T>(key: string, initialValue: T) {\n *   const [value, setValue] = useState<T>(() => {\n *     const stored = localStorage.getItem(key)\n *     return stored ? JSON.parse(stored) : initialValue\n *   })\n *\n *   useEffect(() => {\n *     localStorage.setItem(key, JSON.stringify(value))\n *   }, [key, value])\n *\n *   return [value, setValue] as const\n * }\n * ```\n *\n * useMediaQuery:\n * ```typescript\n * export function useMediaQuery(query: string): boolean {\n *   const [matches, setMatches] = useState(false)\n *\n *   useEffect(() => {\n *     const media = window.matchMedia(query)\n *     setMatches(media.matches)\n *\n *     const listener = (e: MediaQueryListEvent) => setMatches(e.matches)\n *     media.addEventListener('change', listener)\n *\n *     return () => media.removeEventListener('change', listener)\n *   }, [query])\n *\n *   return matches\n * }\n * ```\n */\n// CLOSE: use-todos-hook\n",
      "language": "typescript"
    },
    {
      "path": "next.config.js",
      "content": "/**\n * REF: nextjs-config-file\n *\n * # Next.js Configuration\n *\n * Configures Next.js build and runtime behavior for the Firebase Todo application.\n *\n * ## Key Concepts\n *\n * | `Concept` | Description |\n * |---------|-------------|\n * | **Next.js Config** | Controls framework behavior and build settings |\n * | **Image Optimization** | Configure allowed external image domains |\n * | **Build Settings** | Customize compilation and bundling |\n * | **Runtime Settings** | Server and client runtime configuration |\n *\n * ## What is next.config.js?\n *\n * The `next.config.js` file is the central configuration file for Next.js applications.\n * It allows you to customize:\n * - Image optimization settings\n * - Redirects and rewrites\n * - Environment variables\n * - Webpack configuration\n * - Build output settings\n * - API routes behavior\n *\n * ## Configuration Object\n *\n * Type-checked with JSDoc `@type` annotation for autocomplete and IntelliSense.\n *\n * ## Why This File Matters\n *\n * - **Security**: Controls which external domains can serve optimized images\n * - **Performance**: Enables Next.js optimizations and caching\n * - **Deployment**: Configures build behavior for production\n * - **Integration**: Connects with Firebase Storage and other services\n */\n// CLOSE: nextjs-config-file\n\n/**\n * REF: nextjs-config-type\n *\n * # Next.js Configuration Type\n *\n * TypeScript type annotation for configuration autocomplete.\n *\n * ## JSDoc Type Annotation\n *\n * The `@type` comment provides type checking and autocomplete even in JavaScript files.\n *\n * ```javascript\n * // Without @type: No autocomplete\n * const nextConfig = { ... }\n *\n * // With @type: Full autocomplete and type checking\n * / ** @type {import('next').NextConfig} * /\n * const nextConfig = { ... }\n * ```\n *\n * ## Benefits\n *\n * - **Autocomplete**: Get suggestions for valid config options\n * - **Type Safety**: Catch errors before runtime\n * - **Documentation**: See inline docs for each option\n * - **No TypeScript**: Get TypeScript benefits in JavaScript\n */\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // CLOSE: nextjs-config-type\n\n  /**\n   * REF: image-configuration\n   *\n   * # Image Configuration\n   *\n   * Configures Next.js Image component optimization for external images.\n   *\n   * ## The Next.js Image Component\n   *\n   * Next.js provides an optimized `<Image>` component that:\n   * - Automatically optimizes images\n   * - Serves WebP/AVIF formats when supported\n   * - Lazy loads images below the fold\n   * - Prevents Cumulative Layout Shift (CLS)\n   * - Resizes images on-demand\n   *\n   * ## Security: Allowed Domains\n   *\n   * For security, Next.js only optimizes images from allowed domains.\n   *\n   * ### Configured Domains\n   *\n   * | `Domain` | Purpose |\n   * |--------|---------|\n   * | `firebasestorage.googleapis.com` | Firebase Storage images (profile pictures, attachments) |\n   *\n   * ### Why Domain Allowlist?\n   *\n   * - **Security**: Prevents arbitrary URL loading and potential attacks\n   * - **Performance**: Limits optimization to trusted sources\n   * - **Cost Control**: Prevents abuse of image optimization service\n   * - **Privacy**: Doesn't leak data to unknown domains\n   *\n   * ## How It Works\n   *\n   * 1. **Client requests image**: `<Image src=\"https://firebasestorage.googleapis.com/...\" />`\n   * 2. **Next.js checks domain**: Is it in the allowed list?\n   * 3. **Domain allowed**: Image is optimized and served\n   * 4. **Domain blocked**: Error thrown, image not loaded\n   *\n   * ## Usage Example\n   *\n   * ```tsx\n   * import Image from 'next/image'\n   *\n   * function ProfilePicture({ user }) {\n   *   return (\n   *     <Image\n   *       src={user.photoURL} // Firebase Storage URL\n   *       width={200}\n   *       height={200}\n   *       alt={user.displayName}\n   *       className=\"rounded-full\"\n   *     />\n   *   )\n   * }\n   * ```\n   *\n   * ## What Next.js Does\n   *\n   * - **Checks domain**: Verifies URL is from `firebasestorage.googleapis.com`\n   * - **Optimizes**: Converts to WebP/AVIF, resizes, compresses\n   * - **Caches**: Stores optimized version for fast subsequent loads\n   * - **Serves**: Returns optimized image to browser\n   *\n   * ## Adding More Domains\n   *\n   * To allow images from other domains:\n   *\n   * ```javascript\n   * images: {\n   *   domains: [\n   *     'firebasestorage.googleapis.com',\n   *     'example.com',\n   *     'cdn.mysite.com',\n   *   ],\n   * }\n   * ```\n   */\n  images: {\n    domains: ['firebasestorage.googleapis.com'],\n  },\n  // CLOSE: image-configuration\n}\n\n/**\n * REF: config-export\n *\n * # Configuration Export\n *\n * CommonJS export for Next.js to read the configuration.\n *\n * ## Why CommonJS?\n *\n * Next.js requires CommonJS format (`module.exports`) instead of ES modules (`export default`).\n *\n * - **Compatibility**: Works in all Node.js versions\n * - **Synchronous**: Config is read synchronously during build\n * - **Standard**: Matches Node.js configuration convention\n *\n * ## How Next.js Uses This\n *\n * 1. **Build time**: Next.js reads this file when you run `npm run build`\n * 2. **Development**: Reads on server start for `npm run dev`\n * 3. **Runtime**: Some settings used during SSR and API routes\n */\nmodule.exports = nextConfig\n// CLOSE: config-export\n\n/**\n * REF: additional-config-options\n *\n * # Additional Configuration Options\n *\n * Examples of other common Next.js configuration options you might add.\n *\n * ## Redirects\n *\n * Permanently or temporarily redirect URLs.\n *\n * ```javascript\n * async redirects() {\n *   return [\n *     {\n *       source: '/old-dashboard',\n *       destination: '/dashboard',\n *       permanent: true, // 308 permanent redirect\n *     },\n *     {\n *       source: '/blog/:slug',\n *       destination: '/posts/:slug',\n *       permanent: false, // 307 temporary redirect\n *     },\n *   ]\n * }\n * ```\n *\n * ## Rewrites\n *\n * Proxy requests to different URLs without changing the browser URL.\n *\n * ```javascript\n * async rewrites() {\n *   return [\n *     {\n *       source: '/api/firebase/:path*',\n *       destination: 'https://firebaseapp.com/:path*',\n *     },\n *   ]\n * }\n * ```\n *\n * ## Environment Variables\n *\n * Expose environment variables to the browser (use with caution).\n *\n * ```javascript\n * env: {\n *   // Server-side only (default)\n *   DATABASE_URL: process.env.DATABASE_URL,\n *\n *   // Client-side (must use NEXT_PUBLIC_ prefix)\n *   NEXT_PUBLIC_FIREBASE_API_KEY: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n * }\n * ```\n *\n * ## Webpack Customization\n *\n * Extend or customize the webpack configuration.\n *\n * ```javascript\n * webpack: (config, { isServer }) => {\n *   // Add custom webpack plugins\n *   if (!isServer) {\n *     config.resolve.fallback = {\n *       ...config.resolve.fallback,\n *       fs: false,\n *     }\n *   }\n *   return config\n * }\n * ```\n *\n * ## React Strict Mode\n *\n * Enable React's Strict Mode for highlighting potential problems.\n *\n * ```javascript\n * reactStrictMode: true,\n * ```\n *\n * ## SWC Minification\n *\n * Use faster SWC compiler for minification instead of Terser.\n *\n * ```javascript\n * swcMinify: true,\n * ```\n *\n * ## Output Configuration\n *\n * Configure build output for different deployment targets.\n *\n * ```javascript\n * output: 'standalone', // For Docker deployments\n * ```\n *\n * ## Experimental Features\n *\n * Enable experimental Next.js features.\n *\n * ```javascript\n * experimental: {\n *   serverActions: true,\n *   appDir: true,\n * }\n * ```\n *\n * ## Full Example\n *\n * ```javascript\n * const nextConfig = {\n *   reactStrictMode: true,\n *   swcMinify: true,\n *\n *   images: {\n *     domains: ['firebasestorage.googleapis.com'],\n *     formats: ['image/avif', 'image/webp'],\n *   },\n *\n *   async redirects() {\n *     return [\n *       {\n *         source: '/old-page',\n *         destination: '/new-page',\n *         permanent: true,\n *       },\n *     ]\n *   },\n *\n *   webpack: (config) => {\n *     // Custom webpack config\n *     return config\n *   },\n * }\n * ```\n */\n// CLOSE: additional-config-options\n",
      "language": "javascript"
    },
    {
      "path": "package.json",
      "content": "{\n  \"name\": \"nextjs-firebase-todo\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"lint\": \"next lint\"\n  },\n  \"dependencies\": {\n    \"react\": \"^18.3.1\",\n    \"react-dom\": \"^18.3.1\",\n    \"next\": \"^15.0.0\",\n    \"firebase\": \"^10.7.1\",\n    \"firebase-admin\": \"^12.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20\",\n    \"@types/react\": \"^18\",\n    \"@types/react-dom\": \"^18\",\n    \"typescript\": \"^5\",\n    \"tailwindcss\": \"^3.4.1\",\n    \"postcss\": \"^8\",\n    \"autoprefixer\": \"^10.4.16\",\n    \"eslint\": \"^8\",\n    \"eslint-config-next\": \"^15.0.0\"\n  }\n}\n",
      "language": "json"
    },
    {
      "path": "postcss.config.js",
      "content": "/**\n * REF: postcss-config-file\n *\n * # PostCSS Configuration\n *\n * Configures PostCSS plugins for CSS processing in the Next.js application.\n *\n * ## What is PostCSS?\n *\n * **PostCSS** is a tool for transforming CSS with JavaScript plugins.\n *\n * Think of it like Babel for CSS:\n * - Takes your CSS code as input\n * - Runs it through configured plugins\n * - Outputs transformed CSS\n *\n * ## PostCSS vs Sass/Less\n *\n * | Feature | `PostCSS` | Sass/Less |\n * |---------|---------|-----------|\n * | **Approach** | Plugin-based transformation | Full preprocessor language |\n * | **Flexibility** | Use only what you need | All-or-nothing |\n * | **Performance** | Fast, minimal overhead | Slower compilation |\n * | **Modern CSS** | Uses actual CSS syntax | Custom syntax |\n * | **Ecosystem** | Huge plugin library | Built-in features only |\n *\n * ## Plugins Used in This Project\n *\n * This project uses two essential PostCSS plugins:\n *\n * 1. **Tailwind CSS** - Generates utility-first CSS classes\n * 2. **Autoprefixer** - Adds vendor prefixes for browser compatibility\n *\n * ## How It Works\n *\n * ```\n * Your CSS â†’ PostCSS â†’ Tailwind Plugin â†’ Autoprefixer â†’ Output CSS\n * ```\n */\n// CLOSE: postcss-config-file\n\n/**\n * REF: postcss-plugins-config\n *\n * # PostCSS Plugins Configuration\n *\n * Exports the plugins that PostCSS will use to transform CSS.\n *\n * ## Configuration Format\n *\n * PostCSS uses a simple object where:\n * - **Keys**: Plugin names\n * - **Values**: Plugin options (empty object `{}` for defaults)\n *\n * ```javascript\n * module.exports = {\n *   plugins: {\n *     'plugin-name': { option: value },\n *     'another-plugin': {},\n *   },\n * }\n * ```\n */\nmodule.exports = {\n  plugins: {\n    // CLOSE: postcss-plugins-config\n\n    /**\n     * REF: tailwind-css-plugin\n     *\n     * # Tailwind CSS Plugin\n     *\n     * Processes Tailwind CSS directives and generates utility classes.\n     *\n     * ## What Tailwind Does\n     *\n     * Tailwind processes three main directives in your CSS:\n     *\n     * | `Directive` | Purpose | Example Output |\n     * |-----------|---------|----------------|\n     * | `@tailwind base` | CSS reset and base styles | Normalizes browser defaults |\n     * | `@tailwind components` | Component-level styles | `.btn`, `.card`, etc. |\n     * | `@tailwind utilities` | Utility classes | `.flex`, `.text-center`, etc. |\n     *\n     * ## How It Works\n     *\n     * ### Development Mode\n     *\n     * 1. **Scan files**: Looks for Tailwind classes in JS/TS/JSX files\n     * 2. **Generate CSS**: Creates CSS for all found classes\n     * 3. **Output**: Serves complete CSS file (~3-4MB uncompressed)\n     * 4. **Fast**: Uses JIT (Just-In-Time) mode for instant updates\n     *\n     * ### Production Mode\n     *\n     * 1. **Scan files**: Same as development\n     * 2. **Purge**: Removes unused classes\n     * 3. **Generate**: Only creates CSS for used classes\n     * 4. **Minify**: Compresses the output\n     * 5. **Result**: Tiny CSS file (~10-20KB)\n     *\n     * ## Example Transformation\n     *\n     * **Your Component:**\n     * ```tsx\n     * <div className=\"flex items-center gap-4 p-4 bg-blue-500 rounded-lg\">\n     *   <span className=\"text-white font-bold\">Hello</span>\n     * </div>\n     * ```\n     *\n     * **Generated CSS:**\n     * ```css\n     * .flex { display: flex; }\n     * .items-center { align-items: center; }\n     * .gap-4 { gap: 1rem; }\n     * .p-4 { padding: 1rem; }\n     * .bg-blue-500 { background-color: #3b82f6; }\n     * .rounded-lg { border-radius: 0.5rem; }\n     * .text-white { color: #fff; }\n     * .font-bold { font-weight: 700; }\n     * ```\n     *\n     * ## Configuration Source\n     *\n     * Tailwind reads its configuration from `tailwind.config.ts`:\n     * - Theme colors\n     * - Spacing scale\n     * - Breakpoints\n     * - Custom utilities\n     * - Content paths to scan\n     *\n     * ## JIT (Just-In-Time) Mode\n     *\n     * Modern Tailwind uses JIT compilation:\n     *\n     * **Traditional Mode (Old):**\n     * - Generates all possible classes upfront\n     * - Huge development CSS files\n     * - Slower build times\n     *\n     * **JIT Mode (Current):**\n     * - Generates only used classes\n     * - Fast development builds\n     * - Same CSS in dev and production\n     * - Supports arbitrary values: `w-[137px]`\n     *\n     * ## Performance Benefits\n     *\n     * - **No runtime**: CSS is generated at build time\n     * - **Small bundles**: Only used classes included\n     * - **Fast styles**: No CSS-in-JS overhead\n     * - **Cacheable**: CSS file can be cached forever\n     */\n    tailwindcss: {},\n    // CLOSE: tailwind-css-plugin\n\n    /**\n     * REF: autoprefixer-plugin\n     *\n     * # Autoprefixer Plugin\n     *\n     * Automatically adds vendor prefixes to CSS properties for browser compatibility.\n     *\n     * ## What Problem Does It Solve?\n     *\n     * Different browsers need different CSS prefixes for experimental features:\n     *\n     * - `-webkit-`: Chrome, Safari, newer Edge\n     * - `-moz-`: Firefox\n     * - `-ms-`: Old Edge, IE\n     * - `-o-`: Old Opera\n     *\n     * Writing these manually is tedious and error-prone!\n     *\n     * ## Example Transformation\n     *\n     * **Your CSS:**\n     * ```css\n     * .box {\n     *   display: flex;\n     *   user-select: none;\n     *   backdrop-filter: blur(10px);\n     * }\n     * ```\n     *\n     * **Output CSS:**\n     * ```css\n     * .box {\n     *   display: -webkit-box;\n     *   display: -ms-flexbox;\n     *   display: flex;\n     *   -webkit-user-select: none;\n     *   -moz-user-select: none;\n     *   -ms-user-select: none;\n     *   user-select: none;\n     *   -webkit-backdrop-filter: blur(10px);\n     *   backdrop-filter: blur(10px);\n     * }\n     * ```\n     *\n     * ## Browser Support Targets\n     *\n     * Autoprefixer uses **Browserslist** to determine which browsers to support.\n     *\n     * ### Default Browserslist Query\n     *\n     * If not configured, uses these defaults:\n     * - `> 0.5%` - Browsers with >0.5% market share\n     * - `last 2 versions` - Last 2 versions of each browser\n     * - `Firefox ESR` - Firefox Extended Support Release\n     * - `not dead` - Browsers still receiving updates\n     *\n     * ### Custom Browserslist\n     *\n     * You can customize in `package.json`:\n     *\n     * ```json\n     * {\n     *   \"browserslist\": [\n     *     \">0.2%\",\n     *     \"not dead\",\n     *     \"not op_mini all\"\n     *   ]\n     * }\n     * ```\n     *\n     * Or in `.browserslistrc` file:\n     * ```\n     * > 0.2%\n     * not dead\n     * not op_mini all\n     * ```\n     *\n     * ## Smart Prefix Addition\n     *\n     * Autoprefixer only adds prefixes when needed:\n     *\n     * - **Widely supported features**: No prefixes added\n     * - **Experimental features**: All relevant prefixes added\n     * - **Old features**: Removes outdated prefixes\n     *\n     * **Example - No prefixes needed:**\n     * ```css\n     * .box {\n     *   color: red;  /* No prefixes needed */\n     *   margin: 10px; /* Universal support */\n     * }\n     * ```\n     *\n     * ## Benefits\n     *\n     * | Benefit | Description |\n     * |---------|-------------|\n     * | **Automatic** | No manual prefix management |\n     * | **Optimized** | Only adds necessary prefixes |\n     * | **Up-to-date** | Uses Can I Use database |\n     * | **Clean code** | Write standard CSS |\n     * | **Future-proof** | Updates as browsers evolve |\n     *\n     * ## No Configuration Needed\n     *\n     * Autoprefixer works out of the box with sensible defaults:\n     * - Supports all modern browsers\n     * - Automatically updates with browser changes\n     * - Uses latest Can I Use data\n     *\n     * Just include it in PostCSS config and it works!\n     */\n    autoprefixer: {},\n    // CLOSE: autoprefixer-plugin\n  },\n}\n\n/**\n * REF: postcss-processing-flow\n *\n * # How PostCSS Processes CSS\n *\n * Understanding the CSS transformation pipeline in development and production.\n *\n * ## Development Build Flow\n *\n * When you run `npm run dev`:\n *\n * ```\n * 1. Next.js starts development server\n *    â†“\n * 2. Reads app/globals.css\n *    â†“\n * 3. PostCSS processes the CSS\n *    â†“\n * 4. Tailwind plugin runs\n *    â€¢ Scans files for class names\n *    â€¢ Generates CSS for found classes\n *    â€¢ Uses JIT mode for speed\n *    â†“\n * 5. Autoprefixer plugin runs\n *    â€¢ Adds vendor prefixes\n *    â€¢ Based on browserslist config\n *    â†“\n * 6. CSS served to browser\n *    â€¢ Hot reloads on changes\n *    â€¢ Fast updates with HMR\n * ```\n *\n * ### Development Characteristics\n *\n * - **Full CSS**: Includes all used classes\n * - **Unminified**: Readable for debugging\n * - **Source maps**: Map CSS to source files\n * - **Fast updates**: JIT compilation\n * - **Size**: ~50-200KB (not optimized)\n *\n * ## Production Build Flow\n *\n * When you run `npm run build`:\n *\n * ```\n * 1. Next.js starts production build\n *    â†“\n * 2. Scans all files for CSS usage\n *    â†“\n * 3. Tailwind plugin runs\n *    â€¢ Scans ALL files for classes\n *    â€¢ Generates only used classes\n *    â€¢ Removes unused utilities\n *    â†“\n * 4. Autoprefixer plugin runs\n *    â€¢ Adds necessary prefixes\n *    â€¢ Removes outdated prefixes\n *    â†“\n * 5. CSS optimization\n *    â€¢ Minification\n *    â€¢ Deduplication\n *    â€¢ Compression\n *    â†“\n * 6. Output optimized CSS\n *    â€¢ Hashed filename for caching\n *    â€¢ Example: styles.a3f4b2.css\n * ```\n *\n * ### Production Characteristics\n *\n * - **Minimal CSS**: Only used classes\n * - **Minified**: Compressed, no whitespace\n * - **Optimized**: Dead code eliminated\n * - **Cacheable**: Hashed filenames\n * - **Size**: ~10-20KB (highly optimized)\n *\n * ## Performance Comparison\n *\n * | `Aspect` | `Development` | `Production` |\n * |--------|-------------|------------|\n * | CSS Size | ~100KB | ~15KB |\n * | `Minified` | `No` | `Yes` |\n * | Source Maps | `Yes` | `Optional` |\n * | All Utilities | `Yes` | No, only used |\n * | Build Time | Fast (<1s) | Slower (5-10s) |\n * | `Prefixes` | `All` | Only needed |\n *\n * ## Example: Size Reduction\n *\n * **Development CSS:**\n * ```css\n * /* Includes everything you might use */\n * .flex { display: flex; }\n * .grid { display: grid; }\n * .block { display: block; }\n * /* ... 1000s more classes */\n * ```\n *\n * **Production CSS (if only using flex and grid):**\n * ```css\n * .flex{display:flex}.grid{display:grid}\n * ```\n */\n// CLOSE: postcss-processing-flow\n\n/**\n * REF: nextjs-postcss-integration\n *\n * # Integration with Next.js\n *\n * How Next.js automatically uses PostCSS for CSS processing.\n *\n * ## Automatic Detection\n *\n * Next.js automatically uses PostCSS when it finds:\n *\n * 1. **postcss.config.js** - This configuration file\n * 2. **CSS imports** - Any `.css` file imported in components\n *\n * ### No Additional Setup Needed\n *\n * - No webpack configuration required\n * - No babel plugins needed\n * - No build script modifications\n * - Just works out of the box!\n *\n * ## CSS Import Flow\n *\n * **In your component:**\n * ```tsx\n * import './styles.css'  // Any CSS import\n * ```\n *\n * **Next.js automatically:**\n * 1. Detects the CSS import\n * 2. Runs it through PostCSS\n * 3. Applies configured plugins\n * 4. Bundles the result\n * 5. Injects into the page\n *\n * ## Global CSS\n *\n * **app/layout.tsx:**\n * ```tsx\n * import './globals.css'  // Processed by PostCSS\n * ```\n *\n * **app/globals.css:**\n * ```css\n * @tailwind base;      // â† Tailwind plugin processes this\n * @tailwind components; // â† Tailwind plugin processes this\n * @tailwind utilities;  // â† Tailwind plugin processes this\n *\n * .custom-class {\n *   display: flex;     // â† Autoprefixer adds prefixes\n * }\n * ```\n *\n * ## CSS Modules\n *\n * PostCSS also works with CSS Modules:\n *\n * ```tsx\n * import styles from './Button.module.css'\n * ```\n *\n * Both plugins apply to module CSS as well!\n *\n * ## Configuration Loading\n *\n * Next.js looks for PostCSS config in this order:\n *\n * 1. `postcss.config.js` (this file) âœ“\n * 2. `postcss.config.json`\n * 3. `.postcssrc`\n * 4. Default config (if none found)\n *\n * ## Customizing PostCSS\n *\n * You can add more plugins if needed:\n *\n * ```javascript\n * module.exports = {\n *   plugins: {\n *     tailwindcss: {},\n *     autoprefixer: {},\n *     'postcss-preset-env': {}, // Additional plugin\n *     cssnano: {},               // CSS minification\n *   },\n * }\n * ```\n *\n * ## Performance Optimization\n *\n * Next.js optimizes PostCSS processing:\n *\n * - **Caching**: Processed CSS cached between builds\n * - **Parallel**: Processes CSS in parallel with JS\n * - **Incremental**: Only reprocesses changed files\n * - **Fast Refresh**: CSS updates without full reload\n */\n// CLOSE: nextjs-postcss-integration\n\n",
      "language": "javascript"
    },
    {
      "path": "tailwind.config.ts",
      "content": "/**\n * REF: file-header\n *\n * # Tailwind CSS Configuration\n *\n * Configuration for Tailwind CSS in the Next.js + Firebase project.\n *\n * ## What is Tailwind?\n * Utility-first CSS framework that generates styles based on class names used in your code.\n *\n * ## How It Works\n * | Step | Process |\n * |------|---------|\n * | `1` | Scans files in `content` array |\n * | `2` | Finds Tailwind classes (e.g., `bg-blue-500`) |\n * | `3` | Generates only CSS for used classes |\n * | `4` | Results in minimal bundle size |\n *\n * ## Benefits\n * - **JIT**: Just-In-Time compilation for fast builds\n * - **Tree-shaking**: Only includes used styles\n * - **Type-safe**: With TypeScript configuration\n * - **Customizable**: Extend theme as needed\n */\n// CLOSE: file-header\n\n/**\n * REF: imports\n *\n * ## Import TypeScript Types\n *\n * Import `Config` type for type-safe configuration.\n */\nimport type { Config } from 'tailwindcss'\n// CLOSE: imports\n\n/**\n * REF: config-object\n *\n * ## Tailwind Configuration Object\n *\n * Main configuration with TypeScript typing for IDE support and validation.\n */\nconst config: Config = {\n  /**\n   * REF: content-paths\n   *\n   * ## Content Paths\n   *\n   * Specifies which files Tailwind should scan for class names.\n   *\n   * ### Glob Patterns\n   * | Pattern | Matches | Purpose |\n   * |---------|---------|---------|\n   * | `./pages/**\\/*.{js,ts,jsx,tsx,mdx}` | Pages directory | Pages Router |\n   * | `./components/**\\/*.{js,ts,jsx,tsx,mdx}` | Components | React components |\n   * | `./app/**\\/*.{js,ts,jsx,tsx,mdx}` | App directory | App Router |\n   *\n   * ### File Extensions\n   * - `.js` / `.jsx`: JavaScript/React\n   * - `.ts` / `.tsx`: TypeScript/React\n   * - `.mdx`: Markdown + JSX\n   *\n   * ### Performance\n   * Only scans these paths, generates only needed CSS.\n   *\n   * ### Example Detection\n   * ```tsx\n   * <div className=\"bg-blue-500 text-white p-4 rounded-lg\">\n   *   // Tailwind finds: bg-blue-500, text-white, p-4, rounded-lg\n   * </div>\n   * ```\n   */\n  content: [\n    './pages/**/*.{js,ts,jsx,tsx,mdx}',\n    './components/**/*.{js,ts,jsx,tsx,mdx}',\n    './app/**/*.{js,ts,jsx,tsx,mdx}',\n  ],\n  // CLOSE: content-paths\n\n  /**\n   * REF: theme-config\n   *\n   * ## Theme Configuration\n   *\n   * Customize or extend Tailwind's default theme.\n   *\n   * ### Extend vs Replace\n   * - `extend`: Adds to defaults (recommended)\n   * - Direct properties: Replace defaults\n   *\n   * ### Default Configuration\n   * Empty `extend` uses all Tailwind defaults:\n   * - Color palette (blue, red, green, etc.)\n   * - Spacing scale (1, 2, 4, 8, etc.)\n   * - Breakpoints (sm, md, lg, xl, 2xl)\n   * - Font families\n   *\n   * ### Extending Example\n   * ```typescript\n   * theme: {\n   *   extend: {\n   *     colors: {\n   *       primary: '#3b82f6',\n   *       secondary: '#8b5cf6',\n   *     },\n   *     spacing: {\n   *       '128': '32rem',\n   *     },\n   *     fontFamily: {\n   *       custom: ['Inter', 'sans-serif'],\n   *     },\n   *   },\n   * }\n   * ```\n   *\n   * ### Usage After Extending\n   * ```tsx\n   * <div className=\"bg-primary text-secondary p-128 font-custom\" />\n   * ```\n   */\n  theme: {\n    extend: {},\n  },\n  // CLOSE: theme-config\n\n  /**\n   * REF: plugins-config\n   *\n   * ## Plugins Configuration\n   *\n   * Array of Tailwind plugins for additional functionality.\n   *\n   * ### What Are Plugins?\n   * Add new utilities, components, or features to Tailwind.\n   *\n   * ### Popular Plugins\n   * | Plugin | Purpose |\n   * |--------|---------|\n   * | `@tailwindcss/forms` | Better form styling |\n   * | `@tailwindcss/typography` | Prose/markdown styling |\n   * | `@tailwindcss/aspect-ratio` | Aspect ratio utilities |\n   * | `@tailwindcss/line-clamp` | Line clamping |\n   *\n   * ### Adding Plugins\n   * ```bash\n   * npm install @tailwindcss/forms\n   * ```\n   * ```typescript\n   * import forms from '@tailwindcss/forms'\n   *\n   * plugins: [forms],\n   * ```\n   *\n   * ### Default\n   * Empty array = no additional plugins, all default utilities available.\n   */\n  plugins: [],\n  // CLOSE: plugins-config\n}\n// CLOSE: config-object\n\n/**\n * REF: export\n *\n * ## Export Configuration\n *\n * Export config for Next.js and Tailwind to use automatically.\n */\nexport default config\n// CLOSE: export\n\n/**\n * REF: usage-patterns\n *\n * ## Common Tailwind Patterns in Project\n *\n * Examples of Tailwind usage throughout the codebase.\n *\n * ### Layout Classes\n * ```tsx\n * // Flexbox\n * <div className=\"flex items-center justify-between gap-4\">\n *\n * // Grid\n * <div className=\"grid grid-cols-3 gap-6\">\n *\n * // Spacing\n * <div className=\"p-4 m-2 space-y-3\">\n * ```\n *\n * ### Styling Classes\n * ```tsx\n * // Colors\n * <div className=\"bg-blue-500 text-white\">\n *\n * // Typography\n * <h1 className=\"text-2xl font-bold\">\n *\n * // Borders\n * <div className=\"border border-gray-300 rounded-lg\">\n * ```\n *\n * ### Responsive Classes\n * ```tsx\n * // Mobile-first breakpoints\n * <div className=\"w-full md:w-1/2 lg:w-1/3\">\n * // Full width mobile, half tablet, third desktop\n * ```\n *\n * ### Dark Mode Classes\n * ```tsx\n * <div className=\"bg-white dark:bg-gray-800 text-black dark:text-white\">\n * ```\n *\n * ### State Classes\n * ```tsx\n * <button className=\"bg-blue-500 hover:bg-blue-700 focus:ring-2 active:scale-95\">\n * ```\n */\n// CLOSE: usage-patterns\n\n/**\n * REF: performance-notes\n *\n * ## Performance Optimizations\n *\n * Tailwind automatically optimizes CSS output.\n *\n * ### JIT Mode\n * - Generates styles on-demand\n * - Faster build times\n * - Smaller CSS bundles\n * - Arbitrary value support (e.g., `w-[73px]`)\n *\n * ### Production Build\n * ```bash\n * npm run build\n * ```\n * - Removes unused CSS\n * - Minifies output\n * - Optimizes for performance\n *\n * ### Bundle Size\n * | Environment | CSS Size |\n * |-------------|----------|\n * | `Development` | All utilities available |\n * | `Production` | Only used utilities |\n * | `Typical` | 10-50KB gzipped |\n */\n// CLOSE: performance-notes\n\n/**\n * REF: resources\n *\n * ## Customization Resources\n *\n * ### Official Documentation\n * - Main docs: https://tailwindcss.com/docs\n * - Configuration: https://tailwindcss.com/docs/configuration\n * - Theme: https://tailwindcss.com/docs/theme\n * - Plugins: https://tailwindcss.com/docs/plugins\n * - Dark Mode: https://tailwindcss.com/docs/dark-mode\n *\n * ### VS Code Extension\n * **Tailwind CSS IntelliSense**\n * - Class name autocomplete\n * - CSS value preview on hover\n * - Class name validation\n * - Syntax highlighting\n */\n// CLOSE: resources\n",
      "language": "typescript"
    },
    {
      "path": "tsconfig.json",
      "content": "{\n  \"compilerOptions\": {\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\",\n    \"incremental\": true,\n    \"plugins\": [\n      {\n        \"name\": \"next\"\n      }\n    ],\n    \"paths\": {\n      \"@/*\": [\"./*\"]\n    }\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\", \".next/types/**/*.ts\"],\n  \"exclude\": [\"node_modules\"]\n}\n",
      "language": "json"
    },
    {
      "path": "tsconfig.md",
      "content": "# TypeScript Configuration - tsconfig.json\n\n**Note:** JSON files don't support comments, so this documentation is in a separate file.\n\n## Overview\n\nThe `tsconfig.json` file configures TypeScript for this Next.js project.\n\n## Key Settings Explained\n\n### Compiler Options\n\n**lib: [\"dom\", \"dom.iterable\", \"esnext\"]**\n- Includes type definitions for browser APIs and modern JavaScript\n\n**strict: true**\n- Enables all strict type checking options\n- Catches more errors at compile time\n\n**noEmit: true**\n- TypeScript doesn't output files (Next.js handles that)\n\n**jsx: \"preserve\"**\n- Keeps JSX as-is for Next.js to transform\n\n**paths: { \"@/*\": [\"./*\"] }**\n- Allows `import from '@/types'` instead of `'../../../types'`\n\n### Benefits\n\n- Catches errors before runtime\n- Better autocomplete in IDEs\n- Safer refactoring\n- Self-documenting code\n\n**Audio Guide:** `audio/nextjs-firebase/tsconfig.mp3`\n",
      "language": "markdown"
    },
    {
      "path": "types/index.ts",
      "content": "/**\n * REF: types-file-header\n *\n * # TypeScript Type Definitions\n *\n * Centralized type definitions for the Next.js + Firebase application.\n *\n * ## Key Concepts\n *\n * - **TypeScript interfaces** - Define data shapes\n * - **Compile-time validation** - Catch errors before runtime\n * - **IDE autocomplete** - Better developer experience\n * - **Self-documenting code** - Types explain data structure\n *\n * ## Why Centralized Types?\n *\n * | Benefit | Description |\n * |---------|-------------|\n * | Single source of truth | Update in one place |\n * | Reusability | Import across components |\n * | Consistency | Same data shape everywhere |\n * | Easy refactoring | Change once, TypeScript finds all usages |\n *\n * ## Firestore Timestamp\n *\n * Firebase's `Timestamp` type for dates:\n * - Stores as seconds + nanoseconds\n * - Convert to JavaScript Date with `.toDate()`\n * - Use `Timestamp.now()` for current server time\n * - Consistent across timezones\n */\n\nimport { Timestamp } from 'firebase/firestore'\n// CLOSE: types-file-header\n\n/**\n * REF: user-interface\n *\n * ## User Interface\n *\n * Represents a user profile in the application.\n *\n * ### Fields\n *\n * | Field | Type | Required | Description |\n * |-------|------|----------|-------------|\n * | `id` | `string` | Yes | Unique identifier (Firebase Auth UID) |\n * | `email` | `string` | Yes | User's email address |\n * | `displayName` | `string` | No | Optional display name |\n * | `profilePicture` | `string` | No | URL to profile image in Storage |\n * | `createdAt` | `Timestamp` | Yes | Account creation time |\n * | `updatedAt` | `Timestamp` | Yes | Last profile update time |\n *\n * ### Stored In\n *\n * Firestore collection: `users`\n *\n * ### Optional Fields\n *\n * The `?` question mark indicates optional fields:\n * - Can be `undefined`\n * - Must check before using: `if (user.displayName) { ... }`\n * - TypeScript enforces null checks\n *\n * ### Example\n *\n * ```typescript\n * const user: User = {\n *   id: 'abc123',\n *   email: 'user@example.com',\n *   displayName: 'John Doe',\n *   profilePicture: 'https://storage.../photo.jpg',\n *   createdAt: Timestamp.now(),\n *   updatedAt: Timestamp.now()\n * }\n * ```\n */\nexport interface User {\n  id: string\n  email: string\n  displayName?: string\n  profilePicture?: string\n  createdAt: Timestamp\n  updatedAt: Timestamp\n}\n// CLOSE: user-interface\n\n/**\n * REF: user-settings-interface\n *\n * ## UserSettings Interface\n *\n * Stores user accessibility and appearance preferences.\n *\n * ### Fields\n *\n * | Field | Type | Options | Description |\n * |-------|------|---------|-------------|\n * | `id` | `string` | - | Settings document ID |\n * | `userId` | `string` | - | Reference to user (foreign key) |\n * | `theme` | `'light' \\| 'dark'` | light, dark | Color scheme |\n * | `fontSize` | `'small' \\| 'medium' \\| 'large'` | small, medium, large | Text size |\n * | `highContrast` | `boolean` | true, false | Enhanced contrast mode |\n * | `reducedMotion` | `boolean` | true, false | Disable animations |\n * | `updatedAt` | `Timestamp` | - | Last settings change |\n *\n * ### Stored In\n *\n * Firestore collection: `userSettings`\n *\n * ### Union Types\n *\n * - `theme: 'light' | 'dark'` means ONLY these two string values allowed\n * - TypeScript enforces this at compile time\n * - Prevents typos like `'drak'` or `'lite'`\n * - Great for dropdown/select options\n *\n * ### Example\n *\n * ```typescript\n * const settings: UserSettings = {\n *   id: 'settings-1',\n *   userId: 'user-123',\n *   theme: 'dark',\n *   fontSize: 'medium',\n *   highContrast: false,\n *   reducedMotion: true,\n *   updatedAt: Timestamp.now()\n * }\n * ```\n */\nexport interface UserSettings {\n  id: string\n  userId: string\n  theme: 'light' | 'dark'\n  fontSize: 'small' | 'medium' | 'large'\n  highContrast: boolean\n  reducedMotion: boolean\n  updatedAt: Timestamp\n}\n// CLOSE: user-settings-interface\n\n/**\n * REF: todo-interface\n *\n * ## Todo Interface\n *\n * Represents a single todo item.\n *\n * ### Fields\n *\n * | Field | Type | Required | Description |\n * |-------|------|----------|-------------|\n * | `id` | `string` | Yes | Unique todo identifier |\n * | `userId` | `string` | Yes | Owner of the todo |\n * | `title` | `string` | Yes | Todo title (max 500 chars) |\n * | `description` | `string` | No | Optional detailed description |\n * | `completed` | `boolean` | Yes | Completion status |\n * | `isPublic` | `boolean` | Yes | Visible in public feed |\n * | `tags` | `string[]` | No | Array of tag strings |\n * | `createdAt` | `Timestamp` | Yes | Creation time |\n * | `updatedAt` | `Timestamp` | Yes | Last modification time |\n *\n * ### Stored In\n *\n * Firestore collection: `todos`\n *\n * ### Public Todos\n *\n * - `isPublic: true` makes todo visible to all users\n * - Used for community feed feature\n * - Security rules enforce modification permissions\n *\n * ### Array Fields\n *\n * - `tags?: string[]` is optional array\n * - Can be `undefined` or empty array `[]`\n * - Check with: `if (todo.tags?.length) { ... }`\n * - Optional chaining `?.` prevents errors\n *\n * ### Example\n *\n * ```typescript\n * const todo: Todo = {\n *   id: 'todo-123',\n *   userId: 'user-456',\n *   title: 'Complete documentation',\n *   description: 'Add REF/CLOSE markers to all files',\n *   completed: false,\n *   isPublic: true,\n *   tags: ['work', 'urgent'],\n *   createdAt: Timestamp.now(),\n *   updatedAt: Timestamp.now()\n * }\n * ```\n */\nexport interface Todo {\n  id: string\n  userId: string\n  title: string\n  description?: string\n  completed: boolean\n  isPublic: boolean\n  tags?: string[]\n  createdAt: Timestamp\n  updatedAt: Timestamp\n}\n// CLOSE: todo-interface\n\n/**\n * REF: todo-attachment-interface\n *\n * ## TodoAttachment Interface\n *\n * Metadata for files attached to todos.\n *\n * ### Fields\n *\n * | Field | Type | Required | Description |\n * |-------|------|----------|-------------|\n * | `id` | `string` | Yes | Attachment identifier |\n * | `todoId` | `string` | Yes | Parent todo reference |\n * | `fileName` | `string` | Yes | Original filename |\n * | `fileUrl` | `string` | Yes | Download URL from Storage |\n * | `fileSize` | `number` | Yes | Size in bytes |\n * | `mimeType` | `string` | Yes | File MIME type |\n * | `uploadedAt` | `Timestamp` | Yes | Upload timestamp |\n *\n * ### Stored In\n *\n * Firestore collection: `todoAttachments`\n *\n * ### File Storage Architecture\n *\n * Two-part system:\n * 1. **File content** â†’ Firebase Storage bucket\n * 2. **File metadata** â†’ Firestore collection (this interface)\n *\n * Why separate?\n * - Searchable metadata in Firestore\n * - Large files in Storage\n * - Query attachments without downloading files\n * - Better performance\n *\n * ### Size Limits\n *\n * - `fileSize` validated (max 5MB typically)\n * - Enforced in Storage rules and client code\n * - Prevents abuse and excessive costs\n *\n * ### Example\n *\n * ```typescript\n * const attachment: TodoAttachment = {\n *   id: 'attach-789',\n *   todoId: 'todo-123',\n *   fileName: 'document.pdf',\n *   fileUrl: 'https://storage.googleapis.com/...',\n *   fileSize: 102400, // bytes\n *   mimeType: 'application/pdf',\n *   uploadedAt: Timestamp.now()\n * }\n * ```\n */\nexport interface TodoAttachment {\n  id: string\n  todoId: string\n  fileName: string\n  fileUrl: string\n  fileSize: number\n  mimeType: string\n  uploadedAt: Timestamp\n}\n// CLOSE: todo-attachment-interface\n\n/**\n * REF: message-interface\n *\n * ## Message Interface\n *\n * Represents a direct message in the chat system.\n *\n * ### Fields\n *\n * | Field | Type | Required | Description |\n * |-------|------|----------|-------------|\n * | `id` | `string` | Yes | Message identifier |\n * | `senderId` | `string` | Yes | User who sent message |\n * | `recipientId` | `string` | Yes | User who receives message |\n * | `content` | `string` | Yes | Message text (max 2000 chars) |\n * | `read` | `boolean` | Yes | Read status |\n * | `readAt` | `Timestamp` | No | When marked as read |\n * | `createdAt` | `Timestamp` | Yes | Send time |\n *\n * ### Stored In\n *\n * Firestore collection: `messages`\n *\n * ### Read Receipts\n *\n * Two-field pattern:\n * - `read: boolean` - Simple flag\n * - `readAt?: Timestamp` - When it was read\n *\n * Used for:\n * - \"Seen\" indicators in chat UI\n * - Message delivery confirmation\n * - Tracking engagement\n *\n * ### Privacy & Security\n *\n * - Security rules ensure only sender/recipient can read\n * - Can't access others' conversations\n * - Enforced at database level (not just UI)\n * - RLS equivalent in Firestore\n *\n * ### Example\n *\n * ```typescript\n * const message: Message = {\n *   id: 'msg-789',\n *   senderId: 'user-123',\n *   recipientId: 'user-456',\n *   content: 'Hello! How are you?',\n *   read: false,\n *   createdAt: Timestamp.now()\n * }\n *\n * // Later, when recipient reads it:\n * await markMessageAsRead(message.id)\n * // Sets: read = true, readAt = Timestamp.now()\n * ```\n */\nexport interface Message {\n  id: string\n  senderId: string\n  recipientId: string\n  content: string\n  read: boolean\n  readAt?: Timestamp\n  createdAt: Timestamp\n}\n// CLOSE: message-interface\n\n/**\n * REF: todo-with-user-interface\n *\n * ## TodoWithUser Interface\n *\n * Extended Todo with user information for display in public feed.\n *\n * ### Extension Pattern\n *\n * ```typescript\n * interface TodoWithUser extends Todo {\n *   user?: { ... }\n * }\n * ```\n *\n * This means:\n * - Has all `Todo` fields\n * - Plus additional `user` field\n * - Type-safe inheritance\n *\n * ### Fields\n *\n * All fields from `Todo` interface, plus:\n *\n * | Field | Type | Required | Description |\n * |-------|------|----------|-------------|\n * | `user.displayName` | `string` | No | User's display name |\n * | `user.profilePicture` | `string` | No | User's profile picture URL |\n *\n * ### Use Case\n *\n * Public feed showing who created each todo:\n * - Join todo data with user data\n * - Display creator's name and picture\n * - One query instead of two\n *\n * ### Optional User\n *\n * - `user?` means might not have user data\n * - Check before accessing: `if (todo.user?.displayName)`\n * - Optional chaining `?.` prevents null errors\n *\n * ### Example\n *\n * ```typescript\n * const publicTodo: TodoWithUser = {\n *   id: 'todo-123',\n *   userId: 'user-456',\n *   title: 'Learn TypeScript',\n *   completed: false,\n *   isPublic: true,\n *   tags: ['learning'],\n *   createdAt: Timestamp.now(),\n *   updatedAt: Timestamp.now(),\n *   user: {\n *     displayName: 'Jane Doe',\n *     profilePicture: 'https://storage.../photo.jpg'\n *   }\n * }\n *\n * // Display in UI:\n * <div>\n *   <p>{publicTodo.title}</p>\n *   <p>By {publicTodo.user?.displayName ?? 'Anonymous'}</p>\n * </div>\n * ```\n */\nexport interface TodoWithUser extends Todo {\n  user?: {\n    displayName?: string\n    profilePicture?: string\n  }\n}\n// CLOSE: todo-with-user-interface\n\n/**\n * REF: type-usage-guide\n *\n * ## Using These Types\n *\n * Import types in your components and functions.\n *\n * ### Import Syntax\n *\n * ```typescript\n * import type { Todo, User, Message } from '@/types'\n * ```\n *\n * ### Creating Typed Objects\n *\n * ```typescript\n * const todo: Todo = {\n *   id: '123',\n *   userId: 'user-456',\n *   title: 'Buy groceries',\n *   completed: false,\n *   isPublic: true,\n *   createdAt: Timestamp.now(),\n *   updatedAt: Timestamp.now(),\n * }\n * ```\n *\n * ### TypeScript Validation\n *\n * TypeScript catches errors at compile time:\n *\n * | Error Type | Example | TypeScript Message |\n * |------------|---------|-------------------|\n * | Missing field | No `title` | Property 'title' is missing |\n * | Wrong type | `completed: 'yes'` | Type 'string' not assignable to 'boolean' |\n * | Extra field | `invalid: true` | Object literal may only specify known properties |\n * | Typo | `titel: 'Task'` | Did you mean 'title'? |\n *\n * This catches errors **before runtime**!\n *\n * ### Function Parameters\n *\n * ```typescript\n * async function getTodo(id: string): Promise<Todo | null> {\n *   const doc = await getDoc(doc(db, 'todos', id))\n *   return doc.exists() ? { id: doc.id, ...doc.data() } as Todo : null\n * }\n * ```\n */\n// CLOSE: type-usage-guide\n\n/**\n * REF: type-vs-interface\n *\n * ## Type vs Interface\n *\n * Both define object shapes, with slight differences.\n *\n * ### Comparison\n *\n * | Feature | Interface | Type |\n * |---------|-----------|------|\n * | Extend other types | âœ… Yes | âœ… Yes |\n * | Implement by class | âœ… Yes | âŒ No |\n * | Union types | âŒ No | âœ… Yes |\n * | Intersection types | âŒ No | âœ… Yes |\n * | Declaration merging | âœ… Yes | âŒ No |\n * | Best for | Object shapes | Unions, utilities |\n *\n * ### When to Use Interface\n *\n * ```typescript\n * // âœ… Good: Data models\n * interface User {\n *   id: string\n *   email: string\n * }\n *\n * // âœ… Good: Can extend\n * interface Admin extends User {\n *   role: 'admin'\n * }\n * ```\n *\n * ### When to Use Type\n *\n * ```typescript\n * // âœ… Good: Union types\n * type Theme = 'light' | 'dark'\n * type Status = 'pending' | 'active' | 'completed'\n *\n * // âœ… Good: Complex utilities\n * type Nullable<T> = T | null\n * type ReadOnly<T> = { readonly [K in keyof T]: T[K] }\n * ```\n *\n * ### This Project's Convention\n *\n * - **Interfaces** for data models (User, Todo, Message)\n * - **Types** for utility types and unions\n * - Consistent pattern throughout codebase\n */\n// CLOSE: type-vs-interface\n",
      "language": "typescript"
    }
  ]
}