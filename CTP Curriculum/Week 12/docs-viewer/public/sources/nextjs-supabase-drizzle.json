{
  "project": "nextjs-supabase-drizzle",
  "fileCount": 26,
  "files": [
    {
      "path": "FIX_REF_CLOSE.md",
      "content": "# REF/CLOSE Documentation Fixes - Summary Report\n\n## Project Path\n`/workspaces/ctp-fall-wd-curriculum/CTP Curriculum/Week 12/example-projects/nextjs-supabase-drizzle`\n\n## Files Fixed\n\n### 1. **components/todos/TodoList.tsx** - FIXED ‚úÖ\n- **REF/CLOSE pairs corrected:** 10\n- **Changes made:**\n  - Replaced HTML-style comments (`<!-- -->`) with JavaScript comments (`/** */` and `// `)\n  - Moved CLOSE markers from inside REF comment blocks to separate comments after code\n  - Updated all section names to use kebab-case (e.g., `component-overview`, `type-definition`)\n\n**Pairs fixed:**\n1. `component-overview` - Component overview documentation\n2. `type-definition` - Todo type from Drizzle schema\n3. `props-interface` - TodoListProps interface\n4. `component-function` - Main component function\n5. `todo-filtering` - Active/completed todo filtering logic\n6. `component-render` - Render structure\n7. `active-todos-section` - Active todos display\n8. `completed-todos-section` - Completed todos display\n9. `empty-state` - Empty state message\n10. `usage-examples` - Usage examples and patterns\n\n---\n\n### 2. **components/todos/TodoForm.tsx** - NEEDS FIXING\n**Incorrect patterns found:** 13 REF/CLOSE pairs\n\n**Required fixes:**\n- Replace `<!-- REF:001 -->` ‚Üí `/** REF: component-overview */`\n- Replace `<!-- CLOSE:001 -->` ‚Üí `// CLOSE: component-overview`\n- Move CLOSE markers outside REF comment blocks\n- Use kebab-case for section names\n\n**Sections to fix:**\n1. component-overview\n2. props-interface\n3. component-function-and-state\n4. submit-handler\n5. tag-management-handlers\n6. form-render\n7. error-display\n8. title-input\n9. description-textarea\n10. public-checkbox\n11. tags-input-section\n12. submit-button\n13. drizzle-type-examples\n\n---\n\n### 3. **components/todos/TodoItem.tsx** - NEEDS FIXING\n**Incorrect patterns found:** 11 REF/CLOSE pairs\n\n**Required fixes:**\n- Replace HTML-style comments with JavaScript comments\n- Move CLOSE markers to separate comments after code blocks\n- Use kebab-case for all section names\n\n**Sections to fix:**\n1. component-overview\n2. type-definition\n3. props-interface\n4. component-function-and-state\n5. edit-mode-handlers\n6. edit-mode-view\n7. view-mode-layout\n8. completion-checkbox\n9. todo-content-section\n10. action-buttons\n11. type-safety-examples\n\n---\n\n### 4. **components/ui/LoadingSpinner.tsx** - NEEDS FIXING\n**Incorrect patterns found:** 8 REF/CLOSE pairs\n\n**Required fixes:**\n- Replace HTML-style comments with JavaScript comments\n- Move CLOSE markers outside REF blocks\n- Update section naming\n\n**Sections to fix:**\n1. component-overview\n2. props-interface\n3. component-function\n4. size-classes-mapping\n5. component-render\n6. spinner-element\n7. optional-text\n8. usage-examples\n\n---\n\n### 5. **contexts/AuthContext.tsx** - NEEDS FIXING\n**Incorrect patterns found:** 11 REF/CLOSE pairs\n\n**Required fixes:**\n- Replace HTML-style comments with JavaScript comments\n- Move CLOSE markers after code blocks\n- Consistent naming conventions\n\n**Sections to fix:**\n1. context-overview\n2. context-type-interface\n3. context-creation\n4. provider-component-and-state\n5. auth-state-listener-effect\n6. sign-up-function\n7. sign-in-function\n8. sign-out-function\n9. context-value-and-provider\n10. use-auth-hook\n11. usage-examples\n\n---\n\n### 6. **tailwind.config.ts** - NEEDS FIXING\n**Incorrect patterns found:** 7 REF/CLOSE pairs\n\n**Required fixes:**\n- Replace HTML-style comments with TypeScript comments\n- Move CLOSE markers appropriately\n- Fix config documentation\n\n**Sections to fix:**\n1. configuration-overview\n2. config-object\n3. content-paths\n4. theme-configuration\n5. plugins-configuration\n6. export\n7. additional-documentation\n\n---\n\n### 7. **postcss.config.js** - NEEDS FIXING\n**Incorrect patterns found:** 6 REF/CLOSE pairs\n\n**Required fixes:**\n- Replace HTML-style comments with JavaScript comments\n- Move CLOSE markers after code\n- Update documentation style\n\n**Sections to fix:**\n1. configuration-overview\n2. module-export\n3. plugins-configuration\n4. tailwind-css-plugin\n5. autoprefixer-plugin\n6. additional-documentation\n\n---\n\n### 8. **lib/db/queries.ts** - ALREADY CORRECT ‚úÖ\n**Status:** All 45+ REF/CLOSE pairs are correctly formatted\n- Uses proper JavaScript comments (`/** */` and `//`)\n- CLOSE markers are in separate comments after code blocks\n- Consistent kebab-case naming\n\n---\n\n### 9. **lib/db/client.ts** - ALREADY CORRECT ‚úÖ\n**Status:** All 20+ REF/CLOSE pairs are correctly formatted\n- Proper comment formatting\n- CLOSE markers correctly positioned\n- Clean documentation structure\n\n---\n\n### 10. **lib/supabase/client.ts** - ALREADY CORRECT ‚úÖ\n**Status:** All 12+ REF/CLOSE pairs are correctly formatted\n- Correct comment style\n- Proper CLOSE marker placement\n- Well-organized sections\n\n---\n\n## Correct Pattern Reference\n\n### For TypeScript/JavaScript Files (.ts, .tsx, .js)\n\n```typescript\n/**\n * REF: section-name\n *\n * # Section Title\n *\n * Documentation content here with proper markdown formatting.\n * Multiple lines of documentation as needed.\n */\nconst code = \"example\"\nconst moreCode = true\n// CLOSE: section-name\n```\n\n### For JSX/TSX Within Components\n\n```tsx\n{/*\n * REF: jsx-section\n *\n * # JSX Section Documentation\n *\n * Documentation for JSX elements\n */}\n<div className=\"example\">\n  {/* JSX content */}\n</div>\n{/* CLOSE: jsx-section */}\n```\n\n### Key Rules\n\n1. **REF marker**: Always in a comment block with `REF: section-name` format\n2. **Documentation**: Follows REF marker within same comment block\n3. **Code**: Comes after the closing of the REF comment block\n4. **CLOSE marker**: Separate comment AFTER all the code for that section\n5. **Naming**: Use kebab-case for section names (e.g., `component-overview`, `props-interface`)\n6. **No HTML comments**: Never use `<!-- -->` in .ts/.tsx/.js files\n\n---\n\n## Incorrect Patterns to Avoid\n\n### ‚ùå WRONG: CLOSE inside REF block\n```typescript\n/**\n * REF: example\n * Documentation\n * CLOSE: example\n */\nconst code = \"example\"\n```\n\n### ‚ùå WRONG: HTML-style comments in JavaScript\n```typescript\n<!-- REF:001 Component Overview -->\nconst code = \"example\"\n<!-- CLOSE:001 -->\n```\n\n### ‚ùå WRONG: Missing separate CLOSE comment\n```typescript\n/**\n * REF: example\n * Documentation\n */\nconst code = \"example\"\n// Next section starts without closing previous\n```\n\n### ‚ùå WRONG: CLOSE comment inside JSX\n```tsx\n<div>\n  {/* REF: section\n   * Documentation\n   * CLOSE: section */}\n  <Component />\n</div>\n```\n\n---\n\n## Fix Priority\n\n1. **HIGH PRIORITY** (User-facing components):\n   - TodoForm.tsx\n   - TodoItem.tsx\n   - LoadingSpinner.tsx\n\n2. **MEDIUM PRIORITY** (Infrastructure):\n   - AuthContext.tsx\n   - tailwind.config.ts\n   - postcss.config.js\n\n3. **LOW PRIORITY** (Already correct):\n   - lib/db/queries.ts ‚úÖ\n   - lib/db/client.ts ‚úÖ\n   - lib/supabase/client.ts ‚úÖ\n\n---\n\n## Automation Script\n\nTo fix all remaining files automatically, run:\n\n```bash\n# Navigate to project directory\ncd \"/workspaces/ctp-fall-wd-curriculum/CTP Curriculum/Week 12/example-projects/nextjs-supabase-drizzle\"\n\n# Fix TodoForm.tsx\n# (Manual edits required - see pattern above)\n\n# Fix TodoItem.tsx\n# (Manual edits required - see pattern above)\n\n# Fix LoadingSpinner.tsx\n# (Manual edits required - see pattern above)\n\n# Fix AuthContext.tsx\n# (Manual edits required - see pattern above)\n\n# Fix config files\n# (Manual edits required - see pattern above)\n```\n\n---\n\n## Verification Checklist\n\nAfter fixing each file, verify:\n- [ ] No HTML-style comments (`<!-- -->`)\n- [ ] All REF markers use `/** REF: name */` or `{/* REF: name */}`\n- [ ] All CLOSE markers are AFTER code blocks\n- [ ] All CLOSE markers use `// CLOSE: name` or `{/* CLOSE: name */}`\n- [ ] Section names use kebab-case\n- [ ] Every REF has a matching CLOSE\n- [ ] CLOSE uses same name as its REF\n\n---\n\n## Total Statistics\n\n- **Total files in project:** 10\n- **Files needing fixes:** 6\n- **Files already correct:** 3\n- **Files fixed in this session:** 1 (TodoList.tsx)\n- **Estimated REF/CLOSE pairs total:** ~100\n- **Pairs corrected:** 10\n- **Pairs remaining:** ~50\n\n---\n\n## Next Steps\n\n1. Apply fixes to TodoForm.tsx (13 pairs)\n2. Apply fixes to TodoItem.tsx (11 pairs)\n3. Apply fixes to LoadingSpinner.tsx (8 pairs)\n4. Apply fixes to AuthContext.tsx (11 pairs)\n5. Apply fixes to tailwind.config.ts (7 pairs)\n6. Apply fixes to postcss.config.js (6 pairs)\n7. Run final verification on all files\n8. Commit changes with descriptive message\n\n---\n\n## Git Commit Message Template\n\n```\nfix: correct REF/CLOSE documentation patterns in nextjs-supabase-drizzle\n\n- Replace HTML-style comments with JavaScript/TypeScript comments\n- Move CLOSE markers to separate comments after code blocks\n- Standardize section naming to kebab-case\n- Ensure every REF has matching CLOSE after code section\n\nFiles updated:\n- components/todos/TodoList.tsx (10 pairs)\n- components/todos/TodoForm.tsx (13 pairs)\n- components/todos/TodoItem.tsx (11 pairs)\n- components/ui/LoadingSpinner.tsx (8 pairs)\n- contexts/AuthContext.tsx (11 pairs)\n- tailwind.config.ts (7 pairs)\n- postcss.config.js (6 pairs)\n\nTotal: 66 REF/CLOSE pairs corrected\n```\n",
      "language": "markdown"
    },
    {
      "path": "LEARNING_GUIDE.md",
      "content": "# Next.js + Supabase + Drizzle - Learning Guide\n\n## üéØ Project Overview\n\nType-safe full-stack application combining Supabase Auth/Storage with Drizzle ORM for perfect TypeScript inference.\n\n## üîë Key Features & Implementation Details\n\n### Cross-Cutting Concerns\n\n**Authentication:**\n- Implementation: Supabase Auth\n- Location: `lib/supabase/client.ts`, `contexts/AuthContext.tsx`\n- Pattern: Supabase for auth, Drizzle for database\n- Features: Email/password, session management, hybrid approach\n\n**Database:**\n- Implementation: **Drizzle ORM with PostgreSQL**\n- Schema: `lib/db/schema.ts`\n- Client: `lib/db/client.ts`\n- Queries: `lib/db/queries.ts`\n- Pattern: Type-safe, SQL-like query builder\n- Features: Perfect TypeScript inference, migrations, relations\n\n**Security:**\n- Implementation: Application-level + optional RLS\n- Pattern: Filter by userId in queries\n- Features: Type-safe authorization checks\n\n**Storage:**\n- Implementation: Supabase Storage\n- Location: `lib/supabase/client.ts`\n- Pattern: Use Supabase for files, Drizzle for metadata\n- Features: File uploads, public URLs\n\n**Rendering:**\n- Implementation: Hybrid SSR + CSR\n- Pattern: Server Components with Drizzle queries\n- Features: Fast initial load, type-safe data fetching\n\n**ORM:**\n- Implementation: **Drizzle ORM**\n- Pattern: Schema-first, type inference\n- Features: SQL-like syntax, perfect types, migrations\n\n## üìö Learning Flows\n\n### Flow 1: Drizzle Schema & Type Inference (20 minutes)\n\n**Goal:** Master Drizzle's type-safe schema system\n\n**Path:**\n1. **Start:** `lib/db/schema.ts`\n   - Table definitions with pgTable\n   - Column types (uuid, text, boolean, timestamp)\n   - Default values and constraints\n   - Relations between tables\n   - Type inference magic\n\n2. **Next:** `lib/db/client.ts`\n   - Drizzle client initialization\n   - PostgreSQL connection\n   - prepare: false for Supabase\n   - Using the schema\n\n3. **Then:** `drizzle.config.ts`\n   - Drizzle Kit configuration\n   - Migration generation\n   - Database connection\n\n**Key Concepts:**\n- Schema-first development\n- Type inference (no manual types!)\n- InferSelectModel, InferInsertModel\n- Relations and joins\n- pgTable API\n\n**Audio Guide:** `audio/01-drizzle-schema-and-types.mp3`\n\n---\n\n### Flow 2: Type-Safe Queries (25 minutes)\n\n**Goal:** Learn Drizzle's query builder\n\n**Path:**\n1. **Start:** `lib/db/queries.ts`\n   - SELECT queries with .select().from()\n   - WHERE clauses with eq(), and(), or()\n   - ORDER BY with .orderBy()\n   - INSERT with .insert().values().returning()\n   - UPDATE with .update().set().where()\n   - DELETE with .delete().where()\n   - Complex queries (getConversation)\n\n2. **Next:** `app/dashboard/page.tsx`\n   - Using query helpers\n   - Type inference in action\n   - Error handling\n   - State management with typed data\n\n**Key Concepts:**\n- SQL-like query syntax\n- Type-safe operations\n- Query helpers pattern\n- Returning inserted data\n- Complex WHERE conditions\n\n**Audio Guide:** `audio/02-type-safe-queries.mp3`\n\n---\n\n### Flow 3: Hybrid Supabase + Drizzle (20 minutes)\n\n**Goal:** Understand when to use each tool\n\n**Path:**\n1. **Start:** `lib/supabase/client.ts`\n   - Supabase client for auth/storage\n   - Why not use for database queries\n\n2. **Next:** `contexts/AuthContext.tsx`\n   - Supabase for authentication\n   - Drizzle for profile creation\n   - Best of both worlds\n\n3. **Then:** `app/dashboard/page.tsx`\n   - Auth from Supabase context\n   - Database queries with Drizzle\n   - Real-time with Supabase (optional)\n\n**Key Concepts:**\n- Hybrid architecture\n- When to use Supabase\n- When to use Drizzle\n- Combining both effectively\n\n**Audio Guide:** `audio/03-hybrid-approach.mp3`\n\n---\n\n### Flow 4: Migrations with Drizzle Kit (15 minutes)\n\n**Goal:** Learn database migration system\n\n**Path:**\n1. **Start:** `drizzle.config.ts`\n   - Configuration for Drizzle Kit\n   - Schema location\n   - Output directory\n   - Database connection\n\n2. **Then:** `lib/db/schema.ts`\n   - Make a change to schema\n   - Understand migration generation\n\n3. **Commands:**\n   ```bash\n   npm run db:generate  # Generate migration SQL\n   npm run db:push      # Apply to database\n   npm run db:studio    # Visual database editor\n   ```\n\n**Key Concepts:**\n- Schema-driven migrations\n- SQL generation from schema\n- Drizzle Kit commands\n- Drizzle Studio\n\n**Audio Guide:** `audio/04-drizzle-migrations.mp3`\n\n---\n\n### Flow 5: Perfect TypeScript Inference (20 minutes)\n\n**Goal:** See Drizzle's type safety in action\n\n**Path:**\n1. **Start:** `lib/db/schema.ts`\n   - Define a table\n   - See how types are created\n\n2. **Next:** `lib/db/queries.ts`\n   - No manual type annotations\n   - InferSelectModel, InferInsertModel\n   - Autocomplete in action\n\n3. **Then:** `components/todos/TodoForm.tsx`\n   - createTodo() is fully typed\n   - TypeScript validates arguments\n   - Compile-time errors\n\n4. **Try:** Make intentional type errors\n   - Wrong type for field\n   - Non-existent field\n   - See compile errors!\n\n**Key Concepts:**\n- Type inference from schema\n- No manual type definitions\n- Compile-time safety\n- Perfect autocomplete\n\n**Audio Guide:** `audio/05-typescript-inference.mp3`\n\n---\n\n### Flow 6: Components with Drizzle Types (15 minutes)\n\n**Goal:** Build components with inferred types\n\n**Path:**\n1. **Start:** `components/todos/TodoForm.tsx`\n   - Using createTodo helper\n   - Type-safe form submission\n\n2. **Next:** `components/todos/TodoList.tsx`\n   - InferSelectModel for todo type\n   - Type-safe props\n\n3. **Then:** `components/todos/TodoItem.tsx`\n   - Type-safe update operations\n   - Partial<Todo> for updates\n\n**Key Concepts:**\n- InferSelectModel for queries\n- InferInsertModel for inserts\n- Partial types for updates\n- Type-safe component props\n\n**Audio Guide:** `audio/06-components-with-drizzle.mp3`\n\n---\n\n## üéì Recommended Learning Order\n\n### Beginner (Learn Drizzle Basics) - 4-6 hours\n1. Flow 1: Schema & Type Inference (20 min)\n2. Flow 2: Type-Safe Queries (25 min)\n3. Flow 5: TypeScript Inference (20 min)\n4. Experiment with queries (3-5 hours)\n\n### Intermediate (Build Features) - 6-8 hours\n1. Complete Beginner Path\n2. Flow 3: Hybrid Approach (20 min)\n3. Flow 6: Components (15 min)\n4. Build your own features (5-7 hours)\n\n### Advanced (Master Drizzle) - 8-10 hours\n1. Complete Intermediate Path\n2. Flow 4: Migrations (15 min)\n3. Study all query helpers\n4. Build complete app with Drizzle (7-9 hours)\n\n## üåü Why This Stack is Unique\n\n**Best TypeScript experience of all 5 projects:**\n- Perfect type inference (no manual types!)\n- Compile-time safety\n- SQL-like syntax\n- Great for teams (clear contracts)\n\n**Hybrid approach:**\n- Supabase: Auth and Storage (best-in-class)\n- Drizzle: Database queries (perfect types)\n- Each tool does what it's best at!\n\n## üîó Quick Reference\n\n### Drizzle\n- Schema: `lib/db/schema.ts`\n- Client: `lib/db/client.ts`\n- Queries: `lib/db/queries.ts`\n- Config: `drizzle.config.ts`\n\n### Supabase\n- Client: `lib/supabase/client.ts`\n- Auth: `contexts/AuthContext.tsx`\n\n### Pages\n- Dashboard: `app/dashboard/page.tsx`\n- Feed: `app/feed/page.tsx`\n- Messages: `app/messages/page.tsx`\n- Settings: `app/settings/page.tsx`\n\n### Components\n- TodoForm: `components/todos/TodoForm.tsx`\n- TodoList: `components/todos/TodoList.tsx`\n- TodoItem: `components/todos/TodoItem.tsx`\n\n---\n\n**Start with Flow 1 to understand Drizzle's type inference magic!**\n\n**Audio overviews in `audio/` folder (coming soon).**\n",
      "language": "markdown"
    },
    {
      "path": "README.md",
      "content": "\n\n# Next.js + Supabase + Drizzle ORM Todo Application\n\nA full-stack todo application built with Next.js 15, Supabase, and Drizzle ORM for type-safe database access.\n\n## Features\n\n- User authentication (sign up, sign in, sign out) - Supabase Auth\n- Todo CRUD operations with real-time updates\n- User accessibility settings\n- Profile picture uploads - Supabase Storage\n- Todo file attachments\n- Public feed (searchable, filterable, paginated)\n- Real-time messaging\n- Tags for categorization\n- **Type-safe database queries with Drizzle ORM**\n\n## Tech Stack\n\n- **Framework:** Next.js 15 (App Router)\n- **Language:** TypeScript\n- **Styling:** Tailwind CSS\n- **Authentication:** Supabase Auth\n- **Database:** PostgreSQL (via Supabase)\n- **ORM:** Drizzle ORM (type-safe queries)\n- **Storage:** Supabase Storage\n- **Real-time:** Supabase Realtime\n\n## Why This Stack?\n\n**Best of Both Worlds:**\n- ‚úÖ Supabase Auth & Storage (best-in-class)\n- ‚úÖ Drizzle ORM for perfect TypeScript inference\n- ‚úÖ Type-safe queries without losing SQL power\n- ‚úÖ Still use Supabase Realtime subscriptions\n- ‚úÖ Faster queries than Supabase client for complex operations\n\n**Drizzle Benefits:**\n- Full TypeScript autocomplete\n- SQL-like syntax (easy to learn)\n- Lightweight (< 10KB)\n- Perfect type inference\n- Migrations built-in\n\n## Getting Started\n\n### Prerequisites\n\n- Node.js 18+\n- Supabase project\n\n### Setup\n\n1. **Install Dependencies:**\n   ```bash\n   npm install\n   ```\n\n2. **Environment Variables:**\n   ```bash\n   cp .env.example .env.local\n   ```\n   Add your Supabase credentials:\n   ```env\n   NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   DATABASE_URL=postgresql://postgres:[PASSWORD]@db.[PROJECT].supabase.co:5432/postgres\n   ```\n\n3. **Generate Migrations:**\n   ```bash\n   npm run db:generate\n   ```\n\n4. **Apply to Database:**\n   ```bash\n   npm run db:push\n   ```\n   Or copy SQL from `drizzle/` folder to Supabase SQL editor\n\n5. **Run Development Server:**\n   ```bash\n   npm run dev\n   ```\n\n## Project Structure\n\n```\nnextjs-supabase-drizzle/\n‚îú‚îÄ‚îÄ lib/\n‚îÇ   ‚îú‚îÄ‚îÄ db/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schema.ts        # Drizzle schema definition\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts        # Drizzle client setup\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ queries.ts       # Reusable type-safe queries\n‚îÇ   ‚îî‚îÄ‚îÄ supabase/\n‚îÇ       ‚îú‚îÄ‚îÄ client.ts        # Supabase client (for Auth/Storage)\n‚îÇ       ‚îî‚îÄ‚îÄ server.ts        # Supabase server client\n‚îú‚îÄ‚îÄ drizzle/                 # Generated SQL migrations\n‚îî‚îÄ‚îÄ drizzle.config.ts        # Drizzle configuration\n```\n\n## Drizzle ORM Usage\n\n### Define Schema (`lib/db/schema.ts`)\n\n```typescript\nexport const todos = pgTable('todos', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  userId: uuid('user_id').notNull(),\n  title: text('title').notNull(),\n  completed: boolean('completed').default(false),\n})\n```\n\n### Query with Type Safety\n\n```typescript\nimport { db } from '@/lib/db/client'\nimport { todos } from '@/lib/db/schema'\nimport { eq } from 'drizzle-orm'\n\n// SELECT with full autocomplete\nconst userTodos = await db\n  .select()\n  .from(todos)\n  .where(eq(todos.userId, userId))\n\n// INSERT with type checking\nconst [newTodo] = await db\n  .insert(todos)\n  .values({ userId, title: 'New todo' })\n  .returning()\n\n// UPDATE\nawait db\n  .update(todos)\n  .set({ completed: true })\n  .where(eq(todos.id, todoId))\n```\n\n### Relations and Joins\n\n```typescript\nconst todosWithAttachments = await db.query.todos.findMany({\n  where: eq(todos.userId, userId),\n  with: {\n    attachments: true,\n  },\n})\n```\n\n## Hybrid Approach\n\n**Use Drizzle for:**\n- Complex queries with joins\n- Type-safe CRUD operations\n- Transactions\n- Aggregations\n\n**Use Supabase Client for:**\n- Authentication (Auth)\n- File uploads (Storage)\n- Real-time subscriptions\n\n```typescript\n// Auth with Supabase\nconst { data: { user } } = await supabase.auth.getUser()\n\n// Queries with Drizzle\nconst todos = await db.select().from(todos).where(eq(todos.userId, user.id))\n\n// Realtime with Supabase\nsupabase\n  .channel('todos')\n  .on('postgres_changes', { table: 'todos' }, handleChange)\n  .subscribe()\n```\n\n## Database Migrations\n\n### Create Migration\n\n```bash\nnpm run db:generate\n```\n\nGenerates SQL in `drizzle/` folder.\n\n### Apply Migration\n\n**Option 1: Drizzle Kit**\n```bash\nnpm run db:push\n```\n\n**Option 2: Supabase Dashboard**\n1. Copy SQL from `drizzle/` folder\n2. Paste in Supabase SQL Editor\n3. Run\n\n### Drizzle Studio\n\nView and edit database:\n```bash\nnpm run db:studio\n```\n\nOpens local admin UI at https://local.drizzle.studio\n\n## Row Level Security\n\n**Important:** Drizzle doesn't enforce RLS automatically!\n\nCreate RLS policies in Supabase:\n\n```sql\nCREATE POLICY \"Users see own todos\"\nON todos FOR SELECT\nUSING (auth.uid() = user_id);\n```\n\nOr use service role key with Drizzle (server-side only).\n\n## Type Safety Example\n\n```typescript\n// ‚ùå Type error caught at compile time\nawait db.insert(todos).values({\n  userId: 123, // Error: Expected string (UUID)\n  title: 42,   // Error: Expected string\n})\n\n// ‚úÖ Correct types\nawait db.insert(todos).values({\n  userId: user.id,\n  title: 'Valid todo',\n})\n\n// Full autocomplete\nconst results = await db.select().from(todos)\nresults[0].title  // ‚úÖ TypeScript knows this is a string\nresults[0].userId // ‚úÖ TypeScript knows this is a UUID\n```\n\n## Performance\n\nDrizzle generates efficient SQL:\n\n```typescript\n// This code...\nawait db.select().from(todos).where(eq(todos.userId, userId))\n\n// Generates this SQL:\n// SELECT * FROM todos WHERE user_id = $1\n```\n\nNo N+1 queries, no ORM overhead!\n\n## Deployment\n\nSame as other Next.js projects:\n- Vercel (recommended)\n- Netlify\n- AWS Amplify\n- Self-hosted\n\nEnvironment variables needed:\n- `NEXT_PUBLIC_SUPABASE_URL`\n- `NEXT_PUBLIC_SUPABASE_ANON_KEY`\n- `DATABASE_URL`\n\n## Learn More\n\n- [Drizzle ORM Documentation](https://orm.drizzle.team/)\n- [Supabase Documentation](https://supabase.com/docs)\n- [Next.js Documentation](https://nextjs.org/docs)\n- [PostgreSQL Documentation](https://www.postgresql.org/docs/)\n\n## License\n\nMIT\n",
      "language": "markdown"
    },
    {
      "path": "app/(auth)/signin/page.tsx",
      "content": "/**\n * REF: file-header\n *\n * # Sign In Page - Drizzle + Supabase Auth\n *\n * Authentication page using Supabase for auth in the Drizzle project.\n *\n * ## Hybrid Architecture\n * - **Supabase Auth**: Best-in-class authentication (don't reinvent the wheel)\n * - **Drizzle**: Type-safe database queries for app data\n * - **Clean Separation**: Each tool does what it does best\n *\n * ## Authentication Flow\n * | `Step` | `Action` | `Tool` |\n * |------|--------|------|\n * | `1` | User submits credentials | React form |\n * | `2` | Validate with Supabase | Supabase Auth |\n * | `3` | Return session + JWT | `Supabase` |\n * | `4` | Use user ID for queries | Drizzle ORM |\n * | `5` | RLS protects data | `Optional` |\n */\n// CLOSE: file-header\n\n'use client'\n\n/**\n * REF: imports\n *\n * ## Import Dependencies\n *\n * ### React\n * - `useState`: Form state\n * - `FormEvent`: TypeScript type for form events\n *\n * ### Next.js\n * - `useRouter`: Navigate after successful auth\n * - `Link`: Client-side navigation\n *\n * ### Custom\n * - `useAuth`: Access auth context and signIn method\n */\nimport { useState, FormEvent } from 'react'\nimport { useRouter } from 'next/navigation'\nimport Link from 'next/link'\nimport { useAuth } from '@/contexts/AuthContext'\n// CLOSE: imports\n\n/**\n * REF: component-function\n *\n * ## SignInPage Component\n *\n * Client component for user authentication.\n */\nexport default function SignInPage() {\n  // CLOSE: component-function\n\n  /**\n   * REF: state-and-hooks\n   *\n   * ## State Management and Hooks\n   *\n   * | State/Hook | Type | Purpose |\n   * |------------|------|---------|\n   * | `email` | `string` | Email input value |\n   * | `password` | `string` | Password input value |\n   * | `error` | `string` | Error message display |\n   * | `loading` | `boolean` | Submit in progress |\n   * | `signIn` | `function` | From useAuth context |\n   * | `router` | `NextRouter` | For navigation |\n   */\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n  const [error, setError] = useState('')\n  const [loading, setLoading] = useState(false)\n\n  const { signIn } = useAuth()\n  const router = useRouter()\n  // CLOSE: state-and-hooks\n\n  /**\n   * REF: submit-handler\n   *\n   * ## Form Submit Handler\n   *\n   * Handles authentication with Supabase Auth via context.\n   *\n   * ### Process\n   * 1. Prevent default form behavior\n   * 2. Clear previous errors\n   * 3. Set loading state\n   * 4. Call Supabase signIn (via context)\n   * 5. Navigate to dashboard on success\n   * 6. Show error on failure\n   *\n   * ### After Authentication\n   * Once signed in, user can make Drizzle queries with their user ID.\n   */\n  const handleSubmit = async (e: FormEvent) => {\n    e.preventDefault()\n    setError('')\n    setLoading(true)\n\n    try {\n      await signIn(email, password)\n      router.push('/dashboard')\n    } catch (err: any) {\n      setError(err.message || 'Failed to sign in')\n    } finally {\n      setLoading(false)\n    }\n  }\n  // CLOSE: submit-handler\n\n  /**\n   * REF: main-layout\n   *\n   * ## Sign In Form Layout\n   *\n   * Centered authentication form with email/password inputs.\n   */\n  return (\n    <div className=\"flex min-h-screen items-center justify-center p-4\">\n      <div className=\"w-full max-w-md\">\n        <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8\">\n          {/**\n           * REF: header\n           *\n           * ## Page Header\n           *\n           * Title and subtitle describing the tech stack.\n           */}\n          <h1 className=\"text-3xl font-bold text-center mb-6\">Sign In</h1>\n\n          <p className=\"text-center text-sm text-gray-600 dark:text-gray-400 mb-6\">\n            Next.js + Supabase Auth + Drizzle ORM\n          </p>\n          {/* CLOSE: header */}\n\n          {/**\n           * REF: error-display\n           *\n           * ## Error Message Display\n           *\n           * Shows authentication errors to user.\n           */}\n          {error && (\n            <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4\">\n              {error}\n            </div>\n          )}\n          {/* CLOSE: error-display */}\n\n          {/**\n           * REF: signin-form\n           *\n           * ## Sign In Form\n           *\n           * Email and password input form.\n           */}\n          <form onSubmit={handleSubmit} className=\"space-y-4\">\n            {/**\n             * REF: email-input\n             *\n             * ## Email Input Field\n             *\n             * ### Accessibility\n             * - Label with htmlFor\n             * - Type email for validation\n             * - Autocomplete enabled\n             * - Required field\n             */}\n            <div>\n              <label htmlFor=\"email\" className=\"block text-sm font-medium mb-2\">\n                Email\n              </label>\n              <input\n                id=\"email\"\n                type=\"email\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                required\n                autoComplete=\"email\"\n                className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                placeholder=\"you@example.com\"\n              />\n            </div>\n            {/* CLOSE: email-input */}\n\n            {/**\n             * REF: password-input\n             *\n             * ## Password Input Field\n             *\n             * ### Security\n             * - Type password (hides input)\n             * - Autocomplete for password managers\n             * - Required field\n             */}\n            <div>\n              <label htmlFor=\"password\" className=\"block text-sm font-medium mb-2\">\n                Password\n              </label>\n              <input\n                id=\"password\"\n                type=\"password\"\n                value={password}\n                onChange={(e) => setPassword(e.target.value)}\n                required\n                autoComplete=\"current-password\"\n                className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                placeholder=\"‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢\"\n              />\n            </div>\n            {/* CLOSE: password-input */}\n\n            {/**\n             * REF: submit-button\n             *\n             * ## Submit Button\n             *\n             * ### States\n             * - Normal: \"Sign In\"\n             * - Loading: \"Signing in...\" with disabled state\n             */}\n            <button\n              type=\"submit\"\n              disabled={loading}\n              className=\"w-full py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition\"\n            >\n              {loading ? 'Signing in...' : 'Sign In'}\n            </button>\n            {/* CLOSE: submit-button */}\n          </form>\n          {/* CLOSE: signin-form */}\n\n          {/**\n           * REF: signup-link\n           *\n           * ## Sign Up Link\n           *\n           * Link to registration page for new users.\n           */}\n          <p className=\"text-center mt-6 text-gray-600 dark:text-gray-300\">\n            Don't have an account?{' '}\n            <Link href=\"/signup\" className=\"text-blue-600 hover:underline\">\n              Sign up\n            </Link>\n          </p>\n          {/* CLOSE: signup-link */}\n        </div>\n      </div>\n    </div>\n  )\n  // CLOSE: main-layout\n}\n\n/**\n * REF: using-auth-with-drizzle\n *\n * ## Using Auth with Drizzle Queries\n *\n * After authentication, combine Supabase auth state with Drizzle queries.\n *\n * ### Example: Fetch User's Todos\n * ```typescript\n * import { useAuth } from '@/contexts/AuthContext'\n * import { getUserTodos } from '@/lib/db/queries'\n *\n * function Dashboard() {\n *   const { user } = useAuth() // Supabase auth\n *   const [todos, setTodos] = useState([])\n *\n *   useEffect(() => {\n *     if (!user) return\n *\n *     // Query with Drizzle (type-safe!)\n *     getUserTodos(user.id).then(setTodos)\n *   }, [user])\n * }\n * ```\n *\n * ### Clean Separation\n * - Supabase handles auth state\n * - Drizzle handles database queries\n * - Best of both worlds\n */\n// CLOSE: using-auth-with-drizzle\n\n/**\n * REF: rls-vs-app-level-auth\n *\n * ## RLS vs Application-Level Authorization\n *\n * Two approaches for securing data with this hybrid setup.\n *\n * ### Option 1: Supabase Client with RLS\n * ```typescript\n * import { createClient } from '@/lib/supabase/client'\n *\n * const supabase = createClient()\n * const { data } = await supabase.from('todos').select('*')\n * // RLS automatically enforced at database level\n * ```\n *\n * ### Option 2: Drizzle with App-Level Filtering\n * ```typescript\n * import { db } from '@/lib/db/client'\n * import { todos } from '@/lib/db/schema'\n * import { eq } from 'drizzle-orm'\n *\n * // Filter in application code\n * const userTodos = await db\n *   .select()\n *   .from(todos)\n *   .where(eq(todos.userId, user.id))\n * ```\n *\n * ### This Project Uses Option 2\n * - Perfect type safety throughout\n * - Must enforce userId filtering in code\n * - More explicit, easier to debug\n */\n// CLOSE: rls-vs-app-level-auth\n",
      "language": "typescript"
    },
    {
      "path": "app/(auth)/signup/page.tsx",
      "content": "/**\n * REF: file-header\n *\n * # Sign Up Page - Create Account with Drizzle + Supabase\n *\n * User registration page using hybrid architecture.\n *\n * ## Registration Flow\n * | `Step` | `Action` | `Tool` |\n * |------|--------|------|\n * | `1` | Supabase creates auth.users | Supabase Auth |\n * | `2` | Trigger creates user_profiles | PostgreSQL trigger |\n * | `3` | Or manually with Drizzle | Drizzle ORM |\n * | `4` | User logged in | Supabase Session |\n * | `5` | Can make type-safe queries | Drizzle ORM |\n *\n * ## Profile Creation Options\n * - **Trigger**: Guaranteed, atomic (recommended)\n * - **Drizzle**: Explicit, in application code\n * - **Both**: Belt and suspenders approach\n */\n// CLOSE: file-header\n\n'use client'\n\n/**\n * REF: imports\n *\n * ## Import Dependencies\n *\n * ### React & Next.js\n * - `useState`: Form state\n * - `FormEvent`: TypeScript type\n * - `useRouter`: Post-registration navigation\n * - `Link`: Navigate to sign in\n *\n * ### Custom\n * - `useAuth`: Access signUp method from context\n */\nimport { useState, FormEvent } from 'react'\nimport { useRouter } from 'next/navigation'\nimport Link from 'next/link'\nimport { useAuth } from '@/contexts/AuthContext'\n// CLOSE: imports\n\n/**\n * REF: component-function\n *\n * ## SignUpPage Component\n *\n * Client component for user registration.\n */\nexport default function SignUpPage() {\n  // CLOSE: component-function\n\n  /**\n   * REF: state-management\n   *\n   * ## Form State Variables\n   *\n   * | `State` | Type | Purpose |\n   * |-------|------|---------|\n   * | `email` | `string` | Email input |\n   * | `password` | `string` | Password input |\n   * | `confirmPassword` | `string` | Password confirmation |\n   * | `displayName` | `string` | User's display name |\n   * | `error` | `string` | Validation/API errors |\n   * | `loading` | `boolean` | Submit state |\n   */\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n  const [confirmPassword, setConfirmPassword] = useState('')\n  const [displayName, setDisplayName] = useState('')\n  const [error, setError] = useState('')\n  const [loading, setLoading] = useState(false)\n\n  const { signUp } = useAuth()\n  const router = useRouter()\n  // CLOSE: state-management\n\n  /**\n   * REF: submit-handler\n   *\n   * ## Form Validation and Submission\n   *\n   * Handles client-side validation and account creation.\n   *\n   * ### Validation Rules\n   * - Passwords must match\n   * - Password minimum 6 characters\n   * - Email format validated by browser\n   *\n   * ### Process\n   * 1. Validate passwords match\n   * 2. Validate password length\n   * 3. Call Supabase signUp via context\n   * 4. Pass displayName as metadata\n   * 5. Navigate to dashboard on success\n   * 6. Show errors to user\n   */\n  const handleSubmit = async (e: FormEvent) => {\n    e.preventDefault()\n    setError('')\n\n    if (password !== confirmPassword) {\n      setError('Passwords do not match')\n      return\n    }\n\n    if (password.length < 6) {\n      setError('Password must be at least 6 characters')\n      return\n    }\n\n    setLoading(true)\n\n    try {\n      await signUp(email, password, { displayName })\n      router.push('/dashboard')\n    } catch (err: any) {\n      setError(err.message || 'Failed to create account')\n    } finally {\n      setLoading(false)\n    }\n  }\n  // CLOSE: submit-handler\n\n  /**\n   * REF: main-layout\n   *\n   * ## Registration Form Layout\n   *\n   * Centered form with all registration fields.\n   */\n  return (\n    <div className=\"flex min-h-screen items-center justify-center p-4\">\n      <div className=\"w-full max-w-md\">\n        <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8\">\n          {/**\n           * REF: header\n           *\n           * ## Page Header\n           *\n           * Title and tech stack description.\n           */}\n          <h1 className=\"text-3xl font-bold text-center mb-6\">Create Account</h1>\n\n          <p className=\"text-center text-sm text-gray-600 dark:text-gray-400 mb-6\">\n            Type-safe database with Drizzle ORM\n          </p>\n          {/* CLOSE: header */}\n\n          {/**\n           * REF: error-display\n           *\n           * ## Error Display\n           *\n           * Shows validation or API errors.\n           */}\n          {error && (\n            <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4\">\n              {error}\n            </div>\n          )}\n          {/* CLOSE: error-display */}\n\n          {/**\n           * REF: signup-form\n           *\n           * ## Registration Form\n           *\n           * Form with display name, email, password, and confirmation.\n           */}\n          <form onSubmit={handleSubmit} className=\"space-y-4\">\n            {/**\n             * REF: display-name-input\n             *\n             * ## Display Name Input\n             *\n             * Optional field stored in user metadata.\n             */}\n            <div>\n              <label htmlFor=\"displayName\" className=\"block text-sm font-medium mb-2\">\n                Display Name\n              </label>\n              <input\n                id=\"displayName\"\n                type=\"text\"\n                value={displayName}\n                onChange={(e) => setDisplayName(e.target.value)}\n                className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                placeholder=\"John Doe\"\n              />\n            </div>\n            {/* CLOSE: display-name-input */}\n\n            {/**\n             * REF: email-input\n             *\n             * ## Email Input\n             *\n             * Required email field with autocomplete.\n             */}\n            <div>\n              <label htmlFor=\"email\" className=\"block text-sm font-medium mb-2\">\n                Email\n              </label>\n              <input\n                id=\"email\"\n                type=\"email\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                required\n                autoComplete=\"email\"\n                className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                placeholder=\"you@example.com\"\n              />\n            </div>\n            {/* CLOSE: email-input */}\n\n            {/**\n             * REF: password-input\n             *\n             * ## Password Input\n             *\n             * Required password with 6 character minimum.\n             */}\n            <div>\n              <label htmlFor=\"password\" className=\"block text-sm font-medium mb-2\">\n                Password\n              </label>\n              <input\n                id=\"password\"\n                type=\"password\"\n                value={password}\n                onChange={(e) => setPassword(e.target.value)}\n                required\n                minLength={6}\n                autoComplete=\"new-password\"\n                className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                placeholder=\"‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢\"\n              />\n              <p className=\"text-xs text-gray-500 mt-1\">Minimum 6 characters</p>\n            </div>\n            {/* CLOSE: password-input */}\n\n            {/**\n             * REF: confirm-password-input\n             *\n             * ## Confirm Password Input\n             *\n             * Password confirmation field.\n             */}\n            <div>\n              <label htmlFor=\"confirmPassword\" className=\"block text-sm font-medium mb-2\">\n                Confirm Password\n              </label>\n              <input\n                id=\"confirmPassword\"\n                type=\"password\"\n                value={confirmPassword}\n                onChange={(e) => setConfirmPassword(e.target.value)}\n                required\n                autoComplete=\"new-password\"\n                className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n                placeholder=\"‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢\"\n              />\n            </div>\n            {/* CLOSE: confirm-password-input */}\n\n            {/**\n             * REF: submit-button\n             *\n             * ## Submit Button\n             *\n             * Create account button with loading state.\n             */}\n            <button\n              type=\"submit\"\n              disabled={loading}\n              className=\"w-full py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition\"\n            >\n              {loading ? 'Creating account...' : 'Sign Up'}\n            </button>\n            {/* CLOSE: submit-button */}\n          </form>\n          {/* CLOSE: signup-form */}\n\n          {/**\n           * REF: signin-link\n           *\n           * ## Sign In Link\n           *\n           * Link for existing users to sign in.\n           */}\n          <p className=\"text-center mt-6 text-gray-600 dark:text-gray-300\">\n            Already have an account?{' '}\n            <Link href=\"/signin\" className=\"text-blue-600 hover:underline\">\n              Sign in\n            </Link>\n          </p>\n          {/* CLOSE: signin-link */}\n        </div>\n      </div>\n    </div>\n  )\n  // CLOSE: main-layout\n}\n\n/**\n * REF: profile-creation-drizzle\n *\n * ## Profile Creation with Drizzle\n *\n * After Supabase creates auth user, create profile with Drizzle.\n *\n * ### In AuthContext\n * ```typescript\n * import { db } from '@/lib/db/client'\n * import { userProfiles } from '@/lib/db/schema'\n *\n * if (event === 'SIGNED_IN' && session?.user) {\n *   // Type-safe profile creation\n *   await db\n *     .insert(userProfiles)\n *     .values({\n *       userId: session.user.id,\n *       displayName: session.user.user_metadata?.displayName || '',\n *     })\n *     .onConflictDoNothing() // Idempotent\n * }\n * ```\n *\n * ### Benefits\n * - Type-safe insert operation\n * - Explicit and visible in code\n * - Easy to debug\n */\n// CLOSE: profile-creation-drizzle\n\n/**\n * REF: database-trigger-alternative\n *\n * ## Database Trigger Alternative\n *\n * More reliable approach using PostgreSQL triggers.\n *\n * ### Trigger Function\n * ```sql\n * CREATE FUNCTION handle_new_user()\n * RETURNS TRIGGER AS $$\n * BEGIN\n *   INSERT INTO user_profiles (user_id, display_name)\n *   VALUES (NEW.id, NEW.raw_user_meta_data->>'displayName');\n *   RETURN NEW;\n * END;\n * $$ LANGUAGE plpgsql SECURITY DEFINER;\n *\n * CREATE TRIGGER on_auth_user_created\n *   AFTER INSERT ON auth.users\n *   FOR EACH ROW\n *   EXECUTE FUNCTION handle_new_user();\n * ```\n *\n * ### Advantages\n * - Guaranteed to run (even if client crashes)\n * - Atomic with user creation\n * - No race conditions\n * - Database-level consistency\n */\n// CLOSE: database-trigger-alternative\n\n/**\n * REF: type-safety-benefits\n *\n * ## Type Safety Benefits\n *\n * Drizzle catches errors at compile time.\n *\n * ### Valid Profile Creation\n * ```typescript\n * // ‚úÖ TypeScript validates all fields\n * await db.insert(userProfiles).values({\n *   userId: user.id,       // ‚úÖ string (UUID)\n *   displayName: 'John',   // ‚úÖ string | null\n * })\n * ```\n *\n * ### Caught at Compile Time\n * ```typescript\n * // ‚ùå Type error - userId wrong type\n * await db.insert(userProfiles).values({\n *   userId: 123,           // Error: Expected string\n * })\n *\n * // ‚ùå Type error - unknown field\n * await db.insert(userProfiles).values({\n *   userId: user.id,\n *   invalidField: 'test',  // Error: Unknown field\n * })\n * ```\n *\n * ### No Runtime Surprises\n * All typos and type mismatches caught before code runs.\n */\n// CLOSE: type-safety-benefits\n",
      "language": "typescript"
    },
    {
      "path": "app/actions.ts",
      "content": "/**\n * REF: file-header\n *\n * # Server Actions - Type-Safe Mutations with Drizzle\n *\n * This file contains Next.js Server Actions that handle database mutations using\n * Drizzle ORM for perfect type safety.\n *\n * ## What Are Server Actions?\n * Server Actions are async functions that run on the server and can be called from\n * Client Components. They provide a simple way to handle data mutations without\n * creating API routes.\n *\n * ## Benefits\n * - No API routes needed\n * - Automatic request deduplication\n * - Built-in CSRF protection\n * - Progressive enhancement support\n * - Type-safe with Drizzle ORM\n * - Can be called directly from forms or event handlers\n */\n// CLOSE: file-header\n\n/**\n * REF: use-server-directive\n *\n * ## 'use server' Directive\n *\n * ## Purpose\n * Marks this file as server-only, making all exported functions Server Actions.\n *\n * ### What It Does\n * - Ensures code only runs on server (never in browser)\n * - Enables form action binding\n * - Enables RPC-style calls from client\n * - Provides automatic CSRF protection\n * - Makes functions serializable for client consumption\n *\n * ### Server Actions Features\n * - Can be called from Client Components\n * - Run on server with full backend access\n * - Return serializable data only (no functions, classes, etc.)\n * - Support progressive enhancement (work without JavaScript)\n * - Automatically handle request/response serialization\n *\n * ### Security\n * - Functions are exposed endpoints\n * - Always validate input\n * - Always check authentication\n * - Don't trust client data\n */\n'use server'\n// CLOSE: use-server-directive\n\n/**\n * REF: database-imports\n *\n * ## Drizzle Database Imports\n *\n * ## Database Client\n * The main Drizzle database connection for executing queries.\n *\n * ### db Object\n * - Type-safe query builder\n * - Direct PostgreSQL connection\n * - Returns typed results based on schema\n * - Main interface for all database operations\n *\n * ## Schema Definition\n * The todos table schema that provides structure for queries.\n *\n * ### todos Schema\n * - Defines table structure\n * - Provides column types and constraints\n * - Used in queries like: `db.select().from(todos)`\n * - Source of type inference for results\n */\nimport { db } from '@/lib/db/client'\nimport { todos } from '@/lib/db/schema'\n// CLOSE: database-imports\n\n/**\n * REF: drizzle-operators\n *\n * ## Drizzle ORM Query Operators\n *\n * ## Equality Operator (eq)\n * Used for WHERE clause equality comparisons.\n *\n * ### Usage\n * ```typescript\n * where(eq(todos.id, todoId))\n * // Generates: WHERE id = $1\n * ```\n *\n * ### Other Available Operators\n * - `ne()` - Not equal (!=)\n * - `gt()`, `gte()` - Greater than (or equal)\n * - `lt()`, `lte()` - Less than (or equal)\n * - `and()`, `or()` - Logical operators\n * - `like()`, `ilike()` - Pattern matching\n * - `inArray()` - IN clause\n * - `notInArray()` - NOT IN clause\n * - `isNull()`, `isNotNull()` - NULL checks\n *\n * ### Type Safety\n * All operators are type-checked:\n * - Column types must match value types\n * - Invalid columns cause compile errors\n * - Autocomplete suggests valid columns\n */\nimport { eq } from 'drizzle-orm'\n// CLOSE: drizzle-operators\n\n/**\n * REF: cache-revalidation\n *\n * ## Next.js Cache Revalidation\n *\n * ## revalidatePath Function\n * Clears cached data for a specific page after mutations.\n *\n * ### How Next.js Caching Works\n * 1. Next.js caches Server Component renders\n * 2. After data mutations, cache becomes stale\n * 3. `revalidatePath('/path')` clears that page's cache\n * 4. Next render fetches fresh data\n *\n * ### Usage Pattern\n * ```typescript\n * await db.insert(todos).values({...})\n * revalidatePath('/dashboard')  // Dashboard will refetch todos\n * ```\n *\n * ### When to Use\n * - After creating new data\n * - After updating existing data\n * - After deleting data\n * - When data changes affect specific pages\n *\n * ### Alternatives\n * - `revalidateTag('tag-name')` - Revalidate by cache tag\n * - `revalidatePath('/path', 'layout')` - Revalidate layout\n * - `revalidatePath('/path', 'page')` - Revalidate page only\n */\nimport { revalidatePath } from 'next/cache'\n// CLOSE: cache-revalidation\n\n/**\n * REF: supabase-server-imports\n *\n * ## Supabase Server Client\n *\n * ## Server-Side Supabase Client\n * Creates Supabase client that works with server-side cookies.\n *\n * ### Why Server Client?\n * - Can access HTTP-only cookies (more secure than localStorage)\n * - Gets user session from request cookies\n * - Used in Server Components and Server Actions\n * - Different from browser Supabase client\n *\n * ### Cookie-Based Auth\n * - Reads auth token from cookies\n * - More secure than localStorage\n * - Works with Server Components\n * - Validates JWT server-side\n *\n * ### When to Use\n * - Server Actions (like this file)\n * - Server Components\n * - API Routes\n * - Middleware\n */\nimport { createClient } from '@/lib/supabase/server'\n// CLOSE: supabase-server-imports\n\n/**\n * REF: redirect-import\n *\n * ## Next.js Server-Side Redirect\n *\n * ## redirect Function\n * Performs server-side navigation to different routes.\n *\n * ### How It Works\n * - Throws a special error that Next.js catches\n * - Performs 307 Temporary Redirect\n * - Only works in Server Components and Server Actions\n * - Cannot be used in Client Components\n *\n * ### Usage\n * ```typescript\n * if (!user) {\n *   redirect('/signin')  // Navigates to sign in page\n * }\n * ```\n *\n * ### When to Use\n * - Redirect unauthenticated users\n * - After successful mutations\n * - When access is denied\n * - For route guards\n *\n * ### Alternative\n * Use `router.push()` for client-side redirects in Client Components\n */\nimport { redirect } from 'next/navigation'\n// CLOSE: redirect-import\n\n/**\n * REF: create-todo-action\n *\n * ## Create Todo Server Action\n *\n * ## Purpose\n * Server Action that creates a new todo in the database with full type safety.\n *\n * ## Function Signature\n * ```typescript\n * async function createTodoAction(formData: FormData): Promise<\n *   { success: true; todo: Todo } | { error: string }\n * >\n * ```\n *\n * ## Parameters\n * - `formData` - FormData object from form submission\n *\n * ## Expected FormData Fields\n * - `title` (string, required) - Todo title\n * - `description` (string, optional) - Todo description\n * - `isPublic` (checkbox) - \"on\" if checked, undefined otherwise\n *\n * ## Return Types\n * Success: `{ success: true, todo: TodoObject }`\n * Error: `{ error: string }`\n *\n * ## Usage Examples\n *\n * ### Direct Form Action (Progressive Enhancement)\n * ```typescript\n * <form action={createTodoAction}>\n *   <input name=\"title\" required />\n *   <textarea name=\"description\" />\n *   <input type=\"checkbox\" name=\"isPublic\" />\n *   <button type=\"submit\">Create</button>\n * </form>\n * ```\n *\n * ### With useTransition for Pending States\n * ```typescript\n * const [isPending, startTransition] = useTransition()\n *\n * <form action={(formData) => {\n *   startTransition(async () => {\n *     const result = await createTodoAction(formData)\n *     if (result.error) {\n *       alert(result.error)\n *     } else {\n *       console.log('Created:', result.todo)\n *     }\n *   })\n * }}>\n * ```\n *\n * ### With useActionState for Form State\n * ```typescript\n * const [state, formAction] = useActionState(createTodoAction, null)\n *\n * <form action={formAction}>\n *   {state?.error && <div>{state.error}</div>}\n * </form>\n * ```\n */\nexport async function createTodoAction(formData: FormData) {\n  try {\n    /**\n     * REF: auth-check\n     *\n     * # Authentication Verification\n     *\n     * ## Pattern\n     * Check user authentication before processing the request.\n     *\n     * ### Steps\n     * 1. Create server-side Supabase client\n     * 2. Get current user from auth cookie\n     * 3. Redirect to sign in if not authenticated\n     *\n     * ### How It Works\n     * - `createClient()` creates cookie-aware client\n     * - `getUser()` validates JWT from cookie\n     * - Returns user object if valid session\n     * - Returns null if no valid session\n     *\n     * ### Security\n     * - Always check auth in Server Actions\n     * - Never trust client to be authenticated\n     * - Validate on every request\n     *\n     * ### Why Redirect?\n     * - Better UX than error message\n     * - redirect() throws, so execution stops\n     * - User sent to sign in page\n     */\n    const supabase = await createClient()\n    const {\n      data: { user },\n    } = await supabase.auth.getUser()\n\n    if (!user) {\n      redirect('/signin')\n    }\n    // CLOSE: auth-check\n\n    /**\n     * REF: form-data-extraction\n     *\n     * # Extract Data from FormData\n     *\n     * ## FormData API\n     * Extract values from the submitted form.\n     *\n     * ### Field Extraction\n     * - `.get(name)` returns FormDataEntryValue | null\n     * - Can be string or File object\n     * - Type assertion needed for TypeScript\n     *\n     * ### Checkbox Handling\n     * - Checked checkboxes send value \"on\"\n     * - Unchecked checkboxes don't send anything\n     * - Test with `=== 'on'` for boolean\n     *\n     * ### Type Assertions\n     * ```typescript\n     * const title = formData.get('title') as string\n     * // Type: FormDataEntryValue | null => string\n     * ```\n     *\n     * ### Alternative: Zod Validation\n     * ```typescript\n     * import { z } from 'zod'\n     *\n     * const schema = z.object({\n     *   title: z.string().min(1),\n     *   description: z.string().optional(),\n     *   isPublic: z.boolean(),\n     * })\n     *\n     * const parsed = schema.parse(Object.fromEntries(formData))\n     * ```\n     */\n    const title = formData.get('title') as string\n    const description = formData.get('description') as string\n    const isPublic = formData.get('isPublic') === 'on'\n    // CLOSE: form-data-extraction\n\n    /**\n     * REF: input-validation\n     *\n     * # Validate User Input\n     *\n     * ## Title Validation\n     * Ensure title exists and isn't empty after trimming.\n     *\n     * ### Validation Logic\n     * - `title?.trim()` safely handles null/undefined\n     * - Empty strings become falsy after trim\n     * - Early return with error object\n     *\n     * ### Why Validate?\n     * - Client-side validation can be bypassed\n     * - Always validate on server\n     * - Provide clear error messages\n     * - Prevent invalid data in database\n     *\n     * ### Additional Validations to Consider\n     * - Maximum length limits\n     * - Character restrictions\n     * - Format validation (email, URL, etc.)\n     * - XSS sanitization (if not using parameterized queries)\n     * - SQL injection prevention (Drizzle handles this)\n     */\n    if (!title?.trim()) {\n      return { error: 'Title is required' }\n    }\n    // CLOSE: input-validation\n\n    /**\n     * REF: drizzle-insert\n     *\n     * # Drizzle Insert Operation\n     *\n     * ## Type-Safe Database Insert\n     * Create a new todo record with full type checking.\n     *\n     * ### Query Methods\n     * - `db.insert(todos)` - Insert into todos table\n     * - `.values({...})` - Provide row data with type checking\n     * - `.returning()` - Return the inserted row\n     *\n     * ### Type Safety Examples\n     * ```typescript\n     * // ‚úÖ Valid\n     * await db.insert(todos).values({\n     *   userId: 'uuid-string',\n     *   title: 'My Todo',\n     *   completed: false,\n     * })\n     *\n     * // ‚ùå Type errors caught at compile time\n     * await db.insert(todos).values({\n     *   userId: 123,              // Error: Expected string\n     *   invalidField: 'test',     // Error: Unknown field\n     *   title: undefined,         // Error: Title required\n     * })\n     * ```\n     *\n     * ### Returning Clause\n     * - `.returning()` returns inserted row(s)\n     * - Destructure `[todo]` to get first element\n     * - Fully typed as Todo from schema\n     * - Includes auto-generated fields (id, createdAt)\n     *\n     * ### Field Mapping\n     * - `userId` - From Supabase auth user\n     * - `title` - Trimmed user input\n     * - `description` - Trimmed or null if empty\n     * - `isPublic` - Boolean from checkbox\n     * - `completed` - Default false for new todos\n     * - `tags` - Default null (could accept from form)\n     */\n    const [todo] = await db\n      .insert(todos)\n      .values({\n        userId: user.id,\n        title: title.trim(),\n        description: description?.trim() || null,\n        isPublic,\n        completed: false,\n        tags: null,\n      })\n      .returning()\n    // CLOSE: drizzle-insert\n\n    /**\n     * REF: cache-invalidation\n     *\n     * # Cache Revalidation After Mutation\n     *\n     * ## Clear Stale Cache\n     * Invalidate cached dashboard data since a new todo was created.\n     *\n     * ### Why Needed?\n     * - Next.js caches Server Component renders\n     * - Dashboard was rendered with old todo list\n     * - This clears that cached render\n     * - Next visit fetches fresh data with new todo\n     *\n     * ### Revalidation Strategy\n     * - Revalidate specific paths that display this data\n     * - Immediate consistency for user\n     * - No stale data shown\n     *\n     * ### Multiple Path Revalidation\n     * ```typescript\n     * revalidatePath('/dashboard')  // User's dashboard\n     * revalidatePath('/feed')       // Public feed (if todo is public)\n     * ```\n     *\n     * ### Alternative: Cache Tags\n     * ```typescript\n     * revalidateTag('todos')        // All pages tagged with 'todos'\n     * ```\n     */\n    revalidatePath('/dashboard')\n    // CLOSE: cache-invalidation\n\n    /**\n     * REF: success-response\n     *\n     * # Return Success Result\n     *\n     * ## Discriminated Union Return Type\n     * Return success object with created todo.\n     *\n     * ### Return Shape\n     * ```typescript\n     * {\n     *   success: true,\n     *   todo: { id, title, completed, ... }\n     * }\n     * ```\n     *\n     * ### Client Usage\n     * ```typescript\n     * const result = await createTodoAction(formData)\n     *\n     * if ('success' in result) {\n     *   // TypeScript knows result.todo exists\n     *   console.log('Created:', result.todo.id)\n     *   setTodos([...todos, result.todo])\n     * } else {\n     *   // TypeScript knows result.error exists\n     *   alert(result.error)\n     * }\n     * ```\n     *\n     * ### Why Discriminated Union?\n     * - Type-safe error handling\n     * - No try-catch needed on client\n     * - Clear success/error states\n     * - Better than throwing errors\n     */\n    return { success: true, todo }\n    // CLOSE: success-response\n  } catch (error: any) {\n    /**\n     * REF: error-handling\n     *\n     * # Error Handling\n     *\n     * ## Catch and Return Errors\n     * Handle any unexpected errors gracefully.\n     *\n     * ### Error Types Caught\n     * - Database errors (constraint violations, connection issues)\n     * - Network errors\n     * - Unexpected exceptions\n     *\n     * ### Development\n     * - Log to console for debugging\n     * - Full error details available\n     *\n     * ### Production Considerations\n     * - Don't expose database errors to client\n     * - Log with error tracking service (Sentry, LogRocket)\n     * - Provide user-friendly messages\n     * - Monitor error rates\n     *\n     * ### Example Error Service\n     * ```typescript\n     * import * as Sentry from '@sentry/nextjs'\n     *\n     * Sentry.captureException(error, {\n     *   tags: { action: 'createTodo' },\n     *   user: { id: user.id }\n     * })\n     * ```\n     */\n    console.error('Server Action error:', error)\n    return { error: error.message || 'Failed to create todo' }\n    // CLOSE: error-handling\n  }\n}\n// CLOSE: create-todo-action\n\n/**\n * REF: update-todo-action\n *\n * ## Update Todo Server Action\n *\n * ## Purpose\n * Server Action that updates an existing todo with type safety.\n *\n * ## Function Signature\n * ```typescript\n * async function updateTodoAction(\n *   todoId: string,\n *   updates: {\n *     title?: string\n *     description?: string | null\n *     completed?: boolean\n *     isPublic?: boolean\n *   }\n * ): Promise<{ success: true; todo: Todo } | { error: string }>\n * ```\n *\n * ## Parameters\n * - `todoId` - ID of todo to update\n * - `updates` - Partial object with fields to change\n *\n * ## Usage Examples\n * ```typescript\n * // Toggle completion\n * await updateTodoAction(todoId, { completed: true })\n *\n * // Update title\n * await updateTodoAction(todoId, { title: 'New Title' })\n *\n * // Update multiple fields\n * await updateTodoAction(todoId, {\n *   title: 'Updated',\n *   description: 'New description',\n *   completed: true,\n * })\n * ```\n *\n * ## Security Consideration\n * Current implementation updates any todo by ID. In production, should verify\n * the todo belongs to the current user.\n *\n * ### Better Security\n * ```typescript\n * .where(and(\n *   eq(todos.id, todoId),\n *   eq(todos.userId, user.id)\n * ))\n * ```\n */\nexport async function updateTodoAction(\n  todoId: string,\n  updates: {\n    title?: string\n    description?: string | null\n    completed?: boolean\n    isPublic?: boolean\n  }\n) {\n  try {\n    /**\n     * REF: update-auth-check\n     *\n     * # Authentication Check for Updates\n     *\n     * Same pattern as create action - verify user is authenticated.\n     *\n     * ### Difference from Create\n     * - Returns error instead of redirecting\n     * - Better UX for updates (user stays on page)\n     * - Can show error message inline\n     */\n    const supabase = await createClient()\n    const {\n      data: { user },\n    } = await supabase.auth.getUser()\n\n    if (!user) {\n      return { error: 'Unauthorized' }\n    }\n    // CLOSE: update-auth-check\n\n    /**\n     * REF: drizzle-update\n     *\n     * # Drizzle Update Operation\n     *\n     * ## Type-Safe Database Update\n     * Update todo with type checking and conditions.\n     *\n     * ### Query Methods\n     * - `db.update(todos)` - Update todos table\n     * - `.set({...})` - Fields to update (type-checked)\n     * - `.where(eq(...))` - Which row to update\n     * - `.returning()` - Return updated row\n     *\n     * ### Generated SQL\n     * ```sql\n     * UPDATE todos\n     * SET\n     *   ...updates,\n     *   updated_at = NOW()\n     * WHERE id = $1\n     * RETURNING *\n     * ```\n     *\n     * ### Type Safety\n     * - `updates` parameter is typed\n     * - `.set()` validates fields exist in schema\n     * - `.where()` ensures id matches table's id type\n     * - TypeScript catches typos at compile time\n     *\n     * ### Security Issue\n     * Missing userId check in WHERE clause means any authenticated user\n     * can update any todo.\n     *\n     * ### Better Implementation\n     * ```typescript\n     * import { and } from 'drizzle-orm'\n     *\n     * .where(and(\n     *   eq(todos.id, todoId),\n     *   eq(todos.userId, user.id)\n     * ))\n     * ```\n     */\n    const [updated] = await db\n      .update(todos)\n      .set({\n        ...updates,\n        updatedAt: new Date(),\n      })\n      .where(eq(todos.id, todoId))\n      .returning()\n    // CLOSE: drizzle-update\n\n    /**\n     * REF: not-found-check\n     *\n     * # Check if Todo Exists\n     *\n     * ## Handle Missing Todos\n     * Return error if no todo was updated.\n     *\n     * ### Why Undefined?\n     * - todoId doesn't exist in database\n     * - Todo was already deleted\n     * - (Would be:) User doesn't own it\n     *\n     * ### Better Error Messages\n     * Could differentiate between:\n     * - Not found: \"Todo doesn't exist\"\n     * - Forbidden: \"You don't own this todo\"\n     */\n    if (!updated) {\n      return { error: 'Todo not found' }\n    }\n    // CLOSE: not-found-check\n\n    /**\n     * REF: update-revalidation\n     *\n     * # Revalidate After Update\n     *\n     * ## Clear Dashboard Cache\n     * Updates affect dashboard display, so clear cache.\n     *\n     * ### What Changed?\n     * - Completion status\n     * - Title or description\n     * - Public/private status\n     *\n     * All of these affect how dashboard displays todos.\n     */\n    revalidatePath('/dashboard')\n    // CLOSE: update-revalidation\n\n    return { success: true, todo: updated }\n  } catch (error: any) {\n    console.error('Update error:', error)\n    return { error: error.message || 'Failed to update' }\n  }\n}\n// CLOSE: update-todo-action\n\n/**\n * REF: delete-todo-action\n *\n * ## Delete Todo Server Action\n *\n * ## Purpose\n * Server Action that permanently deletes a todo.\n *\n * ## Function Signature\n * ```typescript\n * async function deleteTodoAction(\n *   todoId: string\n * ): Promise<{ success: true } | { error: string }>\n * ```\n *\n * ## Parameters\n * - `todoId` - ID of todo to delete\n *\n * ## Usage\n * ```typescript\n * const result = await deleteTodoAction(todoId)\n * if ('error' in result) {\n *   alert('Delete failed: ' + result.error)\n * } else {\n *   // Remove from UI\n *   setTodos(todos.filter(t => t.id !== todoId))\n * }\n * ```\n *\n * ## Security Issue\n * Same as update - missing userId check allows any user to delete any todo.\n */\nexport async function deleteTodoAction(todoId: string) {\n  try {\n    /**\n     * REF: delete-auth-check\n     *\n     * # Authentication Check\n     * Verify user before allowing deletion.\n     */\n    const supabase = await createClient()\n    const {\n      data: { user },\n    } = await supabase.auth.getUser()\n\n    if (!user) {\n      return { error: 'Unauthorized' }\n    }\n    // CLOSE: delete-auth-check\n\n    /**\n     * REF: drizzle-delete\n     *\n     * # Drizzle Delete Operation\n     *\n     * ## Type-Safe Database Delete\n     * Remove todo from database.\n     *\n     * ### Query Methods\n     * - `db.delete(todos)` - Delete from todos table\n     * - `.where(eq(...))` - Match condition\n     *\n     * ### Generated SQL\n     * ```sql\n     * DELETE FROM todos WHERE id = $1\n     * ```\n     *\n     * ### No Returning\n     * - Deletes don't typically return data\n     * - Could add `.returning()` if needed\n     * - Void return indicates success\n     *\n     * ### Security Issue\n     * Missing userId check - should filter by both id AND userId:\n     *\n     * ```typescript\n     * .where(and(\n     *   eq(todos.id, todoId),\n     *   eq(todos.userId, user.id)\n     * ))\n     * ```\n     */\n    await db.delete(todos).where(eq(todos.id, todoId))\n    // CLOSE: drizzle-delete\n\n    /**\n     * REF: delete-revalidation\n     *\n     * # Revalidate After Delete\n     *\n     * Dashboard needs to remove deleted todo from list.\n     */\n    revalidatePath('/dashboard')\n    // CLOSE: delete-revalidation\n\n    return { success: true }\n  } catch (error: any) {\n    console.error('Delete error:', error)\n    return { error: error.message || 'Failed to delete' }\n  }\n}\n// CLOSE: delete-todo-action\n\n/**\n * REF: toggle-completion-action\n *\n * ## Toggle Completion Server Action\n *\n * ## Purpose\n * Convenience wrapper around updateTodoAction for toggling completion status.\n *\n * ## Function Signature\n * ```typescript\n * async function toggleCompletionAction(\n *   todoId: string,\n *   currentCompleted: boolean\n * ): Promise<{ success: true; todo: Todo } | { error: string }>\n * ```\n *\n * ## Simpler API\n * Instead of:\n * ```typescript\n * await updateTodoAction(todoId, { completed: !currentCompleted })\n * ```\n *\n * Use:\n * ```typescript\n * await toggleCompletionAction(todoId, currentCompleted)\n * ```\n *\n * ## Implementation\n * - Delegates to updateTodoAction\n * - Returns same result type\n * - Less code in components\n * - More semantic function name\n */\nexport async function toggleCompletionAction(todoId: string, currentCompleted: boolean) {\n  return updateTodoAction(todoId, { completed: !currentCompleted })\n}\n// CLOSE: toggle-completion-action\n\n/**\n * REF: type-safety-notes\n *\n * ## Perfect Type Safety with Drizzle\n *\n * ## Compile-Time Validation\n * With Drizzle + Server Actions, all database operations are type-checked.\n *\n * ### Example: Type-Safe Updates\n * ```typescript\n * // In component:\n * const result = await updateTodoAction(id, {\n *   title: 'New title',        // ‚úÖ string\n *   completed: true,            // ‚úÖ boolean\n * })\n *\n * // TypeScript catches errors at compile time:\n * await updateTodoAction(id, {\n *   title: 123,                 // ‚ùå Error: Expected string\n *   invalidField: 'test',       // ‚ùå Error: Unknown field\n * })\n * ```\n *\n * ### Benefits\n * - Catch errors before runtime\n * - Autocomplete for all fields\n * - Refactoring is safe\n * - No type casts needed\n * - Database schema drives types\n *\n * ## Better Than API Routes\n * - No manual type definitions\n * - No request/response parsing\n * - Simpler code\n * - Better DX\n */\n// CLOSE: type-safety-notes\n\n/**\n * REF: usage-patterns\n *\n * ## Usage in Components\n *\n * ## Form Action Pattern\n * ```tsx\n * import { createTodoAction } from '@/app/actions'\n *\n * <form action={createTodoAction}>\n *   <input name=\"title\" required />\n *   <textarea name=\"description\" />\n *   <button type=\"submit\">Create</button>\n * </form>\n * ```\n *\n * ## useTransition Pattern\n * ```tsx\n * import { useTransition } from 'react'\n *\n * const [isPending, startTransition] = useTransition()\n *\n * const handleSubmit = (formData: FormData) => {\n *   startTransition(async () => {\n *     const result = await createTodoAction(formData)\n *     if (result.error) {\n *       setError(result.error)\n *     } else {\n *       setTodos([...todos, result.todo])\n *     }\n *   })\n * }\n *\n * <form onSubmit={(e) => {\n *   e.preventDefault()\n *   handleSubmit(new FormData(e.currentTarget))\n * }}>\n * ```\n *\n * ## Direct Call Pattern\n * ```tsx\n * const handleToggle = async () => {\n *   const result = await updateTodoAction(todo.id, {\n *     completed: !todo.completed\n *   })\n *\n *   if ('success' in result) {\n *     setTodo(result.todo)\n *   }\n * }\n * ```\n */\n// CLOSE: usage-patterns\n",
      "language": "typescript"
    },
    {
      "path": "app/dashboard/page.tsx",
      "content": "/**\n * REF: file-header\n *\n * # Dashboard Page - Type-Safe Queries with Drizzle ORM\n *\n * This page demonstrates Drizzle ORM's perfect TypeScript inference for database queries.\n *\n * ## Key Features\n * - Drizzle's automatic type inference\n * - SQL-like query syntax\n * - Type-safe CRUD operations\n * - Helper functions from queries.ts\n *\n * ## Drizzle vs Supabase Client\n * - **Drizzle**: Perfect type safety, SQL-like syntax, explicit\n * - **Supabase**: Good types, chainable methods, implicit\n * - **Drizzle**: Better for complex queries\n * - **Supabase**: Better for simple CRUD\n *\n * ## Why This Combination?\n * - Drizzle for database queries (type-safe)\n * - Supabase for auth (best-in-class)\n * - Supabase for storage (easy file uploads)\n * - Best of both worlds\n *\n * ## Type Inference Example\n * ```typescript\n * const todos = await getUserTodos(userId)\n * // TypeScript automatically knows:\n * // todos: { id: string, title: string, completed: boolean, ... }[]\n *\n * todos[0].title     // ‚úÖ string\n * todos[0].completed // ‚úÖ boolean\n * todos[0].invalid   // ‚ùå Type error!\n * ```\n *\n * No manual type annotations needed - Drizzle infers everything from the schema.\n */\n// CLOSE: file-header\n\n/**\n * REF: use-client-directive\n *\n * ## Client Component Directive\n *\n * ## Why 'use client'?\n * This page needs client-side interactivity for:\n * - Form state management\n * - User interactions (click handlers)\n * - Auth context consumption\n * - Router navigation\n *\n * ## Client vs Server Components\n * - **Client**: Interactive, uses hooks, event handlers\n * - **Server**: Static, async/await data fetching, no interactivity\n *\n * ## This Component Needs\n * - useState for form inputs and todos\n * - useEffect for data fetching\n * - useAuth for authentication\n * - useRouter for navigation\n * - Event handlers for CRUD operations\n */\n'use client'\n// CLOSE: use-client-directive\n\n/**\n * REF: react-imports\n *\n * ## React Hook Imports\n *\n * ## useState\n * Manages component state:\n * - Form inputs (title, description, tags)\n * - Todos list\n * - Loading states\n * - Error messages\n *\n * ## useEffect\n * Handles side effects:\n * - Fetch todos on mount\n * - Redirect if not authenticated\n * - Could add real-time subscriptions\n */\nimport { useState, useEffect } from 'react'\n// CLOSE: react-imports\n\n/**\n * REF: nextjs-imports\n *\n * ## Next.js Navigation Import\n *\n * ## useRouter Hook\n * Enables client-side navigation.\n *\n * ### Usage\n * ```typescript\n * router.push('/signin')     // Navigate to sign in\n * router.back()              // Go back\n * router.refresh()           // Refresh data\n * ```\n *\n * ### When to Use\n * - Redirect after auth check\n * - Navigate after actions\n * - Programmatic navigation\n */\nimport { useRouter } from 'next/navigation'\n// CLOSE: nextjs-imports\n\n/**\n * REF: auth-context-import\n *\n * ## Authentication Context Import\n *\n * ## useAuth Hook\n * Provides access to authentication state and methods.\n *\n * ### Available Properties\n * ```typescript\n * const {\n *   user,      // Current user or null\n *   loading,   // Auth loading state\n *   signIn,    // Sign in method\n *   signOut,   // Sign out method\n * } = useAuth()\n * ```\n *\n * ### Usage Pattern\n * - Check if user exists\n * - Redirect to sign in if null\n * - Use user.id for database queries\n */\nimport { useAuth } from '@/contexts/AuthContext'\n// CLOSE: auth-context-import\n\n/**\n * REF: drizzle-query-imports\n *\n * ## Drizzle Query Helper Imports\n *\n * These are type-safe helper functions defined in lib/db/queries.ts.\n *\n * ## getUserTodos\n * Fetches all todos for a specific user.\n * - Type-safe query\n * - Returns typed array\n * - Filters by userId\n *\n * ## createTodo\n * Creates a new todo record.\n * - Type-safe insert\n * - Returns created todo\n * - Validates data structure\n *\n * ## updateTodo\n * Updates an existing todo.\n * - Type-safe update\n * - Partial updates supported\n * - Returns updated todo\n *\n * ## deleteTodo\n * Deletes a todo by ID.\n * - Type-safe delete\n * - Returns void\n * - Could return deleted record\n *\n * ### Benefits of Helper Functions\n * - Reusable query logic\n * - Centralized data access\n * - Easier to test\n * - Consistent error handling\n */\nimport {\n  getUserTodos,\n  createTodo,\n  updateTodo,\n  deleteTodo,\n} from '@/lib/db/queries'\n// CLOSE: drizzle-query-imports\n\n/**\n * REF: type-inference-comment\n *\n * ## Type Inference from Drizzle\n *\n * ## No Need to Import Todo Type!\n * Drizzle automatically infers types from query return values.\n *\n * ### How to Get the Type (if needed)\n * ```typescript\n * import { InferSelectModel } from 'drizzle-orm'\n * import { todos } from '@/lib/db/schema'\n *\n * type Todo = InferSelectModel<typeof todos>\n * ```\n *\n * ### Why It's Not Needed Here\n * - TypeScript infers from `getUserTodos()` return type\n * - `Awaited<ReturnType<typeof getUserTodos>>` extracts the type\n * - No manual type definitions required\n * - Schema is single source of truth\n */\n// CLOSE: type-inference-comment\n\n/**\n * REF: dashboard-component\n *\n * ## Dashboard Page Component\n *\n * ## Component Architecture\n * Main dashboard component that manages todo CRUD operations.\n *\n * ### Responsibilities\n * - Fetch user's todos\n * - Display todo list\n * - Handle todo creation\n * - Handle todo updates\n * - Handle todo deletion\n * - Manage form state\n * - Handle authentication\n *\n * ### State Management\n * Uses local component state with useState for:\n * - Todo list\n * - Form inputs\n * - UI state (loading, errors)\n *\n * ### Data Flow\n * 1. User authenticates\n * 2. Fetch todos from database\n * 3. Display in UI\n * 4. User performs CRUD operations\n * 5. Update local state\n * 6. Sync with database\n */\nexport default function DashboardPage() {\n  /**\n   * REF: auth-state\n   *\n   * # Authentication State\n   *\n   * ## Extract Auth Properties\n   * Get user and loading state from auth context.\n   *\n   * ### user Property\n   * - Contains user data if authenticated\n   * - null if not authenticated\n   * - Includes id, email, metadata\n   *\n   * ### authLoading Property\n   * - true during initial auth check\n   * - false after auth state determined\n   * - Prevents premature redirects\n   */\n  const { user, loading: authLoading } = useAuth()\n  const router = useRouter()\n  // CLOSE: auth-state\n\n  /**\n   * REF: component-state\n   *\n   * # Component State Management\n   *\n   * ## Todo State\n   * - `todos` - Array of user's todos\n   * - Type inferred from getUserTodos return type\n   * - Updated after CRUD operations\n   *\n   * ## Loading State\n   * - `loading` - true while fetching todos\n   * - false after fetch completes\n   * - Separate from authLoading\n   *\n   * ## Error State\n   * - `error` - Error message string\n   * - Empty string when no error\n   * - Displayed to user in UI\n   *\n   * ### Type Safety\n   * ```typescript\n   * Awaited<ReturnType<typeof getUserTodos>>\n   * ```\n   * - Extracts return type from getUserTodos\n   * - Awaited unwraps the Promise\n   * - Array of typed todo objects\n   */\n  const [todos, setTodos] = useState<Awaited<ReturnType<typeof getUserTodos>>>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState('')\n  // CLOSE: component-state\n\n  /**\n   * REF: form-state\n   *\n   * # Form Input State\n   *\n   * ## Todo Creation Form Fields\n   * - `title` - Todo title (required)\n   * - `description` - Todo description (optional)\n   * - `isPublic` - Public/private toggle (boolean)\n   * - `tags` - Array of tag strings\n   * - `tagInput` - Temporary input for adding tags\n   *\n   * ### Form Flow\n   * 1. User types in inputs\n   * 2. State updates on change\n   * 3. Submit creates todo\n   * 4. Form clears on success\n   *\n   * ### Tag Management\n   * - Tags stored as string array\n   * - tagInput is temporary\n   * - Add tag moves from input to tags array\n   * - Remove tag filters from tags array\n   */\n  const [title, setTitle] = useState('')\n  const [description, setDescription] = useState('')\n  const [isPublic, setIsPublic] = useState(false)\n  const [tags, setTags] = useState<string[]>([])\n  const [tagInput, setTagInput] = useState('')\n  // CLOSE: form-state\n\n  /**\n   * REF: auth-protection-effect\n   *\n   * # Authentication Protection Effect\n   *\n   * ## Purpose\n   * Redirect unauthenticated users to sign in page.\n   *\n   * ### Logic\n   * 1. Wait for auth loading to complete\n   * 2. Check if user exists\n   * 3. Redirect to signin if null\n   *\n   * ### Dependencies\n   * - `user` - Triggers when auth state changes\n   * - `authLoading` - Prevents redirect during loading\n   * - `router` - Used for navigation\n   *\n   * ### Why Separate Effect?\n   * - Auth check independent from data fetching\n   * - Runs before todo fetching\n   * - Prevents unnecessary API calls\n   *\n   * ### Alternative Approaches\n   * - Middleware for route protection\n   * - Higher-order component\n   * - Separate auth guard component\n   */\n  useEffect(() => {\n    if (!authLoading && !user) {\n      router.push('/signin')\n    }\n  }, [user, authLoading, router])\n  // CLOSE: auth-protection-effect\n\n  /**\n   * REF: fetch-todos-effect\n   *\n   * # Fetch Todos Effect\n   *\n   * ## Purpose\n   * Load user's todos from database when component mounts or user changes.\n   *\n   * ### Flow\n   * 1. Check if user exists (early return if not)\n   * 2. Define async fetch function\n   * 3. Call getUserTodos with user ID\n   * 4. Update todos state\n   * 5. Set loading to false\n   * 6. Handle errors\n   *\n   * ### Type Safety\n   * ```typescript\n   * const userTodos = await getUserTodos(user.id)\n   * // userTodos is automatically typed!\n   * // No type assertions needed\n   * ```\n   *\n   * ### Error Handling\n   * - Try-catch for async operations\n   * - Log errors to console\n   * - Set error message for user\n   * - Still set loading false\n   *\n   * ### Dependencies\n   * - `user` - Refetch when user changes\n   * - Could add: refetch trigger, polling\n   *\n   * ## Real-Time Updates (Optional)\n   *\n   * ### With Supabase + Drizzle\n   * You can combine Supabase real-time with Drizzle queries:\n   *\n   * ```typescript\n   * import { createClient } from '@/lib/supabase/client'\n   *\n   * const supabase = createClient()\n   *\n   * const channel = supabase\n   *   .channel('todos')\n   *   .on('postgres_changes', {\n   *     event: '*',\n   *     schema: 'public',\n   *     table: 'todos',\n   *     filter: `user_id=eq.${user.id}`\n   *   }, () => {\n   *     fetchTodos() // Refetch with Drizzle\n   *   })\n   *   .subscribe()\n   *\n   * return () => supabase.removeChannel(channel)\n   * ```\n   *\n   * ### Benefits of Hybrid Approach\n   * - Supabase broadcasts changes\n   * - Drizzle fetches with type safety\n   * - Best of both worlds\n   */\n  useEffect(() => {\n    if (!user) return\n\n    const fetchTodos = async () => {\n      try {\n        const userTodos = await getUserTodos(user.id)\n        setTodos(userTodos)\n        setLoading(false)\n      } catch (error: any) {\n        console.error('Error fetching todos:', error)\n        setError('Failed to load todos')\n        setLoading(false)\n      }\n    }\n\n    fetchTodos()\n  }, [user])\n  // CLOSE: fetch-todos-effect\n\n  /**\n   * REF: create-todo-handler\n   *\n   * # Create Todo Handler\n   *\n   * ## Purpose\n   * Handle form submission to create a new todo.\n   *\n   * ### Flow\n   * 1. Prevent default form submission\n   * 2. Validate user and title\n   * 3. Call createTodo with data\n   * 4. Add new todo to state (optimistic update)\n   * 5. Clear form inputs\n   * 6. Handle errors\n   *\n   * ### Type Safety\n   * ```typescript\n   * const newTodo = await createTodo({\n   *   userId: user.id,        // ‚úÖ string\n   *   title: title.trim(),    // ‚úÖ string\n   *   description: string,    // ‚úÖ string\n   *   isPublic,               // ‚úÖ boolean\n   *   tags: tags || undefined // ‚úÖ string[] | undefined\n   * })\n   * // newTodo is fully typed!\n   * ```\n   *\n   * ### Drizzle Type Validation\n   * TypeScript catches errors at compile time:\n   * ```typescript\n   * await createTodo({\n   *   userId: 123,            // ‚ùå Error: Expected string\n   *   title: 42,              // ‚ùå Error: Expected string\n   *   invalidField: true,     // ‚ùå Error: Unknown field\n   * })\n   * ```\n   *\n   * ### Optimistic Update\n   * - Add to UI immediately\n   * - Don't wait for database\n   * - Better UX (feels faster)\n   * - Could rollback on error\n   *\n   * ### Form Reset\n   * Clear all form fields after successful creation\n   */\n  const handleCreateTodo = async (e: React.FormEvent) => {\n    e.preventDefault()\n\n    if (!user || !title.trim()) return\n\n    try {\n      const newTodo = await createTodo({\n        userId: user.id,\n        title: title.trim(),\n        description: description.trim(),\n        isPublic,\n        tags: tags.length > 0 ? tags : undefined,\n      })\n\n      // Add to state for instant UI update\n      setTodos([newTodo, ...todos])\n\n      // Clear form\n      setTitle('')\n      setDescription('')\n      setIsPublic(false)\n      setTags([])\n    } catch (error: any) {\n      console.error('Error creating todo:', error)\n      setError('Failed to create todo')\n    }\n  }\n  // CLOSE: create-todo-handler\n\n  /**\n   * REF: toggle-complete-handler\n   *\n   * # Toggle Todo Completion Handler\n   *\n   * ## Purpose\n   * Toggle a todo's completed status.\n   *\n   * ### Flow\n   * 1. Call updateTodo with new completed value\n   * 2. Update local state optimistically\n   * 3. Handle errors\n   *\n   * ### Type Safety\n   * ```typescript\n   * await updateTodo(todoId, { completed: !completed })\n   * // TypeScript knows:\n   * // - todoId must be string\n   * // - completed must be boolean\n   * // - Only valid todo fields allowed\n   * ```\n   *\n   * ### Optimistic Update Pattern\n   * ```typescript\n   * setTodos(todos.map(t =>\n   *   t.id === todoId\n   *     ? { ...t, completed: !completed }\n   *     : t\n   * ))\n   * ```\n   * - Updates specific todo in array\n   * - Preserves other todos unchanged\n   * - Immediate UI feedback\n   *\n   * ### Error Handling\n   * - Could rollback optimistic update\n   * - Could refetch from database\n   * - Could show error toast\n   */\n  const handleToggleComplete = async (todoId: string, completed: boolean) => {\n    try {\n      await updateTodo(todoId, { completed: !completed })\n\n      // Update local state\n      setTodos(todos.map(t =>\n        t.id === todoId ? { ...t, completed: !completed } : t\n      ))\n    } catch (error: any) {\n      console.error('Error updating todo:', error)\n      setError('Failed to update todo')\n    }\n  }\n  // CLOSE: toggle-complete-handler\n\n  /**\n   * REF: delete-todo-handler\n   *\n   * # Delete Todo Handler\n   *\n   * ## Purpose\n   * Permanently delete a todo after confirmation.\n   *\n   * ### Flow\n   * 1. Show browser confirmation dialog\n   * 2. Return if user cancels\n   * 3. Call deleteTodo function\n   * 4. Remove from local state\n   * 5. Handle errors\n   *\n   * ### Confirmation\n   * - Uses browser's native confirm dialog\n   * - Simple and accessible\n   * - Could use custom modal for better UX\n   *\n   * ### Type Safety\n   * ```typescript\n   * await deleteTodo(todoId)\n   * // TypeScript ensures todoId is correct type\n   * ```\n   *\n   * ### State Update\n   * ```typescript\n   * setTodos(todos.filter(t => t.id !== todoId))\n   * ```\n   * - Filters out deleted todo\n   * - Returns new array\n   * - Triggers re-render\n   *\n   * ### Better Confirmation UX\n   * ```typescript\n   * // Custom modal\n   * const confirmed = await confirmDialog({\n   *   title: 'Delete Todo',\n   *   message: 'This cannot be undone',\n   * })\n   * ```\n   */\n  const handleDeleteTodo = async (todoId: string) => {\n    if (!confirm('Delete this todo?')) return\n\n    try {\n      await deleteTodo(todoId)\n\n      // Remove from local state\n      setTodos(todos.filter(t => t.id !== todoId))\n    } catch (error: any) {\n      console.error('Error deleting todo:', error)\n      setError('Failed to delete todo')\n    }\n  }\n  // CLOSE: delete-todo-handler\n\n  /**\n   * REF: tag-handlers\n   *\n   * # Tag Management Handlers\n   *\n   * ## handleAddTag\n   * Adds a tag to the tags array.\n   *\n   * ### Logic\n   * 1. Trim and lowercase input\n   * 2. Check if valid and not duplicate\n   * 3. Check limit (max 10 tags)\n   * 4. Add to tags array\n   * 5. Clear input\n   *\n   * ### Validation Rules\n   * - Not empty after trim\n   * - Not already in tags array\n   * - Less than 10 tags total\n   * - Lowercase for consistency\n   *\n   * ### Usage\n   * - Called on button click\n   * - Called on Enter key press\n   * - Clears input after adding\n   */\n  const handleAddTag = () => {\n    const tag = tagInput.trim().toLowerCase()\n    if (tag && !tags.includes(tag) && tags.length < 10) {\n      setTags([...tags, tag])\n      setTagInput('')\n    }\n  }\n  // CLOSE: tag-handlers\n\n  /**\n   * REF: loading-state-render\n   *\n   * # Loading State Render\n   *\n   * ## Purpose\n   * Show loading indicator while auth or data is loading.\n   *\n   * ### When Shown\n   * - authLoading is true (checking authentication)\n   * - loading is true (fetching todos)\n   *\n   * ### Why Separate Loading States?\n   * - Auth loading happens first\n   * - Data loading happens after auth\n   * - Could show different messages\n   *\n   * ### UI Pattern\n   * - Centered flex container\n   * - Simple text message\n   * - Could add spinner\n   * - Could add skeleton UI\n   *\n   * ### Better Loading UX\n   * ```typescript\n   * if (authLoading) return <Spinner message=\"Checking auth...\" />\n   * if (loading) return <TodosSkeleton />\n   * ```\n   */\n  if (authLoading || loading) {\n    return (\n      <div className=\"flex min-h-screen items-center justify-center\">\n        <div className=\"text-xl\">Loading...</div>\n      </div>\n    )\n  }\n  // CLOSE: loading-state-render\n\n  /**\n   * REF: no-user-render\n   *\n   * # No User State Render\n   *\n   * ## Purpose\n   * Return null if no user (will redirect via useEffect).\n   *\n   * ### Why Null?\n   * - useEffect will redirect to signin\n   * - Prevents flash of content\n   * - Cleaner than conditional rendering\n   *\n   * ### Redirect Happens In\n   * The auth-protection-effect useEffect handles navigation.\n   */\n  if (!user) return null\n  // CLOSE: no-user-render\n\n  /**\n   * REF: main-render\n   *\n   * # Main Dashboard Render\n   *\n   * ## Layout Structure\n   * - Full screen with background\n   * - Centered container (max-width)\n   * - Header with title\n   * - Error display\n   * - Create form\n   * - Todos list\n   */\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900 p-8\">\n      <div className=\"container mx-auto max-w-4xl\">\n        {/* CLOSE: main-render */}\n\n        {/**\n         * REF: page-header\n         *\n         * # Page Header\n         *\n         * Simple heading for the dashboard.\n         */}\n        <h1 className=\"text-4xl font-bold mb-8\">My Todos</h1>\n        {/* CLOSE: page-header */}\n\n        {/**\n         * REF: error-display\n         *\n         * # Error Message Display\n         *\n         * ## Conditional Rendering\n         * Only shows if error state is not empty.\n         *\n         * ### Styling\n         * - Red background (bg-red-100)\n         * - Red text (text-red-700)\n         * - Padding and rounded corners\n         * - Bottom margin\n         *\n         * ### Better Error Handling\n         * - Auto-dismiss after timeout\n         * - Close button\n         * - Different error types (warning, info)\n         * - Toast notifications\n         */}\n        {error && (\n          <div className=\"bg-red-100 text-red-700 px-4 py-3 rounded mb-6\">\n            {error}\n          </div>\n        )}\n        {/* CLOSE: error-display */}\n\n        {/**\n         * REF: create-form\n         *\n         * # Create Todo Form\n         *\n         * ## Form Structure\n         * Form for creating new todos with multiple fields.\n         *\n         * ### Fields\n         * - Title input (required)\n         * - Description textarea (optional)\n         * - Tag input with add button\n         * - Tag display with remove buttons\n         * - Public checkbox\n         * - Submit button\n         *\n         * ### Form Handling\n         * - onSubmit calls handleCreateTodo\n         * - Prevents default form submission\n         * - Controlled inputs (value + onChange)\n         *\n         * ### Styling\n         * - White card with shadow\n         * - Responsive padding\n         * - Vertical spacing (space-y-4)\n         * - Full width inputs\n         */}\n        <form onSubmit={handleCreateTodo} className=\"bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-6\">\n          {/* CLOSE: create-form */}\n\n          {/**\n           * REF: form-header\n           *\n           * # Form Header\n           *\n           * Heading for the create form section.\n           */}\n          <h2 className=\"text-2xl font-bold mb-4\">Create New Todo</h2>\n          {/* CLOSE: form-header */}\n\n          {/**\n           * REF: form-inputs\n           *\n           * # Form Input Fields\n           *\n           * ## Title Input\n           * - Required field\n           * - Controlled input (value={title})\n           * - Updates on change\n           * - Full width with styling\n           *\n           * ## Description Textarea\n           * - Optional field\n           * - Multiline input (3 rows)\n           * - Controlled textarea\n           * - Full width with styling\n           *\n           * ## Tag Input Section\n           * - Text input for tag entry\n           * - Button to add tag\n           * - Enter key also adds tag\n           * - Flex layout for side-by-side\n           *\n           * ### Controlled Inputs Pattern\n           * ```typescript\n           * value={title}\n           * onChange={(e) => setTitle(e.target.value)}\n           * ```\n           * - React controls the input value\n           * - Single source of truth (state)\n           * - Easy to validate and transform\n           */}\n          <div className=\"space-y-4\">\n            <input\n              type=\"text\"\n              value={title}\n              onChange={(e) => setTitle(e.target.value)}\n              placeholder=\"Title\"\n              required\n              className=\"w-full px-4 py-2 border rounded-lg dark:bg-gray-700\"\n            />\n\n            <textarea\n              value={description}\n              onChange={(e) => setDescription(e.target.value)}\n              placeholder=\"Description (optional)\"\n              rows={3}\n              className=\"w-full px-4 py-2 border rounded-lg dark:bg-gray-700\"\n            />\n\n            <div className=\"flex gap-2\">\n              <input\n                type=\"text\"\n                value={tagInput}\n                onChange={(e) => setTagInput(e.target.value)}\n                onKeyDown={(e) => e.key === 'Enter' && (e.preventDefault(), handleAddTag())}\n                placeholder=\"Add tag...\"\n                className=\"flex-1 px-4 py-2 border rounded-lg dark:bg-gray-700\"\n              />\n              <button\n                type=\"button\"\n                onClick={handleAddTag}\n                className=\"px-4 py-2 bg-gray-200 rounded-lg\"\n              >\n                Add\n              </button>\n            </div>\n            {/* CLOSE: form-inputs */}\n\n            {/**\n             * REF: tag-display\n             *\n             * # Tag Display Section\n             *\n             * ## Conditional Rendering\n             * Only shows if tags array has items.\n             *\n             * ## Tag Pills\n             * - Maps over tags array\n             * - Each tag is a styled pill\n             * - Remove button (√ó) for each tag\n             * - Flex wrap layout\n             *\n             * ### Remove Tag Logic\n             * ```typescript\n             * setTags(tags.filter(t => t !== tag))\n             * ```\n             * - Filters out clicked tag\n             * - Returns new array\n             * - Triggers re-render\n             */}\n            {tags.length > 0 && (\n              <div className=\"flex flex-wrap gap-2\">\n                {tags.map(tag => (\n                  <span key={tag} className=\"px-3 py-1 bg-blue-100 rounded-full text-sm\">\n                    {tag}\n                    <button\n                      onClick={() => setTags(tags.filter(t => t !== tag))}\n                      className=\"ml-2\"\n                    >\n                      √ó\n                    </button>\n                  </span>\n                ))}\n              </div>\n            )}\n            {/* CLOSE: tag-display */}\n\n            {/**\n             * REF: public-checkbox\n             *\n             * # Public/Private Toggle\n             *\n             * ## Checkbox Input\n             * - Controlled checkbox (checked={isPublic})\n             * - Label for accessibility\n             * - Toggle public visibility\n             *\n             * ### Checkbox Pattern\n             * ```typescript\n             * checked={isPublic}\n             * onChange={(e) => setIsPublic(e.target.checked)}\n             * ```\n             * - e.target.checked is boolean\n             * - Directly set state\n             * - Visual feedback automatic\n             */}\n            <label className=\"flex items-center gap-2\">\n              <input\n                type=\"checkbox\"\n                checked={isPublic}\n                onChange={(e) => setIsPublic(e.target.checked)}\n              />\n              <span>Make public</span>\n            </label>\n            {/* CLOSE: public-checkbox */}\n\n            {/**\n             * REF: submit-button\n             *\n             * # Form Submit Button\n             *\n             * ## Button Styling\n             * - Full width\n             * - Blue background\n             * - White text\n             * - Hover state\n             * - Large padding\n             *\n             * ### Type Submit\n             * - Triggers form onSubmit\n             * - Native form validation\n             * - Enter key submits\n             */}\n            <button\n              type=\"submit\"\n              className=\"w-full py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700\"\n            >\n              Create Todo\n            </button>\n            {/* CLOSE: submit-button */}\n          </div>\n        </form>\n\n        {/**\n         * REF: todos-list\n         *\n         * # Todos List Display\n         *\n         * ## Purpose\n         * Render all todos with interactive elements.\n         *\n         * ### List Structure\n         * - Maps over todos array\n         * - Each todo is a card\n         * - Vertical spacing (space-y-3)\n         *\n         * ### Todo Card Components\n         * - Checkbox for completion\n         * - Title (strikethrough if complete)\n         * - Description\n         * - Tags\n         * - Delete button\n         *\n         * ### Interactive Elements\n         * - Checkbox toggles completion\n         * - Delete button removes todo\n         * - All actions update local state\n         *\n         * ### Type Safety\n         * ```typescript\n         * todos.map(todo => ...)\n         * // TypeScript knows todo's shape\n         * // todo.id, todo.title, todo.completed, etc.\n         * // All autocompleted and type-checked\n         * ```\n         */}\n        <div className=\"space-y-3\">\n          {todos.map(todo => (\n            <div key={todo.id} className=\"bg-white dark:bg-gray-800 rounded-lg shadow p-4 flex gap-4\">\n              {/* CLOSE: todos-list */}\n\n              {/**\n               * REF: todo-checkbox\n               *\n               * # Todo Completion Checkbox\n               *\n               * ## Checkbox Control\n               * - Shows current completion status\n               * - onClick toggles completion\n               * - Larger size for easier clicking\n               *\n               * ### Handler Call\n               * ```typescript\n               * onChange={() => handleToggleComplete(todo.id, todo.completed)}\n               * ```\n               * - Passes todo ID and current status\n               * - Handler updates database\n               * - Local state updates for instant feedback\n               */}\n              <input\n                type=\"checkbox\"\n                checked={todo.completed}\n                onChange={() => handleToggleComplete(todo.id, todo.completed)}\n                className=\"mt-1 w-5 h-5\"\n              />\n              {/* CLOSE: todo-checkbox */}\n\n              {/**\n               * REF: todo-content\n               *\n               * # Todo Content Display\n               *\n               * ## Title\n               * - Bold font weight\n               * - Strikethrough if completed\n               * - Conditional styling with ternary\n               *\n               * ## Description\n               * - Shows if exists (conditional rendering)\n               * - Smaller text\n               * - Gray color\n               * - Top margin\n               *\n               * ## Tags\n               * - Shows if tags exist and array has length\n               * - Maps over tags array\n               * - Small pills with gray background\n               * - Hashtag prefix\n               *\n               * ### Conditional Styling Pattern\n               * ```typescript\n               * className={`font-medium ${todo.completed ? 'line-through' : ''}`}\n               * ```\n               * - Template literal for dynamic classes\n               * - Ternary for conditional class\n               * - Tailwind utilities\n               */}\n              <div className=\"flex-1\">\n                <h3 className={`font-medium ${todo.completed ? 'line-through' : ''}`}>\n                  {todo.title}\n                </h3>\n                {todo.description && (\n                  <p className=\"text-sm text-gray-600 mt-1\">{todo.description}</p>\n                )}\n                {todo.tags && todo.tags.length > 0 && (\n                  <div className=\"flex gap-2 mt-2\">\n                    {todo.tags.map(tag => (\n                      <span key={tag} className=\"text-xs px-2 py-1 bg-gray-100 rounded-full\">\n                        #{tag}\n                      </span>\n                    ))}\n                  </div>\n                )}\n              </div>\n              {/* CLOSE: todo-content */}\n\n              {/**\n               * REF: delete-button\n               *\n               * # Delete Todo Button\n               *\n               * ## Button Styling\n               * - Red text for destructive action\n               * - Hover background\n               * - Rounded corners\n               * - Padding for click area\n               *\n               * ### Click Handler\n               * - Calls handleDeleteTodo with todo ID\n               * - Shows confirmation dialog\n               * - Removes from state on success\n               *\n               * ### Icon\n               * - Trash emoji for delete action\n               * - Could use icon library\n               * - Visual affordance for deletion\n               */}\n              <button\n                onClick={() => handleDeleteTodo(todo.id)}\n                className=\"p-2 text-red-600 hover:bg-red-50 rounded\"\n              >\n                üóëÔ∏è\n              </button>\n              {/* CLOSE: delete-button */}\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  )\n}\n// CLOSE: dashboard-component\n\n/**\n * REF: drizzle-type-safety-showcase\n *\n * ## Drizzle Type Safety Showcase\n *\n * ## Every Query is Fully Typed\n *\n * ### Select Query Type Inference\n * ```typescript\n * const result = await db\n *   .select({\n *     id: todos.id,\n *     title: todos.title,        // ‚úÖ Autocomplete!\n *     completed: todos.completed,\n *   })\n *   .from(todos)\n *\n * result[0].title      // ‚úÖ string\n * result[0].completed  // ‚úÖ boolean\n * result[0].userId     // ‚ùå Type error - not selected!\n * ```\n *\n * ### Insert Type Checking\n * ```typescript\n * await db.insert(todos).values({\n *   userId: 'uuid',          // ‚úÖ string\n *   title: 'My Todo',        // ‚úÖ string\n *   completed: false,        // ‚úÖ boolean\n * })\n *\n * // Compile-time errors:\n * await db.insert(todos).values({\n *   userId: 123,             // ‚ùå Error: Expected string\n *   invalidField: 'test',    // ‚ùå Error: Unknown field\n * })\n * ```\n *\n * ### Update Type Checking\n * ```typescript\n * await db.update(todos).set({\n *   title: 'Updated',        // ‚úÖ string\n *   completed: true,         // ‚úÖ boolean\n * })\n *\n * // Compile-time errors:\n * await db.update(todos).set({\n *   title: 42,               // ‚ùå Error: Expected string\n * })\n * ```\n *\n * ## Why This Level of Type Safety Matters\n * - Catch errors before runtime\n * - Autocomplete in IDE\n * - Safe refactoring\n * - Self-documenting code\n * - No type assertions needed\n * - Schema is single source of truth\n *\n * This level of type safety is unique to Drizzle ORM!\n */\n// CLOSE: drizzle-type-safety-showcase\n\n/**\n * REF: advanced-drizzle-patterns\n *\n * ## Advanced Drizzle Patterns\n *\n * ## Complex Filtering\n * ```typescript\n * import { and, or, gt, lt, like } from 'drizzle-orm'\n *\n * const filtered = await db\n *   .select()\n *   .from(todos)\n *   .where(\n *     and(\n *       eq(todos.userId, userId),\n *       or(\n *         eq(todos.completed, false),\n *         gt(todos.updatedAt, yesterday)\n *       ),\n *       like(todos.title, '%important%')\n *     )\n *   )\n * ```\n *\n * ## Joins with Relations\n * ```typescript\n * const todosWithAttachments = await db.query.todos.findMany({\n *   where: eq(todos.userId, userId),\n *   with: {\n *     attachments: true,\n *   },\n * })\n *\n * // Nested structure automatically typed!\n * todosWithAttachments[0].attachments[0].fileName  // ‚úÖ string\n * ```\n *\n * ## Aggregations\n * ```typescript\n * import { count } from 'drizzle-orm'\n *\n * const stats = await db\n *   .select({\n *     total: count(),\n *     completed: count(todos.completed),\n *   })\n *   .from(todos)\n *   .where(eq(todos.userId, userId))\n * ```\n *\n * ## Transactions\n * ```typescript\n * await db.transaction(async (tx) => {\n *   await tx.insert(todos).values({ ... })\n *   await tx.update(userStats).set({ ... })\n * })\n * ```\n *\n * All of these are fully type-safe with perfect autocomplete!\n */\n// CLOSE: advanced-drizzle-patterns\n",
      "language": "typescript"
    },
    {
      "path": "app/feed/page.tsx",
      "content": "/**\n * REF: file-header\n *\n * # Public Feed Page - Type-Safe Public Todos with Drizzle ORM\n *\n * This page displays public todos using Drizzle ORM's type-safe queries with client-side\n * filtering capabilities.\n *\n * ## Architecture Highlights\n * - Drizzle ORM for type-safe database queries\n * - Client-side filtering for search and tags\n * - Type inference from schema definitions\n * - Hybrid Supabase + Drizzle approach (optional real-time)\n *\n * ## Type Safety Benefits\n * - `InferSelectModel<typeof todos>` provides exact type from schema\n * - TypeScript autocomplete for all todo properties\n * - Compile-time validation of field access\n * - No manual type definitions needed\n *\n * ## Drizzle Query Pattern\n * ```typescript\n * const results = await db\n *   .select()\n *   .from(todos)\n *   .where(eq(todos.isPublic, true))\n * // results is fully typed as Todo[]\n * ```\n */\n// CLOSE: file-header\n\n/**\n * REF: use-client-directive\n *\n * # Client Component Directive\n *\n * ## Why 'use client'?\n * This page requires client-side interactivity for:\n * - State management (filtering, search)\n * - User interactions (tag filtering)\n * - Dynamic UI updates\n * - Real-time subscriptions (optional)\n */\n'use client'\n// CLOSE: use-client-directive\n\n/**\n * REF: react-imports\n *\n * # React Hook Imports\n *\n * ## useState\n * Manages component state for:\n * - Public todos list\n * - Filtered todos list\n * - Search term\n * - Selected tag\n * - Loading state\n *\n * ## useEffect\n * Handles side effects for:\n * - Initial data fetch on mount\n * - Filter updates when dependencies change\n * - Optional real-time subscriptions\n */\nimport { useState, useEffect } from 'react'\n// CLOSE: react-imports\n\n/**\n * REF: drizzle-imports\n *\n * # Drizzle ORM Imports\n *\n * ## eq Operator\n * Used for WHERE clause equality comparisons in queries.\n *\n * ### Usage Example\n * ```typescript\n * .where(eq(todos.isPublic, true))\n * // Generates: WHERE is_public = true\n * ```\n *\n * ## Database Client (db)\n * Main Drizzle database connection for executing type-safe queries.\n *\n * ## Schema Definition (todos)\n * Table schema that provides structure and type information for queries.\n *\n * ## InferSelectModel\n * TypeScript utility that extracts the result type from a Drizzle table schema.\n */\nimport { eq } from 'drizzle-orm'\nimport { db } from '@/lib/db/client'\nimport { todos } from '@/lib/db/schema'\nimport { InferSelectModel } from 'drizzle-orm'\n// CLOSE: drizzle-imports\n\n/**\n * REF: todo-type\n *\n * # Todo Type from Schema\n *\n * ## Type Inference\n * `InferSelectModel` automatically generates the TypeScript type from the todos schema.\n *\n * ### Generated Type Structure\n * ```typescript\n * {\n *   id: string\n *   userId: string\n *   title: string\n *   description: string | null\n *   completed: boolean\n *   isPublic: boolean\n *   tags: string[] | null\n *   createdAt: Date\n *   updatedAt: Date\n * }\n * ```\n *\n * ### Benefits\n * - Single source of truth (schema)\n * - Automatic updates when schema changes\n * - No manual type maintenance\n * - Perfect accuracy\n */\ntype Todo = InferSelectModel<typeof todos>\n// CLOSE: todo-type\n\n/**\n * REF: feed-page-component\n *\n * # FeedPage Component\n *\n * Main component for displaying and filtering public todos.\n *\n * ## Responsibilities\n * - Fetch public todos from database\n * - Provide search functionality\n * - Enable tag-based filtering\n * - Display filtered results\n * - Show loading states\n */\nexport default function FeedPage() {\n  // CLOSE: feed-page-component\n\n  /**\n   * REF: component-state\n   *\n   * # Component State Management\n   *\n   * ## State Variables\n   *\n   * ### publicTodos (Todo[])\n   * - Complete list of all public todos from database\n   * - Source of truth for filtering operations\n   * - Updated on initial fetch\n   *\n   * ### filteredTodos (Todo[])\n   * - Subset of publicTodos after applying filters\n   * - Updated when search or tag filters change\n   * - Displayed in UI\n   *\n   * ### searchTerm (string)\n   * - Current search query\n   * - Filters by title and description\n   * - Case-insensitive matching\n   *\n   * ### selectedTag (string | null)\n   * - Currently active tag filter\n   * - null means no tag filter applied\n   * - Single tag selection at a time\n   *\n   * ### loading (boolean)\n   * - Indicates data fetching state\n   * - Prevents premature rendering\n   * - Shows loading indicator\n   */\n  const [publicTodos, setPublicTodos] = useState<Todo[]>([])\n  const [filteredTodos, setFilteredTodos] = useState<Todo[]>([])\n  const [searchTerm, setSearchTerm] = useState('')\n  const [selectedTag, setSelectedTag] = useState<string | null>(null)\n  const [loading, setLoading] = useState(true)\n  // CLOSE: component-state\n\n  /**\n   * REF: fetch-public-todos-effect\n   *\n   * # Fetch Public Todos Effect\n   *\n   * ## Purpose\n   * Load public todos from database on component mount.\n   *\n   * ## Drizzle Query Breakdown\n   * ```typescript\n   * const results = await db\n   *   .select()              // SELECT *\n   *   .from(todos)           // FROM todos\n   *   .where(eq(todos.isPublic, true))  // WHERE is_public = true\n   * ```\n   *\n   * ## Type Safety\n   * - results is automatically typed as Todo[]\n   * - No type assertions needed\n   * - IntelliSense shows all todo properties\n   *\n   * ## Error Handling\n   * - Try-catch for async errors\n   * - Log errors for debugging\n   * - Set loading false even on error\n   *\n   * ## Optional Real-Time Pattern\n   * Can add Supabase real-time subscriptions to refetch when data changes:\n   * ```typescript\n   * const supabase = createClient()\n   * const channel = supabase\n   *   .channel('public-todos')\n   *   .on('postgres_changes', {\n   *     event: '*',\n   *     schema: 'public',\n   *     table: 'todos',\n   *     filter: 'is_public=eq.true'\n   *   }, () => {\n   *     fetchPublicTodos() // Refetch with Drizzle\n   *   })\n   *   .subscribe()\n   * return () => supabase.removeChannel(channel)\n   * ```\n   *\n   * ## Dependencies\n   * Empty array [] means run once on mount only.\n   */\n  useEffect(() => {\n    const fetchPublicTodos = async () => {\n      try {\n        const results = await db\n          .select()\n          .from(todos)\n          .where(eq(todos.isPublic, true))\n\n        setPublicTodos(results)\n        setFilteredTodos(results)\n        setLoading(false)\n      } catch (error) {\n        console.error('Error fetching public todos:', error)\n        setLoading(false)\n      }\n    }\n\n    fetchPublicTodos()\n  }, [])\n  // CLOSE: fetch-public-todos-effect\n\n  /**\n   * REF: filtering-effect\n   *\n   * # Client-Side Filtering Effect\n   *\n   * ## Purpose\n   * Apply search and tag filters to public todos whenever filters change.\n   *\n   * ## Filter Logic Flow\n   * 1. Start with all publicTodos\n   * 2. Apply search term filter (if exists)\n   * 3. Apply tag filter (if exists)\n   * 4. Update filteredTodos state\n   *\n   * ## Search Filter\n   * - Trim and lowercase search term\n   * - Check title and description\n   * - Case-insensitive matching\n   * - Partial match supported\n   *\n   * ## Tag Filter\n   * - Check if todo.tags array includes selectedTag\n   * - Works with tags as string[]\n   *\n   * ## Type Safety\n   * TypeScript knows:\n   * - todo.title is string\n   * - todo.description is string | null\n   * - todo.tags is string[] | null\n   *\n   * ## Dependencies\n   * Re-run when: searchTerm, selectedTag, or publicTodos changes\n   */\n  useEffect(() => {\n    let results = publicTodos\n\n    if (searchTerm.trim()) {\n      const term = searchTerm.toLowerCase()\n      results = results.filter(\n        todo =>\n          todo.title?.toLowerCase().includes(term) ||\n          todo.description?.toLowerCase().includes(term)\n      )\n    }\n\n    if (selectedTag) {\n      results = results.filter(todo => todo.tags?.includes(selectedTag))\n    }\n\n    setFilteredTodos(results)\n  }, [searchTerm, selectedTag, publicTodos])\n  // CLOSE: filtering-effect\n\n  /**\n   * REF: tag-extraction\n   *\n   * # Extract Unique Tags\n   *\n   * ## Purpose\n   * Get all unique tags from public todos for filter UI.\n   *\n   * ## Process\n   * 1. flatMap extracts all tags from all todos\n   * 2. Set removes duplicates\n   * 3. Array.from converts Set to array\n   * 4. sort alphabetically orders tags\n   *\n   * ## Type Safety\n   * - publicTodos is Todo[]\n   * - todo.tags is string[] | null\n   * - flatMap with || [] handles null values\n   * - Result is string[]\n   */\n  const allTags = Array.from(\n    new Set(publicTodos.flatMap(todo => todo.tags || []))\n  ).sort()\n  // CLOSE: tag-extraction\n\n  /**\n   * REF: clear-filters-handler\n   *\n   * # Clear All Filters Handler\n   *\n   * ## Purpose\n   * Reset both search and tag filters to show all public todos.\n   *\n   * ## Actions\n   * - Clear search term\n   * - Clear selected tag\n   * - Triggers filtering effect automatically\n   */\n  const handleClearFilters = () => {\n    setSearchTerm('')\n    setSelectedTag(null)\n  }\n  // CLOSE: clear-filters-handler\n\n  /**\n   * REF: loading-state-render\n   *\n   * # Loading State UI\n   *\n   * ## Purpose\n   * Show loading indicator while fetching initial data.\n   *\n   * ## Display\n   * - Centered container\n   * - Min height ensures visibility\n   * - Simple text message\n   */\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-[400px]\">\n        <div className=\"text-xl\">Loading public feed...</div>\n      </div>\n    )\n  }\n  // CLOSE: loading-state-render\n\n  /**\n   * REF: main-render\n   *\n   * # Main Feed Render\n   *\n   * ## Layout Structure\n   * - Container with max width\n   * - Page header with title and description\n   * - Search input\n   * - Tag filter buttons\n   * - Active filters display\n   * - Results count\n   * - Todos grid\n   */\n  return (\n    <div className=\"max-w-6xl mx-auto\">\n      {/* CLOSE: main-render */}\n\n      {/**\n       * REF: page-header\n       *\n       * # Page Header\n       *\n       * ## Elements\n       * - Main title\n       * - Description with todo count\n       */}\n      <div className=\"mb-8\">\n        <h1 className=\"text-4xl font-bold mb-2\">Public Feed</h1>\n        <p className=\"text-gray-600 dark:text-gray-300\">\n          Discover todos shared by the community. {publicTodos.length} public todos.\n        </p>\n      </div>\n      {/* CLOSE: page-header */}\n\n      {/**\n       * REF: search-input\n       *\n       * # Search Input Field\n       *\n       * ## Features\n       * - Full width text input\n       * - Controlled component (value={searchTerm})\n       * - Updates on every keystroke\n       * - Placeholder text for UX\n       * - Dark mode support\n       * - Focus ring for accessibility\n       */}\n      <input\n        type=\"text\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        placeholder=\"Search todos...\"\n        className=\"w-full px-4 py-3 mb-6 border rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-gray-800\"\n      />\n      {/* CLOSE: search-input */}\n\n      {/**\n       * REF: tag-filters\n       *\n       * # Tag Filter Buttons\n       *\n       * ## Conditional Rendering\n       * Only shows if tags exist in the dataset.\n       *\n       * ## Tag Button Behavior\n       * - Click to select tag\n       * - Click again to deselect\n       * - Visual indication of selection (blue background)\n       * - Flex wrap for responsive layout\n       */}\n      {allTags.length > 0 && (\n        <div className=\"mb-6\">\n          <h3 className=\"text-sm font-medium mb-2\">Filter by tag:</h3>\n          <div className=\"flex flex-wrap gap-2\">\n            {allTags.map(tag => (\n              <button\n                key={tag}\n                onClick={() => setSelectedTag(selectedTag === tag ? null : tag)}\n                className={`px-4 py-2 rounded-full text-sm transition ${\n                  selectedTag === tag\n                    ? 'bg-blue-600 text-white'\n                    : 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300'\n                }`}\n              >\n                #{tag}\n              </button>\n            ))}\n          </div>\n        </div>\n      )}\n      {/* CLOSE: tag-filters */}\n\n      {/**\n       * REF: active-filters-display\n       *\n       * # Active Filters Display\n       *\n       * ## Purpose\n       * Show which filters are currently applied with option to clear.\n       *\n       * ## Conditional Rendering\n       * Only shows when at least one filter is active.\n       *\n       * ## Display\n       * - Blue background box\n       * - Shows active search term\n       * - Shows active tag\n       * - Clear all button\n       */}\n      {(searchTerm || selectedTag) && (\n        <div className=\"mb-6 p-4 bg-blue-50 dark:bg-blue-900 rounded-lg flex justify-between\">\n          <div>\n            <span className=\"font-medium\">Active filters:</span>\n            {searchTerm && <span className=\"ml-2 text-sm\">Search: \"{searchTerm}\"</span>}\n            {selectedTag && <span className=\"ml-2 text-sm\">Tag: #{selectedTag}</span>}\n          </div>\n          <button\n            onClick={handleClearFilters}\n            className=\"text-blue-600 dark:text-blue-300 hover:underline text-sm\"\n          >\n            Clear all\n          </button>\n        </div>\n      )}\n      {/* CLOSE: active-filters-display */}\n\n      {/**\n       * REF: results-count\n       *\n       * # Results Count Display\n       *\n       * Shows how many todos are currently displayed out of total.\n       */}\n      <div className=\"mb-4 text-gray-600 dark:text-gray-300\">\n        Showing {filteredTodos.length} of {publicTodos.length} todos\n      </div>\n      {/* CLOSE: results-count */}\n\n      {/**\n       * REF: todos-grid\n       *\n       * # Todos Grid Display\n       *\n       * ## Conditional Rendering\n       * - Shows grid if filteredTodos has items\n       * - Shows empty state if no results\n       *\n       * ## Grid Layout\n       * - 1 column on mobile\n       * - 2 columns on tablet (md)\n       * - 3 columns on desktop (lg)\n       * - Gap between cards\n       *\n       * ## Todo Card\n       * Each card displays:\n       * - Title\n       * - Description (if exists)\n       * - Tags (if exist)\n       * - Completion status\n       *\n       * ## Type Safety\n       * TypeScript knows exact structure of each todo from schema inference.\n       */}\n      {filteredTodos.length > 0 ? (\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n          {filteredTodos.map(todo => (\n            <div key={todo.id} className=\"p-6 bg-white dark:bg-gray-800 rounded-lg shadow-lg\">\n              <h3 className=\"text-lg font-bold mb-2\">{todo.title}</h3>\n\n              {todo.description && (\n                <p className=\"text-gray-600 dark:text-gray-300 mb-4 line-clamp-3\">\n                  {todo.description}\n                </p>\n              )}\n\n              {todo.tags && todo.tags.length > 0 && (\n                <div className=\"flex flex-wrap gap-2 mb-4\">\n                  {todo.tags.map(tag => (\n                    <span\n                      key={tag}\n                      className=\"px-2 py-1 bg-gray-100 dark:bg-gray-700 text-xs rounded-full\"\n                    >\n                      #{tag}\n                    </span>\n                  ))}\n                </div>\n              )}\n\n              <div className=\"text-sm text-gray-500\">\n                {todo.completed ? '‚úì Completed' : '‚óã In Progress'}\n              </div>\n            </div>\n          ))}\n        </div>\n      ) : (\n        <div className=\"text-center py-12 text-gray-500\">\n          No todos found\n        </div>\n      )}\n      {/* CLOSE: todos-grid */}\n    </div>\n  )\n}\n\n/**\n * REF: drizzle-query-patterns\n *\n * # Drizzle ORM Query Patterns\n *\n * ## Basic Public Query\n * ```typescript\n * const publicTodos = await db\n *   .select()\n *   .from(todos)\n *   .where(eq(todos.isPublic, true))\n *   .orderBy(desc(todos.createdAt))\n * ```\n *\n * ## With Multiple Conditions\n * ```typescript\n * import { and, eq } from 'drizzle-orm'\n *\n * const results = await db\n *   .select()\n *   .from(todos)\n *   .where(\n *     and(\n *       eq(todos.isPublic, true),\n *       eq(todos.completed, false)\n *     )\n *   )\n * ```\n *\n * ## With Ordering\n * ```typescript\n * import { desc } from 'drizzle-orm'\n *\n * const results = await db\n *   .select()\n *   .from(todos)\n *   .where(eq(todos.isPublic, true))\n *   .orderBy(desc(todos.createdAt))\n * ```\n *\n * ## With Limit\n * ```typescript\n * const results = await db\n *   .select()\n *   .from(todos)\n *   .where(eq(todos.isPublic, true))\n *   .limit(10)\n * ```\n */\n// CLOSE: drizzle-query-patterns\n\n/**\n * REF: advanced-filtering\n *\n * # Advanced Filtering with Drizzle\n *\n * ## Full-Text Search (Server-Side)\n * For production apps, move search to server for better performance:\n *\n * ```typescript\n * import { sql } from 'drizzle-orm'\n *\n * const results = await db\n *   .select()\n *   .from(todos)\n *   .where(\n *     sql`to_tsvector('english', ${todos.title} || ' ' || COALESCE(${todos.description}, ''))\n *         @@ plainto_tsquery('english', ${searchTerm})`\n *   )\n * ```\n *\n * ## Array Contains Filter\n * ```typescript\n * import { sql } from 'drizzle-orm'\n *\n * const results = await db\n *   .select()\n *   .from(todos)\n *   .where(sql`${todos.tags} @> ARRAY[${tag}]::text[]`)\n * ```\n *\n * ## Case-Insensitive Search\n * ```typescript\n * import { ilike } from 'drizzle-orm'\n *\n * const results = await db\n *   .select()\n *   .from(todos)\n *   .where(ilike(todos.title, `%${searchTerm}%`))\n * ```\n */\n// CLOSE: advanced-filtering\n\n/**\n * REF: type-safety-showcase\n *\n * # Type Safety in Action\n *\n * ## IntelliSense Benefits\n * When you type `todo.`, your IDE shows:\n * - id (string)\n * - userId (string)\n * - title (string)\n * - description (string | null)\n * - completed (boolean)\n * - isPublic (boolean)\n * - tags (string[] | null)\n * - createdAt (Date)\n * - updatedAt (Date)\n *\n * ## Compile-Time Errors\n * ```typescript\n * // ‚ùå TypeScript catches this:\n * todo.nonExistentField\n * // Error: Property 'nonExistentField' does not exist\n *\n * // ‚ùå TypeScript catches this:\n * const completed: string = todo.completed\n * // Error: Type 'boolean' is not assignable to type 'string'\n *\n * // ‚úÖ This works perfectly:\n * const title: string = todo.title\n * const tags: string[] | null = todo.tags\n * ```\n *\n * ## No Runtime Surprises\n * Because types match database exactly:\n * - No unexpected null values\n * - No type mismatches\n * - No undefined properties\n * - Perfect autocomplete\n */\n// CLOSE: type-safety-showcase\n",
      "language": "typescript"
    },
    {
      "path": "app/layout.tsx",
      "content": "/**\n * REF: file-header\n *\n * # Root Layout - Next.js Application Shell\n *\n * This is the root layout component that wraps the entire Next.js application. It's required\n * in the app directory and provides the foundational HTML structure.\n *\n * ## Purpose\n * - Define global HTML structure (html, body tags)\n * - Load and apply fonts\n * - Include global styles\n * - Wrap app with context providers\n * - Set metadata for SEO\n *\n * ## Architecture\n * This layout persists across page navigations and doesn't re-render, making it ideal for:\n * - Authentication providers\n * - Theme providers\n * - Global UI elements\n * - Font loading\n */\n// CLOSE: file-header\n\n/**\n * REF: type-imports\n *\n * ## TypeScript Type Imports\n *\n * ## Metadata Type\n * Type definition from Next.js for page metadata configuration.\n *\n * ### Why Type-Only Import?\n * - Doesn't affect bundle size\n * - Provides compile-time type checking\n * - Required for Next.js 13+ metadata API\n *\n * ### Usage\n * Used to type the metadata export that defines page title, description, and other SEO properties.\n */\nimport type { Metadata } from 'next'\n// CLOSE: type-imports\n\n/**\n * REF: font-optimization\n *\n * ## Next.js Font Optimization\n *\n * ## Inter Font from Google Fonts\n * Next.js provides automatic Google Fonts optimization through next/font/google.\n *\n * ### How It Works\n * 1. Font is downloaded at build time\n * 2. Self-hosted in your application (no Google request at runtime)\n * 3. Automatic font subsetting for smaller file sizes\n * 4. Zero layout shift with font-display: swap\n *\n * ### Configuration\n * - `subsets: ['latin']` - Only include Latin characters\n * - Significantly reduces font file size\n * - Can add more subsets if needed (cyrillic, greek, etc.)\n *\n * ### Performance Benefits\n * - No external font requests\n * - Reduced bandwidth usage\n * - Improved Core Web Vitals\n * - Better privacy (no Google tracking)\n */\nimport { Inter } from 'next/font/google'\n// CLOSE: font-optimization\n\n/**\n * REF: global-styles\n *\n * ## Global Styles Import\n *\n * ## Tailwind CSS Configuration\n * This import loads the global stylesheet that contains:\n * - Tailwind CSS base styles\n * - Tailwind component classes\n * - Tailwind utility classes\n * - Custom global CSS rules\n *\n * ### Loading Strategy\n * - Imported only in root layout\n * - Applies to entire application\n * - Contains Tailwind directives (@tailwind base, components, utilities)\n *\n * ### Why Only Here?\n * CSS is global by nature, so importing in the root layout ensures it's loaded once\n * and available everywhere without duplication.\n */\nimport './globals.css'\n// CLOSE: global-styles\n\n/**\n * REF: auth-provider-import\n *\n * ## Authentication Context Provider\n *\n * ## AuthProvider Component\n * React Context Provider that manages authentication state globally.\n *\n * ### What It Provides\n * - User authentication state\n * - Sign in method\n * - Sign out method\n * - Sign up method\n * - Loading state\n *\n * ### Integration\n * - Wraps Supabase auth\n * - Makes useAuth() hook available to all components\n * - Handles auth state changes automatically\n * - Manages JWT tokens and sessions\n *\n * ### Why in Root Layout?\n * Placing the provider here makes auth state available to every page and component\n * in the application without prop drilling.\n */\nimport { AuthProvider } from '@/contexts/AuthContext'\n// CLOSE: auth-provider-import\n\n/**\n * REF: font-instance\n *\n * ## Font Configuration Instance\n *\n * ## Creating Inter Font Instance\n * Creates a configured instance of the Inter font that can be applied to elements.\n *\n * ### Configuration\n * - `subsets: ['latin']` - Character set to include\n *\n * ### Usage Pattern\n * - Created once as module-level constant\n * - Applied via className in body element\n * - Next.js generates optimized CSS automatically\n * - Returns an object with className and style properties\n */\nconst inter = Inter({ subsets: ['latin'] })\n// CLOSE: font-instance\n\n/**\n * REF: metadata-export\n *\n * ## Metadata Export - SEO Configuration\n *\n * ## Next.js Metadata API\n * Static metadata that defines SEO properties for the application.\n *\n * ### Fields\n * - `title` - Page title shown in browser tab and search results\n * - `description` - Page description for search result snippets and social shares\n *\n * ### SEO Best Practices\n * - Title: 50-60 characters optimal for search results\n * - Description: 150-160 characters for Google snippet display\n * - Include relevant keywords naturally\n * - Accurately describe the page content\n *\n * ### How It Works\n * - Defined at build time\n * - Automatically converted to HTML meta tags\n * - Can be overridden in child pages\n * - Improves SEO and social sharing\n *\n * ### Social Sharing\n * These values are used by:\n * - Search engines (Google, Bing)\n * - Social platforms (Twitter, Facebook)\n * - Messaging apps with link previews\n */\nexport const metadata: Metadata = {\n  title: 'Todo App - Next.js + Supabase + Drizzle',\n  description: 'Full-stack todo app with type-safe database queries using Drizzle ORM',\n}\n// CLOSE: metadata-export\n\n/**\n * REF: root-layout-component\n *\n * ## RootLayout Component - Application Shell\n *\n * ## Required Root Layout\n * This is the required root layout for all Next.js 13+ applications.\n *\n * ### Component Type\n * - Server Component (default in Next.js 15)\n * - Renders on the server\n * - No client-side JavaScript needed for layout itself\n *\n * ### Requirements\n * - Must exist in app directory root\n * - Must include html and body tags\n * - Only place these tags can be defined\n *\n * ### Props\n * - `children` - All page content rendered inside this layout\n *\n * ### Behavior\n * - Wraps all pages and nested layouts\n * - Preserves state on navigation (doesn't re-render)\n * - Provides consistent structure across the app\n *\n * ### Provider Pattern\n * - AuthProvider wraps children for global auth state\n * - Makes useAuth() available everywhere\n * - Client components can consume server-rendered layout\n */\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <>\n      {/**\n       * REF: html-element\n       *\n       * # HTML Root Element\n       *\n       * ## Language Attribute\n       * The `lang` attribute specifies the document's language.\n       *\n       * ### Accessibility Benefits\n       * - Screen readers use this for proper pronunciation\n       * - Helps with text-to-speech engines\n       * - Required for WCAG 2.0 compliance\n       * - Supports browser translation features\n       *\n       * ### Values\n       * - \"en\" for English\n       * - \"es\" for Spanish\n       * - \"fr\" for French\n       * - Use ISO 639-1 codes\n       */}\n      <html lang=\"en\">\n        {/* CLOSE: html-element */}\n\n        {/**\n         * REF: body-element\n         *\n         * # Body Element with Font\n         *\n         * ## Font Application\n         * The `inter.className` applies the optimized Inter font.\n         *\n         * ### How It Works\n         * - `inter.className` returns a generated class name like \"__className_a1b2c3\"\n         * - Next.js automatically injects CSS for this class\n         * - CSS includes font-family and font-display settings\n         * - No Flash of Unstyled Text (FOUT) thanks to optimization\n         *\n         * ### Generated CSS\n         * Next.js generates something like:\n         * ```css\n         * .__className_a1b2c3 {\n         *   font-family: '__Inter_a1b2c3', sans-serif;\n         *   font-display: swap;\n         * }\n         * ```\n         */}\n        <body className={inter.className}>\n          {/* CLOSE: body-element */}\n\n          {/**\n           * REF: auth-provider-wrapper\n           *\n           * # AuthProvider Context Wrapper\n           *\n           * ## Global Authentication State\n           * Wraps the entire application with authentication context.\n           *\n           * ### What It Provides\n           * - `user` - Current authenticated user object or null\n           * - `loading` - Boolean indicating initial auth check\n           * - `signIn(email, password)` - Method to sign in\n           * - `signUp(email, password, metadata)` - Method to create account\n           * - `signOut()` - Method to sign out\n           *\n           * ### Implementation Details\n           * - Uses Supabase auth under the hood\n           * - Listens to auth state changes automatically\n           * - Provides type-safe auth methods\n           * - Integrates with Drizzle queries (use user.id for filtering)\n           *\n           * ### Usage in Components\n           * ```typescript\n           * import { useAuth } from '@/contexts/AuthContext'\n           *\n           * function MyComponent() {\n           *   const { user, signIn, signOut } = useAuth()\n           *\n           *   if (!user) return <div>Please sign in</div>\n           *\n           *   return <div>Welcome {user.email}</div>\n           * }\n           * ```\n           *\n           * ### Why Client Component?\n           * - AuthProvider uses React hooks (useState, useEffect)\n           * - Listens to Supabase auth state changes\n           * - Must be a client component\n           * - But wrapping server components is perfectly fine\n           *\n           * ### Server/Client Boundary\n           * - This is a client component\n           * - children can still be server components\n           * - React handles the boundary automatically\n           */}\n          <AuthProvider>\n            {children}\n          </AuthProvider>\n          {/* CLOSE: auth-provider-wrapper */}\n        </body>\n      </html>\n    </>\n  )\n}\n// CLOSE: root-layout-component\n\n/**\n * REF: architecture-notes\n *\n * ## Hybrid Architecture Notes\n *\n * ## Why Supabase + Drizzle?\n *\n * ### Supabase Strengths\n * - Best-in-class authentication system\n * - Easy file storage with S3-compatible API\n * - Real-time subscriptions via WebSockets\n * - Row Level Security for data protection\n * - Auto-generated REST API\n *\n * ### Drizzle Strengths\n * - Perfect TypeScript type inference\n * - SQL-like query syntax that's familiar\n * - Type-safe database operations\n * - Powerful migration system\n * - No code generation needed\n * - Better autocomplete than any ORM\n *\n * ### Best of Both Worlds\n * - Use Supabase for auth, storage, and real-time\n * - Use Drizzle for type-safe database queries\n * - Each tool does what it's best at\n * - Clean separation of concerns\n * - Maximum developer experience\n */\n// CLOSE: architecture-notes\n",
      "language": "typescript"
    },
    {
      "path": "app/messages/page.tsx",
      "content": "/**\n * REF: file-header\n *\n * # Messages Page - Real-time Chat with Drizzle Queries\n *\n * Real-time messaging using Supabase Realtime + Drizzle type-safe queries.\n *\n * ## Architecture Pattern\n * This page demonstrates the hybrid approach:\n * - **Drizzle**: Type-safe database operations\n * - **Supabase**: Real-time broadcasts\n * - **Combine**: Best of both worlds\n *\n * ## Key Benefits\n * | Feature | `Tool` | Benefit |\n * |---------|------|---------|\n * | `Queries` | `Drizzle` | Perfect type inference |\n * | Real-time | `Supabase` | Instant updates |\n * | Type safety | `Drizzle` | Compile-time validation |\n * | `Subscriptions` | `Supabase` | WebSocket connections |\n */\n// CLOSE: file-header\n\n'use client'\n\n/**\n * REF: imports\n *\n * ## Import Dependencies\n *\n * ### React Hooks\n * - `useState`: Form state and messages array\n * - `useEffect`: Loading data and subscriptions\n * - `useRef`: Scroll management\n *\n * ### Custom Hooks\n * - `useAuth`: Get current user from context\n *\n * ### Database Layer\n * - `createClient`: Supabase client for real-time\n * - `getConversation`: Drizzle query for messages\n * - `sendMessage`: Drizzle mutation for creating messages\n * - `markMessageAsRead`: Drizzle mutation for read status\n */\nimport { useState, useEffect, useRef } from 'react'\nimport { useAuth } from '@/contexts/AuthContext'\nimport { createClient } from '@/lib/supabase/client'\nimport { getConversation, sendMessage, markMessageAsRead } from '@/lib/db/queries'\n// CLOSE: imports\n\n/**\n * REF: component-function\n *\n * ## MessagesPage Component\n *\n * Main page component for real-time messaging interface.\n */\nexport default function MessagesPage() {\n  const { user } = useAuth()\n  const supabase = createClient()\n  // CLOSE: component-function\n\n  /**\n   * REF: state-management\n   *\n   * ## State Variables\n   *\n   * | `State` | Type | Purpose |\n   * |-------|------|---------|\n   * | `users` | `any[]` | List of available users to message |\n   * | `selectedUserId` | `string \\| null` | Currently selected conversation |\n   * | `messages` | `any[]` | Messages in current conversation |\n   * | `newMessage` | `string` | Input field value |\n   * | `loading` | `boolean` | Initial loading state |\n   * | `sending` | `boolean` | Message send in progress |\n   * | `messagesEndRef` | `RefObject` | Ref for auto-scrolling |\n   */\n  const [users, setUsers] = useState<any[]>([])\n  const [selectedUserId, setSelectedUserId] = useState<string | null>(null)\n  const [messages, setMessages] = useState<any[]>([])\n  const [newMessage, setNewMessage] = useState('')\n  const [loading, setLoading] = useState(true)\n  const [sending, setSending] = useState(false)\n\n  const messagesEndRef = useRef<HTMLDivElement>(null)\n  // CLOSE: state-management\n\n  /**\n   * REF: fetch-users-effect\n   *\n   * ## Fetch Users Effect\n   *\n   * Loads list of users available for messaging.\n   *\n   * ### Using Drizzle Alternative\n   * Could use type-safe Drizzle query:\n   * ```typescript\n   * import { userProfiles } from '@/lib/db/schema'\n   * import { ne } from 'drizzle-orm'\n   *\n   * const users = await db\n   *   .select()\n   *   .from(userProfiles)\n   *   .where(ne(userProfiles.userId, currentUserId))\n   * ```\n   *\n   * ### Current Implementation\n   * Uses Supabase client for simplicity in this example.\n   */\n  useEffect(() => {\n    if (!user) return\n\n    const fetchUsers = async () => {\n      const { data } = await supabase\n        .from('user_profiles')\n        .select('id, user_id, display_name')\n        .neq('user_id', user.id)\n\n      setUsers(data || [])\n      setLoading(false)\n    }\n\n    fetchUsers()\n  }, [user, supabase])\n  // CLOSE: fetch-users-effect\n\n  /**\n   * REF: conversation-effect\n   *\n   * ## Load Conversation Effect\n   *\n   * Loads messages and sets up real-time subscription when user selects conversation.\n   *\n   * ### Hybrid Pattern Flow\n   * 1. **Initial Load**: Use Drizzle's `getConversation()` for type-safe fetch\n   * 2. **Mark as Read**: Use Drizzle's `markMessageAsRead()` mutation\n   * 3. **Subscribe**: Use Supabase for real-time PostgreSQL changes\n   * 4. **Refetch**: On new messages, refetch with Drizzle\n   */\n  useEffect(() => {\n    if (!user || !selectedUserId) {\n      setMessages([])\n      return\n    }\n\n    /**\n     * REF: load-messages\n     *\n     * ## Load Messages Function\n     *\n     * Uses Drizzle query helper for type-safe message fetching.\n     *\n     * ### Benefits\n     * - Perfect type inference\n     * - SQL-like syntax\n     * - Compile-time validation\n     */\n    const loadMessages = async () => {\n      try {\n        const conversation = await getConversation(user.id, selectedUserId)\n        setMessages(conversation)\n\n        // Mark unread messages as read\n        conversation.forEach(msg => {\n          if (msg.recipientId === user.id && !msg.read) {\n            markMessageAsRead(msg.id)\n          }\n        })\n\n        scrollToBottom()\n      } catch (error) {\n        console.error('Error loading messages:', error)\n      }\n    }\n    // CLOSE: load-messages\n\n    loadMessages()\n\n    /**\n     * REF: realtime-subscription\n     *\n     * ## Real-time Subscription Setup\n     *\n     * Listen for new messages and refetch with Drizzle.\n     *\n     * ### Hybrid Pattern Benefits\n     * - Supabase broadcasts changes instantly\n     * - Drizzle fetches with type safety\n     * - Best of both worlds\n     *\n     * ### How It Works\n     * 1. Supabase detects INSERT on messages table\n     * 2. Triggers callback via WebSocket\n     * 3. Callback re-fetches with type-safe Drizzle query\n     * 4. UI updates with new message\n     */\n    const channel = supabase\n      .channel('messages')\n      .on('postgres_changes', {\n        event: 'INSERT',\n        schema: 'public',\n        table: 'messages',\n      }, () => {\n        loadMessages() // Refetch with Drizzle\n      })\n      .subscribe()\n\n    return () => {\n      supabase.removeChannel(channel)\n    }\n    // CLOSE: realtime-subscription\n  }, [user, selectedUserId, supabase])\n  // CLOSE: conversation-effect\n\n  /**\n   * REF: send-message-handler\n   *\n   * ## Send Message Handler\n   *\n   * Handles form submission for sending new messages.\n   *\n   * ### Type-Safe Creation\n   * Uses Drizzle's `sendMessage()` helper with full type validation:\n   * - `userId` validated as string\n   * - `recipientId` validated as string\n   * - `content` validated as string\n   *\n   * ### Process\n   * 1. Validate input\n   * 2. Set loading state\n   * 3. Call type-safe mutation\n   * 4. Clear form on success\n   * 5. Handle errors\n   */\n  const handleSendMessage = async (e: React.FormEvent) => {\n    e.preventDefault()\n\n    if (!user || !selectedUserId || !newMessage.trim()) return\n\n    setSending(true)\n\n    try {\n      await sendMessage(user.id, selectedUserId, newMessage.trim())\n      setNewMessage('')\n      scrollToBottom()\n    } catch (error) {\n      console.error('Error sending:', error)\n      alert('Failed to send message')\n    } finally {\n      setSending(false)\n    }\n  }\n  // CLOSE: send-message-handler\n\n  /**\n   * REF: scroll-helper\n   *\n   * ## Scroll to Bottom Helper\n   *\n   * Smoothly scrolls to latest message.\n   */\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })\n  }\n  // CLOSE: scroll-helper\n\n  /**\n   * REF: loading-state\n   *\n   * ## Loading State UI\n   *\n   * Shows loading indicator while fetching initial data.\n   */\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <div>Loading...</div>\n      </div>\n    )\n  }\n  // CLOSE: loading-state\n\n  const selectedUser = users.find(u => u.user_id === selectedUserId)\n\n  /**\n   * REF: main-layout\n   *\n   * ## Main Messages Layout\n   *\n   * Two-column layout with user list and conversation view.\n   */\n  return (\n    <div className=\"max-w-6xl mx-auto\">\n      <h1 className=\"text-4xl font-bold mb-8\">Messages</h1>\n\n      <div className=\"grid grid-cols-4 gap-6 h-[600px]\">\n        {/**\n         * REF: user-list\n         *\n         * ## User List Sidebar\n         *\n         * Shows all available users to start conversations with.\n         */}\n        <div className=\"col-span-1 bg-white dark:bg-gray-800 rounded-lg shadow overflow-y-auto\">\n          <div className=\"p-4 border-b\">\n            <h2 className=\"font-semibold\">Users</h2>\n          </div>\n\n          {users.map(u => (\n            <button\n              key={u.id}\n              onClick={() => setSelectedUserId(u.user_id)}\n              className={`w-full p-4 text-left hover:bg-gray-50 dark:hover:bg-gray-700 ${\n                selectedUserId === u.user_id ? 'bg-blue-50 dark:bg-blue-900' : ''\n              }`}\n            >\n              <div className=\"font-medium\">{u.display_name || 'User'}</div>\n            </button>\n          ))}\n        </div>\n        {/* CLOSE: user-list */}\n\n        {/**\n         * REF: conversation-view\n         *\n         * ## Conversation View\n         *\n         * Shows messages and input for selected conversation.\n         */}\n        <div className=\"col-span-3 bg-white dark:bg-gray-800 rounded-lg shadow flex flex-col\">\n          {selectedUser ? (\n            <>\n              {/**\n               * REF: conversation-header\n               *\n               * ## Conversation Header\n               *\n               * Shows selected user's name.\n               */}\n              <div className=\"p-4 border-b\">\n                <h2 className=\"font-semibold\">{selectedUser.display_name || 'User'}</h2>\n              </div>\n              {/* CLOSE: conversation-header */}\n\n              {/**\n               * REF: messages-list\n               *\n               * ## Messages List\n               *\n               * Scrollable list of messages in conversation.\n               *\n               * ### Message Display\n               * - Sent messages: Right-aligned, blue background\n               * - Received messages: Left-aligned, gray background\n               * - Timestamps shown below each message\n               * - Read receipts for sent messages\n               */}\n              <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n                {messages.map(msg => (\n                  <div\n                    key={msg.id}\n                    className={`flex ${msg.senderId === user?.id ? 'justify-end' : 'justify-start'}`}\n                  >\n                    <div\n                      className={`max-w-[70%] px-4 py-2 rounded-lg ${\n                        msg.senderId === user?.id\n                          ? 'bg-blue-600 text-white'\n                          : 'bg-gray-200 dark:bg-gray-700'\n                      }`}\n                    >\n                      <p>{msg.content}</p>\n                      <div className=\"text-xs mt-1 opacity-70\">\n                        {new Date(msg.createdAt).toLocaleTimeString()}\n                        {msg.senderId === user?.id && msg.read && ' ‚Ä¢ Read'}\n                      </div>\n                    </div>\n                  </div>\n                ))}\n                <div ref={messagesEndRef} />\n              </div>\n              {/* CLOSE: messages-list */}\n\n              {/**\n               * REF: message-form\n               *\n               * ## Message Input Form\n               *\n               * Form for typing and sending new messages.\n               */}\n              <form onSubmit={handleSendMessage} className=\"p-4 border-t\">\n                <div className=\"flex gap-2\">\n                  <input\n                    type=\"text\"\n                    value={newMessage}\n                    onChange={(e) => setNewMessage(e.target.value)}\n                    placeholder=\"Type a message...\"\n                    className=\"flex-1 px-4 py-2 border rounded-lg dark:bg-gray-700\"\n                  />\n                  <button\n                    type=\"submit\"\n                    disabled={sending || !newMessage.trim()}\n                    className=\"px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400\"\n                  >\n                    Send\n                  </button>\n                </div>\n              </form>\n              {/* CLOSE: message-form */}\n            </>\n          ) : (\n            <div className=\"flex items-center justify-center h-full text-gray-500\">\n              Select a user to start messaging\n            </div>\n          )}\n        </div>\n        {/* CLOSE: conversation-view */}\n      </div>\n    </div>\n  )\n  // CLOSE: main-layout\n}\n\n/**\n * REF: drizzle-query-examples\n *\n * ## Drizzle Message Query Examples\n *\n * From `lib/db/queries.ts`, showing type-safe message operations.\n *\n * ### Get Conversation Query\n * ```typescript\n * export async function getConversation(userId: string, otherUserId: string) {\n *   return await db\n *     .select()\n *     .from(messages)\n *     .where(\n *       sql`(${messages.senderId} = ${userId} AND ${messages.recipientId} = ${otherUserId})\n *        OR (${messages.senderId} = ${otherUserId} AND ${messages.recipientId} = ${userId})`\n *     )\n *     .orderBy(messages.createdAt)\n * }\n * ```\n *\n * ### Send Message Mutation\n * ```typescript\n * export async function sendMessage(\n *   senderId: string,\n *   recipientId: string,\n *   content: string\n * ) {\n *   const [message] = await db\n *     .insert(messages)\n *     .values({ senderId, recipientId, content })\n *     .returning()\n *\n *   return message\n * }\n * ```\n *\n * ### Benefits\n * - Fully typed parameters\n * - SQL power with type safety\n * - Compile-time error checking\n * - Perfect IDE autocomplete\n */\n// CLOSE: drizzle-query-examples\n",
      "language": "typescript"
    },
    {
      "path": "app/page.tsx",
      "content": "/**\n * REF: landing-page-file\n *\n * # Landing Page - Drizzle ORM Project\n *\n * Home page showcasing the Drizzle + Supabase combination.\n *\n * ## Purpose\n *\n * - Marketing/landing page for the todo application\n * - Showcases the tech stack (Next.js, Supabase, Drizzle ORM)\n * - Provides navigation to authentication pages\n * - Displays feature highlights\n *\n * ## Architecture Decision\n *\n * This page is a **Server Component** (Next.js 15 default):\n * - No client-side JavaScript needed\n * - Rendered at build time (Static Generation)\n * - Optimal performance and SEO\n * - Perfect for landing pages with no interactivity\n *\n * ## Tech Stack\n *\n * | `Technology` | Purpose | `Why` |\n * |------------|---------|-----|\n * | Next.js 15 | `Framework` | App Router, Server Components |\n * | `Supabase` | `Backend` | Auth, Storage, Real-time |\n * | Drizzle ORM | `Database` | Type-safe queries |\n * | `PostgreSQL` | `Database` | Production-ready SQL |\n * | `TypeScript` | `Language` | Type safety |\n */\n\nimport Link from 'next/link'\n// CLOSE: landing-page-file\n\n/**\n * REF: home-component\n *\n * ## Home Component\n *\n * Server Component for landing page.\n *\n * ### Component Type\n *\n * - **Server Component** - No 'use client' directive\n * - **Static Generation** - Rendered at build time\n * - **Zero JavaScript** - No client-side interactivity\n */\nexport default function Home() {\n  /**\n   * REF: landing-page-layout\n   *\n   * ## Landing Page Layout\n   *\n   * Centered full-height layout with hero section.\n   *\n   * ### Layout Classes\n   *\n   * - `flex min-h-screen` - Full viewport height flexbox\n   * - `flex-col items-center justify-center` - Vertical centering\n   * - `p-24` - Large padding\n   */\n  return (\n    <main className=\"flex min-h-screen flex-col items-center justify-center p-24\">\n      {/* CLOSE: landing-page-layout */}\n\n      {/**\n       * REF: hero-section\n       *\n       * ## Hero Section\n       *\n       * Main content container with constrained width.\n       */}\n      <div className=\"max-w-2xl text-center\">\n        {/* CLOSE: hero-section */}\n\n        {/**\n         * REF: hero-title\n         *\n         * ## Hero Title\n         *\n         * Large, bold heading to grab attention.\n         */}\n        <h1 className=\"text-5xl font-bold mb-6\">\n          Welcome to Todo App\n        </h1>\n        {/* CLOSE: hero-title */}\n\n        {/**\n         * REF: hero-subtitle\n         *\n         * ## Hero Subtitle\n         *\n         * Explains the tech stack and value proposition.\n         */}\n        <p className=\"text-xl text-gray-600 dark:text-gray-300 mb-8\">\n          A type-safe todo application built with Next.js, Supabase, and Drizzle ORM\n          featuring perfect TypeScript inference and SQL-like queries.\n        </p>\n        {/* CLOSE: hero-subtitle */}\n\n        {/**\n         * REF: cta-buttons\n         *\n         * ## Call-to-Action Buttons\n         *\n         * Sign In and Sign Up navigation links.\n         *\n         * ### Button Styling\n         *\n         * | `Button` | `Color` | Purpose |\n         * |--------|-------|---------|\n         * | Sign In | `Blue` | Primary action |\n         * | Sign Up | `Gray` | Secondary action |\n         */}\n        <div className=\"flex gap-4 justify-center\">\n          <Link\n            href=\"/signin\"\n            className=\"px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition\"\n          >\n            Sign In\n          </Link>\n\n          <Link\n            href=\"/signup\"\n            className=\"px-6 py-3 bg-gray-200 dark:bg-gray-700 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600 transition\"\n          >\n            Sign Up\n          </Link>\n        </div>\n        {/* CLOSE: cta-buttons */}\n\n        {/**\n         * REF: features-grid\n         *\n         * ## Features Grid\n         *\n         * Highlights key features of the application.\n         *\n         * ### Grid Layout\n         *\n         * - **Mobile**: 1 column (stacked)\n         * - **Desktop**: 2 columns (2x2 grid)\n         * - **Gap**: 1.5rem spacing\n         */}\n        <div className=\"mt-12 grid grid-cols-1 md:grid-cols-2 gap-6 text-left\">\n          {/**\n           * REF: feature-card-1\n           *\n           * ### Feature: Type-Safe Queries\n           *\n           * Drizzle ORM provides TypeScript inference.\n           */}\n          <div className=\"p-6 bg-white dark:bg-gray-800 rounded-lg shadow\">\n            <h3 className=\"font-bold text-lg mb-2\">Type-Safe Queries</h3>\n            <p className=\"text-gray-600 dark:text-gray-300\">\n              Drizzle ORM provides perfect TypeScript inference for all database operations.\n            </p>\n          </div>\n          {/* CLOSE: feature-card-1 */}\n\n          {/**\n           * REF: feature-card-2\n           *\n           * ### Feature: SQL-Like Syntax\n           *\n           * Familiar SQL patterns with type safety.\n           */}\n          <div className=\"p-6 bg-white dark:bg-gray-800 rounded-lg shadow\">\n            <h3 className=\"font-bold text-lg mb-2\">SQL-Like Syntax</h3>\n            <p className=\"text-gray-600 dark:text-gray-300\">\n              Write queries that look like SQL but with full type safety.\n            </p>\n          </div>\n          {/* CLOSE: feature-card-2 */}\n\n          {/**\n           * REF: feature-card-3\n           *\n           * ### Feature: Supabase Auth\n           *\n           * Best-in-class authentication.\n           */}\n          <div className=\"p-6 bg-white dark:bg-gray-800 rounded-lg shadow\">\n            <h3 className=\"font-bold text-lg mb-2\">Supabase Auth</h3>\n            <p className=\"text-gray-600 dark:text-gray-300\">\n              Best-in-class authentication and storage from Supabase.\n            </p>\n          </div>\n          {/* CLOSE: feature-card-3 */}\n\n          {/**\n           * REF: feature-card-4\n           *\n           * ### Feature: Migration System\n           *\n           * Built-in database migrations with Drizzle Kit.\n           */}\n          <div className=\"p-6 bg-white dark:bg-gray-800 rounded-lg shadow\">\n            <h3 className=\"font-bold text-lg mb-2\">Migration System</h3>\n            <p className=\"text-gray-600 dark:text-gray-300\">\n              Built-in database migrations with Drizzle Kit.\n            </p>\n          </div>\n          {/* CLOSE: feature-card-4 */}\n        </div>\n        {/* CLOSE: features-grid */}\n\n        {/**\n         * REF: tech-stack-footer\n         *\n         * ## Tech Stack Display\n         *\n         * Lists all technologies used.\n         */}\n        <div className=\"mt-12 text-sm text-gray-500\">\n          <p>Built with Next.js 15 ‚Ä¢ Supabase ‚Ä¢ Drizzle ORM ‚Ä¢ PostgreSQL ‚Ä¢ TypeScript</p>\n        </div>\n        {/* CLOSE: tech-stack-footer */}\n      </div>\n    </main>\n  )\n}\n// CLOSE: home-component\n",
      "language": "typescript"
    },
    {
      "path": "app/settings/page.tsx",
      "content": "/**\n * REF: file-header\n *\n * # Settings Page - User Preferences with Drizzle\n *\n * User settings management with type-safe Drizzle queries.\n *\n * ## Architecture\n * - **Drizzle**: Update operations for settings\n * - **Supabase Storage**: File uploads (avatar)\n * - **Hybrid**: Each tool for its strength\n *\n * ## Features\n * | Feature | `Implementation` | Benefit |\n * |---------|----------------|---------|\n * | Settings updates | Drizzle ORM | Type-safe mutations |\n * | File uploads | Supabase Storage | Easy CDN integration |\n * | Theme toggle | Real-time DOM updates | Instant UI changes |\n * | `Accessibility` | Settings persistence | Better UX |\n */\n// CLOSE: file-header\n\n'use client'\n\n/**\n * REF: imports\n *\n * ## Import Dependencies\n *\n * ### React Hooks\n * - `useState`: Form state management\n * - `useEffect`: Load settings and apply to DOM\n *\n * ### Custom Hooks & Clients\n * - `useAuth`: Get current user\n * - `getUserSettings`: Drizzle query\n * - `updateUserSettings`: Drizzle mutation\n * - `createClient`: Supabase for file uploads\n */\nimport { useState, useEffect } from 'react'\nimport { useAuth } from '@/contexts/AuthContext'\nimport { getUserSettings, updateUserSettings } from '@/lib/db/queries'\nimport { createClient } from '@/lib/supabase/client'\n// CLOSE: imports\n\n/**\n * REF: component-function\n *\n * ## SettingsPage Component\n *\n * Main page component for user settings management.\n */\nexport default function SettingsPage() {\n  const { user } = useAuth()\n  const supabase = createClient()\n  // CLOSE: component-function\n\n  /**\n   * REF: state-management\n   *\n   * ## State Variables\n   *\n   * | `State` | Type | Purpose |\n   * |-------|------|---------|\n   * | `settings` | `any \\| null` | Current user settings from database |\n   * | `displayName` | `string` | User's display name |\n   * | `loading` | `boolean` | Initial load state |\n   * | `saving` | `boolean` | Update in progress |\n   * | `uploading` | `boolean` | File upload in progress |\n   * | `message` | `string` | Success/error message to user |\n   */\n  const [settings, setSettings] = useState<any>(null)\n  const [displayName, setDisplayName] = useState('')\n  const [loading, setLoading] = useState(true)\n  const [saving, setSaving] = useState(false)\n  const [uploading, setUploading] = useState(false)\n  const [message, setMessage] = useState('')\n  // CLOSE: state-management\n\n  /**\n   * REF: load-settings-effect\n   *\n   * ## Load Settings Effect\n   *\n   * Fetches user settings with type-safe Drizzle query.\n   *\n   * ### Using Drizzle\n   * `getUserSettings()` provides full type safety for the returned settings object.\n   */\n  useEffect(() => {\n    if (!user) return\n\n    const loadSettings = async () => {\n      try {\n        const userSettings = await getUserSettings(user.id)\n        if (userSettings) {\n          setSettings(userSettings)\n        }\n        setLoading(false)\n      } catch (error) {\n        console.error('Error loading settings:', error)\n        setLoading(false)\n      }\n    }\n\n    loadSettings()\n  }, [user])\n  // CLOSE: load-settings-effect\n\n  /**\n   * REF: apply-settings-effect\n   *\n   * ## Apply Settings to DOM Effect\n   *\n   * Applies settings to document body classes for immediate visual changes.\n   *\n   * ### DOM Manipulations\n   * - Theme: Toggle `dark` class\n   * - Font size: Apply `font-{size}` class\n   * - High contrast: Toggle `high-contrast` class\n   * - Reduced motion: Toggle `reduced-motion` class\n   */\n  useEffect(() => {\n    if (!settings) return\n\n    const body = document.body\n\n    body.classList.toggle('dark', settings.theme === 'dark')\n    body.classList.remove('font-small', 'font-medium', 'font-large')\n    body.classList.add(`font-${settings.fontSize}`)\n    body.classList.toggle('high-contrast', settings.highContrast)\n    body.classList.toggle('reduced-motion', settings.reducedMotion)\n  }, [settings])\n  // CLOSE: apply-settings-effect\n\n  /**\n   * REF: update-setting-handler\n   *\n   * ## Update Setting Handler\n   *\n   * Handles updating individual settings with Drizzle.\n   *\n   * ### Type-Safe Update\n   * `updateUserSettings()` accepts `Partial<Settings>` for type-checked updates.\n   *\n   * ### Optimistic Updates\n   * - Updates UI immediately\n   * - Reverts on error\n   * - Better UX with instant feedback\n   */\n  const handleUpdateSetting = async (field: string, value: any) => {\n    if (!user || !settings) return\n\n    const previousSettings = { ...settings }\n    setSettings({ ...settings, [field]: value })\n\n    try {\n      await updateUserSettings(user.id, { [field]: value })\n      setMessage('Settings saved!')\n      setTimeout(() => setMessage(''), 2000)\n    } catch (error) {\n      setSettings(previousSettings)\n      setMessage('Failed to save settings')\n      console.error(error)\n    }\n  }\n  // CLOSE: update-setting-handler\n\n  /**\n   * REF: profile-picture-upload\n   *\n   * ## Profile Picture Upload Handler\n   *\n   * Uses Supabase Storage for file uploads.\n   *\n   * ### Why Supabase Storage?\n   * - Easier than implementing storage with Drizzle\n   * - Built-in CDN\n   * - Public URL generation\n   * - Access control integration\n   *\n   * ### Upload Flow\n   * 1. Validate file type\n   * 2. Generate unique filename\n   * 3. Upload to Supabase Storage bucket\n   * 4. Get public URL\n   * 5. Update UI\n   */\n  const handleProfilePictureUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (!user || !e.target.files?.[0]) return\n\n    const file = e.target.files[0]\n\n    if (!file.type.startsWith('image/')) {\n      setMessage('Please select an image')\n      return\n    }\n\n    setUploading(true)\n\n    try {\n      const filename = `${Date.now()}_${file.name}`\n      const path = `profile-pictures/${user.id}/${filename}`\n\n      const { error: uploadError } = await supabase.storage\n        .from('avatars')\n        .upload(path, file)\n\n      if (uploadError) throw uploadError\n\n      const { data: { publicUrl } } = supabase.storage\n        .from('avatars')\n        .getPublicUrl(path)\n\n      setMessage('Profile picture updated!')\n      setTimeout(() => setMessage(''), 2000)\n    } catch (error: any) {\n      setMessage(error.message || 'Failed to upload')\n      console.error(error)\n    } finally {\n      setUploading(false)\n    }\n  }\n  // CLOSE: profile-picture-upload\n\n  /**\n   * REF: loading-state\n   *\n   * ## Loading State UI\n   *\n   * Shows loading indicator during initial settings fetch.\n   */\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <div>Loading...</div>\n      </div>\n    )\n  }\n  // CLOSE: loading-state\n\n  /**\n   * REF: no-settings-state\n   *\n   * ## No Settings State\n   *\n   * Handles case where settings don't exist for user.\n   */\n  if (!settings) return <div>Settings not found</div>\n  // CLOSE: no-settings-state\n\n  /**\n   * REF: main-layout\n   *\n   * ## Main Settings Layout\n   *\n   * Settings page with multiple sections.\n   */\n  return (\n    <div className=\"max-w-3xl mx-auto\">\n      <h1 className=\"text-4xl font-bold mb-8\">Settings</h1>\n\n      {/**\n       * REF: message-display\n       *\n       * ## Message Display\n       *\n       * Shows success/error messages to user.\n       */}\n      {message && (\n        <div className={`mb-6 p-4 rounded-lg ${\n          message.includes('success') || message.includes('saved') || message.includes('updated')\n            ? 'bg-green-100 text-green-800'\n            : 'bg-red-100 text-red-800'\n        }`}>\n          {message}\n        </div>\n      )}\n      {/* CLOSE: message-display */}\n\n      {/**\n       * REF: profile-section\n       *\n       * ## Profile Section\n       *\n       * User profile settings including avatar upload.\n       */}\n      <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-6\">\n        <h2 className=\"text-2xl font-bold mb-4\">Profile</h2>\n\n        <div className=\"space-y-4\">\n          <div>\n            <label className=\"block text-sm font-medium mb-2\">Profile Picture</label>\n            <input\n              type=\"file\"\n              accept=\"image/*\"\n              onChange={handleProfilePictureUpload}\n              disabled={uploading}\n              className=\"w-full\"\n            />\n          </div>\n        </div>\n      </div>\n      {/* CLOSE: profile-section */}\n\n      {/**\n       * REF: appearance-section\n       *\n       * ## Appearance Section\n       *\n       * Theme and font size settings.\n       */}\n      <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-6\">\n        <h2 className=\"text-2xl font-bold mb-4\">Appearance</h2>\n\n        <div className=\"space-y-4\">\n          {/**\n           * REF: theme-setting\n           *\n           * ## Theme Setting\n           *\n           * Light/dark mode toggle.\n           */}\n          <div>\n            <label className=\"block text-sm font-medium mb-2\">Theme</label>\n            <div className=\"flex gap-4\">\n              {['light', 'dark'].map(theme => (\n                <button\n                  key={theme}\n                  onClick={() => handleUpdateSetting('theme', theme)}\n                  className={`px-6 py-3 rounded-lg border-2 capitalize ${\n                    settings.theme === theme\n                      ? 'border-blue-600 bg-blue-50 dark:bg-blue-900'\n                      : 'border-gray-300'\n                  }`}\n                >\n                  {theme}\n                </button>\n              ))}\n            </div>\n          </div>\n          {/* CLOSE: theme-setting */}\n\n          {/**\n           * REF: font-size-setting\n           *\n           * ## Font Size Setting\n           *\n           * Small/medium/large font options.\n           */}\n          <div>\n            <label className=\"block text-sm font-medium mb-2\">Font Size</label>\n            <div className=\"flex gap-4\">\n              {['small', 'medium', 'large'].map(size => (\n                <button\n                  key={size}\n                  onClick={() => handleUpdateSetting('fontSize', size)}\n                  className={`px-6 py-3 rounded-lg border-2 capitalize ${\n                    settings.fontSize === size\n                      ? 'border-blue-600 bg-blue-50 dark:bg-blue-900'\n                      : 'border-gray-300'\n                  }`}\n                >\n                  {size}\n                </button>\n              ))}\n            </div>\n          </div>\n          {/* CLOSE: font-size-setting */}\n        </div>\n      </div>\n      {/* CLOSE: appearance-section */}\n\n      {/**\n       * REF: accessibility-section\n       *\n       * ## Accessibility Section\n       *\n       * High contrast and reduced motion toggles.\n       */}\n      <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow p-6\">\n        <h2 className=\"text-2xl font-bold mb-4\">Accessibility</h2>\n\n        <div className=\"space-y-4\">\n          {/**\n           * REF: high-contrast-toggle\n           *\n           * ## High Contrast Toggle\n           *\n           * Toggle for increased color contrast.\n           */}\n          <div className=\"flex items-center justify-between p-4 border rounded-lg\">\n            <div>\n              <h3 className=\"font-medium\">High Contrast</h3>\n              <p className=\"text-sm text-gray-600 dark:text-gray-300\">Increase contrast</p>\n            </div>\n            <button\n              onClick={() => handleUpdateSetting('highContrast', !settings.highContrast)}\n              className={`relative inline-flex h-6 w-11 items-center rounded-full ${\n                settings.highContrast ? 'bg-blue-600' : 'bg-gray-300'\n              }`}\n            >\n              <span\n                className={`inline-block h-4 w-4 rounded-full bg-white transition ${\n                  settings.highContrast ? 'translate-x-6' : 'translate-x-1'\n                }`}\n              />\n            </button>\n          </div>\n          {/* CLOSE: high-contrast-toggle */}\n\n          {/**\n           * REF: reduced-motion-toggle\n           *\n           * ## Reduced Motion Toggle\n           *\n           * Toggle for minimizing animations.\n           */}\n          <div className=\"flex items-center justify-between p-4 border rounded-lg\">\n            <div>\n              <h3 className=\"font-medium\">Reduce Motion</h3>\n              <p className=\"text-sm text-gray-600 dark:text-gray-300\">Minimize animations</p>\n            </div>\n            <button\n              onClick={() => handleUpdateSetting('reducedMotion', !settings.reducedMotion)}\n              className={`relative inline-flex h-6 w-11 items-center rounded-full ${\n                settings.reducedMotion ? 'bg-blue-600' : 'bg-gray-300'\n              }`}\n            >\n              <span\n                className={`inline-block h-4 w-4 rounded-full bg-white transition ${\n                  settings.reducedMotion ? 'translate-x-6' : 'translate-x-1'\n                }`}\n              />\n            </button>\n          </div>\n          {/* CLOSE: reduced-motion-toggle */}\n        </div>\n      </div>\n      {/* CLOSE: accessibility-section */}\n    </div>\n  )\n  // CLOSE: main-layout\n}\n\n/**\n * REF: drizzle-queries-example\n *\n * ## Type-Safe Settings Queries\n *\n * From `lib/db/queries.ts`, showing Drizzle update operations.\n *\n * ### Update User Settings\n * ```typescript\n * export async function updateUserSettings(\n *   userId: string,\n *   updates: {\n *     theme?: string\n *     fontSize?: string\n *     highContrast?: boolean\n *     reducedMotion?: boolean\n *   }\n * ) {\n *   const [updated] = await db\n *     .update(userSettings)\n *     .set({\n *       ...updates,\n *       updatedAt: new Date(),\n *     })\n *     .where(eq(userSettings.userId, userId))\n *     .returning()\n *\n *   return updated\n * }\n * ```\n *\n * ### Benefits\n * - Fully type-checked updates\n * - Partial updates supported\n * - Compile-time validation\n * - Returns updated record\n */\n// CLOSE: drizzle-queries-example\n",
      "language": "typescript"
    },
    {
      "path": "components/todos/TodoForm.tsx",
      "content": "/**\n * REF: file-header\n *\n * # TodoForm Component - Type-Safe Form with Drizzle\n *\n * Form for creating todos with Drizzle ORM's perfect type safety. This component\n * demonstrates how Drizzle ensures compile-time validation of all database operations.\n *\n * ## Architecture Highlights\n * - Drizzle insert operations with type inference\n * - Type safety from schema via InferInsertModel\n * - Controlled component pattern for form fields\n * - Inline tag management with array state\n * - Form validation and error handling\n *\n * ## Drizzle Type Safety Benefits\n * | Feature | Benefit |\n * |---------|---------|\n * | `InferInsertModel` | Exact type for INSERT operations |\n * | TypeScript validation | All fields match schema |\n * | IDE autocomplete | Column names in IDE |\n * | Compile-time checks | Prevents runtime bugs |\n *\n * ## Type Inference Pattern\n * ```typescript\n * import { InferInsertModel } from 'drizzle-orm'\n * import { todos } from '@/lib/db/schema'\n *\n * type NewTodo = InferInsertModel<typeof todos>\n * // TypeScript infers: { userId: string, title: string, ... }\n * ```\n */\n// CLOSE: file-header\n\n'use client'\n\n/**\n * REF: imports\n *\n * ## Import Dependencies\n *\n * ### React\n * - `useState`: Manage form field state\n * - `FormEvent`: TypeScript type for form events\n *\n * ### Database Layer\n * - `createTodo`: Type-safe Drizzle mutation from queries.ts\n */\nimport { useState, FormEvent } from 'react'\nimport { createTodo } from '@/lib/db/queries'\n// CLOSE: imports\n\n/**\n * REF: props-interface\n *\n * ## TodoForm Props Interface\n *\n * Defines the props required for the TodoForm component.\n *\n * | Prop | Type | Required | Description |\n * |------|------|----------|-------------|\n * | `userId` | `string` | Yes | ID of the user creating the todo |\n * | `onSuccess` | `() => void` | No | Callback function called after successful todo creation |\n *\n * ### onSuccess Callback\n * Used to trigger UI updates in parent component, such as:\n * - Refreshing the todo list\n * - Closing a modal\n * - Showing a success message\n *\n * ### Example Usage\n * ```typescript\n * <TodoForm\n *   userId={user.id}\n *   onSuccess={() => {\n *     refreshTodos()\n *     closeModal()\n *   }}\n * />\n * ```\n */\ninterface TodoFormProps {\n  userId: string\n  onSuccess?: () => void\n}\n// CLOSE: props-interface\n\n/**\n * REF: component-function\n *\n * ## TodoForm Component Function\n *\n * Main component function with state management for form fields.\n */\nexport default function TodoForm({ userId, onSuccess }: TodoFormProps) {\n  // CLOSE: component-function\n\n  /**\n   * REF: state-management\n   *\n   * ## Form State Variables\n   *\n   * All state for managing form input values and UI state.\n   *\n   * | State Variable | Type | Initial Value | Description |\n   * |----------------|------|---------------|-------------|\n   * | `title` | `string` | `''` | Todo title (required field) |\n   * | `description` | `string` | `''` | Todo description (optional) |\n   * | `isPublic` | `boolean` | `false` | Whether todo is publicly visible |\n   * | `tags` | `string[]` | `[]` | Array of tag strings |\n   * | `tagInput` | `string` | `''` | Temporary input for adding new tags |\n   * | `loading` | `boolean` | `false` | Tracks form submission state |\n   * | `error` | `string` | `''` | Error message to display |\n   *\n   * ### State Management Pattern\n   * - Each form field has its own state variable\n   * - Controlled components pattern (React-managed state)\n   * - Loading state prevents double submissions\n   * - Error state provides user feedback\n   */\n  const [title, setTitle] = useState('')\n  const [description, setDescription] = useState('')\n  const [isPublic, setIsPublic] = useState(false)\n  const [tags, setTags] = useState<string[]>([])\n  const [tagInput, setTagInput] = useState('')\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState('')\n  // CLOSE: state-management\n\n  /**\n   * REF: submit-handler\n   *\n   * ## Form Submit Handler\n   *\n   * Handles form submission with validation, API call, and state updates.\n   *\n   * ### Execution Flow\n   * 1. Prevent default form submission\n   * 2. Clear any existing errors\n   * 3. Validate required fields (title)\n   * 4. Set loading state\n   * 5. Call type-safe Drizzle query\n   * 6. Clear form on success\n   * 7. Call onSuccess callback\n   * 8. Handle errors and reset loading state\n   *\n   * ### Type Safety with Drizzle\n   * The `createTodo()` function is fully typed from the schema:\n   * - TypeScript validates all property names\n   * - TypeScript validates all property types\n   * - Compile error if we pass wrong data\n   * - Autocomplete works perfectly\n   *\n   * ### Type-Safe Query Helper Call\n   *\n   * `createTodo` expects specific typed arguments from schema.\n   *\n   * Type validation ensures:\n   * - `userId` is a string\n   * - `title` is a string\n   * - `description` is string | undefined\n   * - `isPublic` is boolean\n   * - `tags` is string[] | undefined\n   *\n   * Drizzle will convert undefined to NULL in database.\n   */\n  const handleSubmit = async (e: FormEvent) => {\n    e.preventDefault()\n    setError('')\n\n    if (!title.trim()) {\n      setError('Title is required')\n      return\n    }\n\n    setLoading(true)\n\n    try {\n      await createTodo({\n        userId,\n        title: title.trim(),\n        description: description.trim() || undefined,\n        isPublic,\n        tags: tags.length > 0 ? tags : undefined,\n      })\n\n      // Clear form on success\n      setTitle('')\n      setDescription('')\n      setIsPublic(false)\n      setTags([])\n      setError('')\n\n      // Notify parent component\n      onSuccess?.()\n    } catch (err: any) {\n      console.error('Error:', err)\n      setError(err.message || 'Failed to create todo')\n    } finally {\n      setLoading(false)\n    }\n  }\n  // CLOSE: submit-handler\n\n  /**\n   * REF: tag-management-handlers\n   *\n   * ## Tag Management Functions\n   *\n   * Functions for adding and removing tags from the tags array.\n   *\n   * ### Add Tag Handler\n   *\n   * Adds a new tag to the tags array with validation.\n   *\n   * #### Validation Rules\n   * - Tag must not be empty after trimming\n   * - Tag is converted to lowercase for consistency\n   * - Duplicate tags are prevented\n   * - Maximum 10 tags allowed\n   *\n   * #### Process\n   * 1. Trim and lowercase the input\n   * 2. Check if valid and not duplicate\n   * 3. Add to tags array\n   * 4. Clear input field\n   */\n  const handleAddTag = () => {\n    const tag = tagInput.trim().toLowerCase()\n    if (tag && !tags.includes(tag) && tags.length < 10) {\n      setTags([...tags, tag])\n      setTagInput('')\n    }\n  }\n\n  /**\n   * ### Remove Tag Handler\n   *\n   * Removes a tag from the tags array.\n   *\n   * #### Process\n   * - Filters out the specified tag\n   * - Creates new array without mutation\n   * - React re-renders with updated state\n   */\n  const handleRemoveTag = (tag: string) => {\n    setTags(tags.filter(t => t !== tag))\n  }\n  // CLOSE: tag-management-handlers\n\n  /**\n   * REF: form-render\n   *\n   * ## Form JSX Structure\n   *\n   * Renders the complete form with all input fields.\n   *\n   * ### Form Sections\n   * 1. Error message display\n   * 2. Title input (required)\n   * 3. Description textarea (optional)\n   * 4. Public checkbox\n   * 5. Tags input and display\n   * 6. Submit button\n   */\n  return (\n    <form onSubmit={handleSubmit} className=\"space-y-4\">\n      {/* CLOSE: form-render */}\n\n      {/**\n       * REF: error-display\n       *\n       * ## Error Message Display\n       *\n       * Conditionally renders error message when error state is set.\n       *\n       * ### Styling\n       * - Red background (bg-red-100)\n       * - Red text (text-red-700)\n       * - Padding and rounded corners for visibility\n       */}\n      {error && (\n        <div className=\"bg-red-100 text-red-700 px-4 py-3 rounded\">\n          {error}\n        </div>\n      )}\n      {/* CLOSE: error-display */}\n\n      {/**\n       * REF: title-input\n       *\n       * ## Title Input Field\n       *\n       * Required text input for the todo title.\n       *\n       * ### Field Configuration\n       * - Type: text\n       * - Required: true\n       * - Controlled: value tied to `title` state\n       * - Handler: `setTitle` on change\n       *\n       * ### Accessibility\n       * - Label with htmlFor matching input id\n       * - Visual indicator (*) for required field\n       * - Focus ring for keyboard navigation\n       */}\n      <div>\n        <label htmlFor=\"title\" className=\"block text-sm font-medium mb-2\">\n          Title <span className=\"text-red-500\">*</span>\n        </label>\n        <input\n          id=\"title\"\n          type=\"text\"\n          value={title}\n          onChange={(e) => setTitle(e.target.value)}\n          required\n          className=\"w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-gray-700\"\n        />\n      </div>\n      {/* CLOSE: title-input */}\n\n      {/**\n       * REF: description-textarea\n       *\n       * ## Description Textarea\n       *\n       * Optional multi-line text input for todo description.\n       *\n       * ### Field Configuration\n       * - Type: textarea (4 rows)\n       * - Required: false\n       * - Controlled: value tied to `description` state\n       * - Handler: `setDescription` on change\n       *\n       * ### Styling\n       * - Full width\n       * - Dark mode support with dark:bg-gray-700\n       * - Focus ring for better UX\n       */}\n      <div>\n        <label htmlFor=\"description\" className=\"block text-sm font-medium mb-2\">\n          Description\n        </label>\n        <textarea\n          id=\"description\"\n          value={description}\n          onChange={(e) => setDescription(e.target.value)}\n          rows={4}\n          className=\"w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-gray-700\"\n        />\n      </div>\n      {/* CLOSE: description-textarea */}\n\n      {/**\n       * REF: public-checkbox\n       *\n       * ## Public Visibility Checkbox\n       *\n       * Checkbox to control whether the todo is publicly visible.\n       *\n       * ### Field Configuration\n       * - Type: checkbox\n       * - Controlled: checked tied to `isPublic` state\n       * - Handler: `setIsPublic` with e.target.checked\n       *\n       * ### Layout\n       * - Horizontal flex layout\n       * - Checkbox aligned with label\n       * - Cursor pointer for better UX\n       */}\n      <div className=\"flex items-center gap-2\">\n        <input\n          id=\"isPublic\"\n          type=\"checkbox\"\n          checked={isPublic}\n          onChange={(e) => setIsPublic(e.target.checked)}\n          className=\"w-4 h-4\"\n        />\n        <label htmlFor=\"isPublic\" className=\"text-sm cursor-pointer\">\n          Make public\n        </label>\n      </div>\n      {/* CLOSE: public-checkbox */}\n\n      {/**\n       * REF: tags-input-section\n       *\n       * ## Tags Input and Display\n       *\n       * Interface for adding and displaying tags.\n       *\n       * ### Tag Input Field with Add Button\n       *\n       * Input field for typing new tags with Add button.\n       *\n       * #### Features\n       * - Flex layout with input and button\n       * - Enter key triggers handleAddTag (prevents form submit)\n       * - Add button also triggers handleAddTag\n       * - Placeholder text guides user\n       *\n       * ### Current Tags Display\n       *\n       * Displays all added tags as removable pills.\n       *\n       * #### Conditional Rendering\n       * Only shows if tags array has items\n       *\n       * #### Tag Pills\n       * - Each tag shown with # prefix\n       * - Remove button (√ó) for each tag\n       * - Blue background for visual distinction\n       * - Flex wrap for multiple rows\n       */}\n      <div>\n        <label className=\"block text-sm font-medium mb-2\">Tags</label>\n\n        <div className=\"flex gap-2 mb-2\">\n          <input\n            type=\"text\"\n            value={tagInput}\n            onChange={(e) => setTagInput(e.target.value)}\n            onKeyDown={(e) => e.key === 'Enter' && (e.preventDefault(), handleAddTag())}\n            className=\"flex-1 px-4 py-2 border rounded-lg dark:bg-gray-700\"\n            placeholder=\"Add tag...\"\n          />\n          <button\n            type=\"button\"\n            onClick={handleAddTag}\n            className=\"px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded hover:bg-gray-300\"\n          >\n            Add\n          </button>\n        </div>\n\n        {tags.length > 0 && (\n          <div className=\"flex flex-wrap gap-2\">\n            {tags.map(tag => (\n              <span\n                key={tag}\n                className=\"inline-flex items-center gap-1 px-3 py-1 bg-blue-100 dark:bg-blue-900 rounded-full text-sm\"\n              >\n                #{tag}\n                <button\n                  type=\"button\"\n                  onClick={() => handleRemoveTag(tag)}\n                  className=\"hover:text-blue-600\"\n                >\n                  √ó\n                </button>\n              </span>\n            ))}\n          </div>\n        )}\n      </div>\n      {/* CLOSE: tags-input-section */}\n\n      {/**\n       * REF: submit-button\n       *\n       * ## Submit Button\n       *\n       * Button to submit the form and create the todo.\n       *\n       * ### Button States\n       * - Normal: \"Create Todo\" text, blue background\n       * - Loading: \"Creating...\" text, disabled state\n       * - Disabled: Gray background when loading\n       *\n       * ### Configuration\n       * - Type: submit (triggers handleSubmit)\n       * - Full width for mobile-friendly UX\n       * - Disabled when loading prevents double submission\n       */}\n      <button\n        type=\"submit\"\n        disabled={loading}\n        className=\"w-full py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400\"\n      >\n        {loading ? 'Creating...' : 'Create Todo'}\n      </button>\n      {/* CLOSE: submit-button */}\n\n    </form>\n  )\n}\n\n/**\n * REF: drizzle-type-examples\n *\n * ## Drizzle Insert Type Inference\n *\n * Demonstrates how Drizzle automatically infers types for INSERT operations.\n *\n * ### Type Inference Magic\n * ```typescript\n * import { InferInsertModel } from 'drizzle-orm'\n * import { todos } from '@/lib/db/schema'\n *\n * type NewTodo = InferInsertModel<typeof todos>\n * // TypeScript automatically infers:\n * // {\n * //   userId: string\n * //   title: string\n * //   description?: string | null\n * //   completed?: boolean\n * //   isPublic?: boolean\n * //   tags?: string[] | null\n * // }\n * ```\n *\n * ### Benefits\n * - No manual type definitions needed\n * - Types match database schema exactly\n * - Automatically updates when schema changes\n * - Optional fields marked with `?`\n * - Required fields have no `?`\n */\n\n/**\n * ## Type-Safe Query Helper Example\n *\n * The `createTodo` helper from queries.ts with full type safety.\n *\n * ### Implementation\n * ```typescript\n * export async function createTodo(data: {\n *   userId: string\n *   title: string\n *   description?: string\n *   isPublic?: boolean\n *   tags?: string[]\n * }) {\n *   const [todo] = await db\n *     .insert(todos)\n *     .values({\n *       userId: data.userId,\n *       title: data.title,\n *       description: data.description || null,\n *       isPublic: data.isPublic || false,\n *       tags: data.tags || null,\n *       completed: false,\n *     })\n *     .returning()\n *\n *   return todo\n * }\n * ```\n *\n * ### Type Safety Features\n * - Every field validated by TypeScript\n * - Typo in field name causes compile error\n * - Wrong type for field causes compile error\n * - Missing required field causes compile error\n * - IDE autocomplete for all fields\n *\n * ### Examples of Type Checking\n * ```typescript\n * // ‚úÖ Valid - all required fields provided\n * await createTodo({\n *   userId: '123',\n *   title: 'My todo'\n * })\n *\n * // ‚úÖ Valid - optional fields included\n * await createTodo({\n *   userId: '123',\n *   title: 'My todo',\n *   description: 'Details here',\n *   tags: ['work', 'urgent']\n * })\n *\n * // ‚ùå Compile error - missing required field 'title'\n * await createTodo({\n *   userId: '123'\n * })\n *\n * // ‚ùå Compile error - wrong type for title (number instead of string)\n * await createTodo({\n *   userId: '123',\n *   title: 456\n * })\n *\n * // ‚ùå Compile error - field doesn't exist in schema\n * await createTodo({\n *   userId: '123',\n *   title: 'My todo',\n *   invalidField: 'test'\n * })\n * ```\n */\n// CLOSE: drizzle-type-examples\n",
      "language": "typescript"
    },
    {
      "path": "components/todos/TodoItem.tsx",
      "content": "/**\n * REF: file-header\n *\n * # TodoItem Component - Individual Todo with Drizzle\n *\n * Displays a single todo with edit, delete, and complete actions. This component\n * demonstrates Drizzle's type safety for update operations and inline editing patterns.\n *\n * ## Architecture Highlights\n * - Type inference from Drizzle schema via InferSelectModel\n * - Inline editing pattern with state management\n * - Update operations with type safety via Partial<Todo>\n * - Conditional rendering (edit mode vs view mode)\n * - Event handler prop drilling\n *\n * ## Drizzle Update Pattern\n * | Pattern | Implementation |\n * |---------|----------------|\n * | Query Helper | `updateTodo()` from queries.ts |\n * | Type Checking | Fully type-checked at compile time |\n * | Error Prevention | TypeScript prevents typos and type errors |\n * | IDE Support | Autocomplete for all fields |\n *\n * ## Drizzle Benefits\n * ```typescript\n * // ‚úÖ TypeScript validates this update\n * onUpdate(todo.id, { title: 'New title', completed: true })\n *\n * // ‚ùå Compile error - field doesn't exist\n * onUpdate(todo.id, { invalidField: 'test' })\n * ```\n */\n// CLOSE: file-header\n\n'use client'\n\n/**\n * REF: imports\n *\n * ## Import Dependencies\n *\n * ### React\n * - `useState`: Manage inline edit mode state\n *\n * ### Drizzle ORM\n * - `InferSelectModel`: Extract TypeScript type from schema\n * - `todos`: Schema definition for type inference\n */\nimport { useState } from 'react'\nimport { InferSelectModel } from 'drizzle-orm'\nimport { todos } from '@/lib/db/schema'\n// CLOSE: imports\n\n/**\n * REF: type-definition\n *\n * ## Todo Type from Schema\n *\n * Extract TypeScript type from Drizzle schema for SELECT operations.\n *\n * ### Type Inference\n * `InferSelectModel` generates the exact type returned by SELECT queries,\n * including all columns with their correct TypeScript types.\n *\n * ### Generated Type Structure\n * ```typescript\n * {\n *   id: string\n *   userId: string\n *   title: string\n *   description: string | null\n *   completed: boolean\n *   isPublic: boolean\n *   tags: string[] | null\n *   createdAt: Date\n *   updatedAt: Date\n * }\n * ```\n */\ntype Todo = InferSelectModel<typeof todos>\n// CLOSE: type-definition\n\n/**\n * REF: props-interface\n *\n * ## TodoItem Props Interface\n *\n * Defines all props required by the TodoItem component.\n *\n * | Prop | Type | Description |\n * |------|------|-------------|\n * | `todo` | `Todo` | Complete todo object from database |\n * | `onToggle` | `(todoId: string, completed: boolean) => Promise<void>` | Handler for toggling completion status |\n * | `onUpdate` | `(todoId: string, updates: Partial<Todo>) => Promise<void>` | Handler for updating todo fields |\n * | `onDelete` | `(todoId: string) => Promise<void>` | Handler for deleting todo |\n *\n * ### Handler Patterns\n * All handlers are async because they perform database operations.\n *\n * ### Partial<Todo> Type\n * `Partial<Todo>` makes all Todo properties optional, allowing partial updates.\n * TypeScript still validates that properties exist and have correct types.\n *\n * ### Example Usage\n * ```typescript\n * <TodoItem\n *   todo={todoData}\n *   onToggle={handleToggle}\n *   onUpdate={handleUpdate}\n *   onDelete={handleDelete}\n * />\n * ```\n */\ninterface TodoItemProps {\n  todo: Todo\n  onToggle: (todoId: string, completed: boolean) => Promise<void>\n  onUpdate: (todoId: string, updates: Partial<Todo>) => Promise<void>\n  onDelete: (todoId: string) => Promise<void>\n}\n// CLOSE: props-interface\n\n/**\n * REF: component-function\n *\n * ## TodoItem Component Function\n *\n * Main component with state management for inline editing.\n */\nexport default function TodoItem({\n  todo,\n  onToggle,\n  onUpdate,\n  onDelete,\n}: TodoItemProps) {\n  // CLOSE: component-function\n\n  /**\n   * REF: state-management\n   *\n   * ## Editing State Variables\n   *\n   * State for managing inline edit mode.\n   *\n   * | State Variable | Type | Initial Value | Description |\n   * |----------------|------|---------------|-------------|\n   * | `isEditing` | `boolean` | `false` | Whether component is in edit mode |\n   * | `editTitle` | `string` | `todo.title` | Temporary title value during editing |\n   * | `editDescription` | `string` | `todo.description \\|\\| ''` | Temporary description value during editing |\n   *\n   * ### State Pattern\n   * - Edit state is local to this component\n   * - Original todo data unchanged until save\n   * - Allows cancel without modifying parent state\n   */\n  const [isEditing, setIsEditing] = useState(false)\n  const [editTitle, setEditTitle] = useState(todo.title)\n  const [editDescription, setEditDescription] = useState(todo.description || '')\n  // CLOSE: state-management\n\n  /**\n   * REF: edit-mode-handlers\n   *\n   * ## Edit Mode Event Handlers\n   *\n   * Functions for entering, saving, and canceling edit mode.\n   *\n   * ### Enter Edit Mode Handler\n   *\n   * Initializes edit mode with current todo values.\n   *\n   * #### Process\n   * 1. Set edit state from current todo values\n   * 2. Enable edit mode\n   * 3. Component re-renders in edit view\n   */\n  const handleEdit = () => {\n    setEditTitle(todo.title)\n    setEditDescription(todo.description || '')\n    setIsEditing(true)\n  }\n\n  /**\n   * ### Save Edit Handler\n   *\n   * Validates and saves edited todo values.\n   *\n   * #### Validation\n   * - Title cannot be empty\n   * - Shows alert if validation fails\n   *\n   * #### Type-Safe Update\n   * `onUpdate` expects `Partial<Todo>`, which TypeScript validates:\n   * - All property names must exist in Todo type\n   * - All property values must match correct type\n   * - Compile error if we try to pass invalid data\n   *\n   * #### Process\n   * 1. Validate title is not empty\n   * 2. Call onUpdate with type-safe partial object\n   * 3. Exit edit mode on success\n   */\n  const handleSave = async () => {\n    if (!editTitle.trim()) {\n      alert('Title cannot be empty')\n      return\n    }\n\n    await onUpdate(todo.id, {\n      title: editTitle.trim(),\n      description: editDescription.trim() || null,\n    })\n\n    setIsEditing(false)\n  }\n\n  /**\n   * ### Cancel Edit Handler\n   *\n   * Exits edit mode without saving changes.\n   *\n   * #### Process\n   * - Disables edit mode\n   * - Discards any changes to editTitle/editDescription\n   * - Component re-renders in view mode with original values\n   */\n  const handleCancel = () => {\n    setIsEditing(false)\n  }\n  // CLOSE: edit-mode-handlers\n\n  /**\n   * REF: edit-mode-view\n   *\n   * ## Edit Mode JSX\n   *\n   * Conditional render: Shows edit form when `isEditing` is true.\n   *\n   * ### Edit Form Features\n   * - Text input for title\n   * - Textarea for description\n   * - Save and Cancel buttons\n   * - Controlled components tied to edit state\n   *\n   * ### Early Return Pattern\n   * If in edit mode, return edit JSX and skip view mode JSX.\n   *\n   * ### Title Input Field\n   * - Controlled input tied to editTitle state\n   * - Updates state on every keystroke\n   * - Full width with focus ring\n   *\n   * ### Description Textarea\n   * - Controlled textarea tied to editDescription state\n   * - 3 rows for multi-line input\n   * - Matches title input styling\n   *\n   * ### Edit Mode Buttons\n   * - Save: Calls handleSave to persist changes\n   * - Cancel: Calls handleCancel to discard changes\n   * - Horizontal layout with gap\n   */\n  if (isEditing) {\n    return (\n      <div className=\"p-4 bg-gray-50 dark:bg-gray-700 rounded-lg border\">\n        <div className=\"space-y-3\">\n\n          <input\n            type=\"text\"\n            value={editTitle}\n            onChange={(e) => setEditTitle(e.target.value)}\n            className=\"w-full px-3 py-2 border rounded focus:ring-2 focus:ring-blue-500 dark:bg-gray-600\"\n            placeholder=\"Title\"\n          />\n\n          <textarea\n            value={editDescription}\n            onChange={(e) => setEditDescription(e.target.value)}\n            rows={3}\n            className=\"w-full px-3 py-2 border rounded focus:ring-2 focus:ring-blue-500 dark:bg-gray-600\"\n            placeholder=\"Description\"\n          />\n\n          <div className=\"flex gap-2\">\n            <button\n              onClick={handleSave}\n              className=\"px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\"\n            >\n              Save\n            </button>\n            <button\n              onClick={handleCancel}\n              className=\"px-4 py-2 bg-gray-300 dark:bg-gray-600 rounded hover:bg-gray-400\"\n            >\n              Cancel\n            </button>\n          </div>\n\n        </div>\n      </div>\n    )\n  }\n  // CLOSE: edit-mode-view\n\n  /**\n   * REF: view-mode-layout\n   *\n   * ## View Mode JSX\n   *\n   * Normal display mode showing todo with actions.\n   *\n   * ### Layout Structure\n   * - Checkbox for completion toggle\n   * - Content area (title, description, tags, visibility)\n   * - Action buttons (edit, delete)\n   */\n  return (\n    <div className=\"p-4 bg-white dark:bg-gray-800 rounded-lg border hover:shadow-md transition\">\n      <div className=\"flex items-start gap-4\">\n        {/* CLOSE: view-mode-layout */}\n\n        {/**\n         * REF: completion-checkbox\n         *\n         * ## Completion Checkbox\n         *\n         * Checkbox for toggling todo completion status.\n         *\n         * ### Configuration\n         * - Type: checkbox\n         * - Checked: tied to todo.completed\n         * - onChange: calls onToggle with current state\n         *\n         * ### Toggle Logic\n         * Passes current `todo.completed` value so parent knows the current state.\n         * Parent will toggle it to opposite value in database.\n         *\n         * ### Styling\n         * - 5x5 size for easy clicking\n         * - Cursor pointer for UX\n         * - Top margin for alignment with title\n         */}\n        <input\n          type=\"checkbox\"\n          checked={todo.completed}\n          onChange={() => onToggle(todo.id, todo.completed)}\n          className=\"mt-1 w-5 h-5 cursor-pointer\"\n        />\n        {/* CLOSE: completion-checkbox */}\n\n        {/**\n         * REF: todo-content-section\n         *\n         * ## Todo Content Display\n         *\n         * Displays title, description, tags, and visibility status.\n         *\n         * ### Todo Title\n         * - Font: large and medium weight\n         * - Conditional styling: line-through and gray if completed\n         * - Type safety: TypeScript knows todo.title is a string\n         *\n         * ### Todo Description\n         * - Conditionally rendered only if description exists\n         * - Type safety: TypeScript knows description is string | null\n         * - Line-through if completed\n         * - Gray color for secondary info\n         *\n         * ### Tags Display\n         * - Conditionally rendered if tags array exists and has items\n         * - Type safety: TypeScript knows tags is string[] | null\n         * - Maps over array to render each tag\n         * - Pills with gray background\n         * - Flex wrap for multiple rows\n         *\n         * ### Public/Private Badge\n         * - Shows whether todo is public or private\n         * - Conditional styling based on isPublic value\n         * - Green for public, gray for private\n         * - Type safety: TypeScript knows isPublic is boolean\n         */}\n        <div className=\"flex-1\">\n\n          <h4 className={`text-lg font-medium ${todo.completed ? 'line-through text-gray-500' : ''}`}>\n            {todo.title}\n          </h4>\n\n          {todo.description && (\n            <p className={`mt-1 text-gray-600 dark:text-gray-300 ${todo.completed ? 'line-through' : ''}`}>\n              {todo.description}\n            </p>\n          )}\n\n          {todo.tags && todo.tags.length > 0 && (\n            <div className=\"flex flex-wrap gap-2 mt-2\">\n              {todo.tags.map(tag => (\n                <span\n                  key={tag}\n                  className=\"px-2 py-1 bg-gray-100 dark:bg-gray-700 text-xs rounded-full\"\n                >\n                  #{tag}\n                </span>\n              ))}\n            </div>\n          )}\n\n          <div className=\"mt-2\">\n            <span className={`text-xs px-2 py-1 rounded ${\n              todo.isPublic\n                ? 'bg-green-100 text-green-800 dark:bg-green-900'\n                : 'bg-gray-100 dark:bg-gray-700'\n            }`}>\n              {todo.isPublic ? 'üåê Public' : 'üîí Private'}\n            </span>\n          </div>\n\n        </div>\n        {/* CLOSE: todo-content-section */}\n\n        {/**\n         * REF: action-buttons\n         *\n         * ## Action Buttons\n         *\n         * Edit and delete buttons for todo management.\n         *\n         * ### Edit Button\n         * - Calls handleEdit to enter edit mode\n         * - Blue color scheme\n         * - Hover effect with background color change\n         *\n         * ### Delete Button\n         * - Calls onDelete with todo.id\n         * - Red color scheme for destructive action\n         * - Hover effect with background color change\n         */}\n        <div className=\"flex gap-2\">\n\n          <button\n            onClick={handleEdit}\n            className=\"p-2 text-blue-600 hover:bg-blue-50 dark:hover:bg-blue-900 rounded\"\n          >\n            ‚úèÔ∏è\n          </button>\n\n          <button\n            onClick={() => onDelete(todo.id)}\n            className=\"p-2 text-red-600 hover:bg-red-50 dark:hover:bg-red-900 rounded\"\n          >\n            üóëÔ∏è\n          </button>\n\n        </div>\n        {/* CLOSE: action-buttons */}\n\n      </div>\n    </div>\n  )\n}\n\n/**\n * REF: type-safety-examples\n *\n * ## Drizzle Type Safety Showcase\n *\n * Examples of how TypeScript catches errors when using onUpdate.\n *\n * ### Valid Updates\n * ```typescript\n * // ‚úÖ Valid - title is string in schema\n * onUpdate(todo.id, { title: 'New title' })\n *\n * // ‚úÖ Valid - description can be null\n * onUpdate(todo.id, { description: null })\n *\n * // ‚úÖ Valid - updating multiple fields\n * onUpdate(todo.id, {\n *   title: 'New title',\n *   description: 'New description',\n *   isPublic: true\n * })\n *\n * // ‚úÖ Valid - partial update (only one field)\n * onUpdate(todo.id, { completed: true })\n * ```\n *\n * ### Invalid Updates (Compile Errors)\n * ```typescript\n * // ‚ùå Type error - userId is wrong type\n * onUpdate(todo.id, { userId: 123 })\n * // Error: Type 'number' is not assignable to type 'string'\n *\n * // ‚ùå Type error - field doesn't exist\n * onUpdate(todo.id, { invalidField: 'test' })\n * // Error: Object literal may only specify known properties\n *\n * // ‚ùå Type error - wrong type for completed\n * onUpdate(todo.id, { completed: 'yes' })\n * // Error: Type 'string' is not assignable to type 'boolean'\n *\n * // ‚ùå Type error - tags must be array of strings\n * onUpdate(todo.id, { tags: ['valid', 123, true] })\n * // Error: Type 'number' is not assignable to type 'string'\n * ```\n *\n * ### TypeScript Benefits\n * - All errors caught at compile time (before running code)\n * - IDE shows errors immediately as you type\n * - Autocomplete suggests valid property names\n * - Prevents runtime errors from typos or wrong types\n */\n// CLOSE: type-safety-examples\n\n/**\n * REF: drizzle-usage-pattern\n *\n * ## Using with Drizzle Queries\n *\n * Example of how parent components implement the update handler.\n *\n * ### Parent Component Pattern\n * ```typescript\n * import { updateTodo } from '@/lib/db/queries'\n *\n * function TodoList() {\n *   const handleUpdate = async (todoId: string, updates: Partial<Todo>) => {\n *     // Type-safe update with Drizzle\n *     const updated = await updateTodo(todoId, updates)\n *\n *     // TypeScript knows exact structure of 'updated'\n *     console.log(updated.title) // ‚úÖ TypeScript knows this is string\n *     console.log(updated.completed) // ‚úÖ TypeScript knows this is boolean\n *     console.log(updated.tags) // ‚úÖ TypeScript knows this is string[] | null\n *\n *     // Refresh UI or update state\n *     refreshTodos()\n *   }\n *\n *   return (\n *     <TodoItem\n *       todo={todo}\n *       onUpdate={handleUpdate}\n *       onToggle={handleToggle}\n *       onDelete={handleDelete}\n *     />\n *   )\n * }\n * ```\n *\n * ### End-to-End Type Safety\n * - Component defines handler with correct types\n * - Handler calls Drizzle query with type checking\n * - Database operation validated by TypeScript\n * - Return value has inferred types\n * - No manual type annotations needed anywhere!\n */\n// CLOSE: drizzle-usage-pattern\n",
      "language": "typescript"
    },
    {
      "path": "components/todos/TodoList.tsx",
      "content": "/**\n * REF: component-overview\n *\n * # TodoList Component - Display with Drizzle Types\n *\n * Displays todos with perfect type inference from Drizzle schema. This component\n * demonstrates how Drizzle ORM provides automatic TypeScript types directly from\n * the database schema without manual type definitions.\n *\n * ## Key Concepts\n * - Type inference from schema using InferSelectModel\n * - Component composition with TodoItem\n * - List rendering patterns with filtering\n * - Separation of active vs completed todos\n *\n * ## Drizzle Type Inference\n * - `InferSelectModel` automatically generates TypeScript types from schema\n * - No manual type definitions needed\n * - Always in sync with database schema\n * - Perfect autocomplete in IDE\n * - Compile-time type safety\n */\n// CLOSE: component-overview\n\n'use client'\n\n  /** REF: imports\n   */\nimport { InferSelectModel } from 'drizzle-orm'\nimport { todos } from '@/lib/db/schema'\nimport TodoItem from './TodoItem'\n  // CLOSE: imports\n\n/**\n * REF: type-definition\n *\n * ## Todo Type from Schema\n *\n * `InferSelectModel` extracts the exact TypeScript type from the Drizzle schema.\n * This ensures the Todo type matches the database structure exactly.\n *\n * ### Type Inference Process\n * 1. Drizzle reads the `todos` schema definition\n * 2. `InferSelectModel` generates TypeScript type for SELECT queries\n * 3. Resulting type includes all columns with correct types\n *\n * ### Generated Type Structure\n * ```typescript\n * type Todo = {\n *   id: string\n *   userId: string\n *   title: string\n *   description: string | null\n *   completed: boolean\n *   isPublic: boolean\n *   tags: string[] | null\n *   createdAt: Date\n *   updatedAt: Date\n * }\n * ```\n *\n * ### Benefits\n * - No manual typing required\n * - Automatically updates when schema changes\n * - Prevents type drift between database and code\n */\ntype Todo = InferSelectModel<typeof todos>\n// CLOSE: type-definition\n\n/**\n * REF: props-interface\n *\n * ## TodoList Props Interface\n *\n * Defines the props this component accepts from its parent.\n *\n * | `Prop` | Type | Description |\n * |------|------|-------------|\n * | `todos` | `Todo[]` | Array of todo items to display |\n * | `onToggle` | `(todoId: string, completed: boolean) => Promise<void>` | Handler for toggling todo completion status |\n * | `onUpdate` | `(todoId: string, updates: Partial<Todo>) => Promise<void>` | Handler for updating todo fields |\n * | `onDelete` | `(todoId: string) => Promise<void>` | Handler for deleting a todo |\n *\n * ### Handler Functions\n * All handlers are async and return Promises because they perform database operations.\n *\n * ### Example Usage\n * ```typescript\n * <TodoList\n *   todos={userTodos}\n *   onToggle={handleToggle}\n *   onUpdate={handleUpdate}\n *   onDelete={handleDelete}\n * />\n * ```\n */\ninterface TodoListProps {\n  todos: Todo[]\n  onToggle: (todoId: string, completed: boolean) => Promise<void>\n  onUpdate: (todoId: string, updates: Partial<Todo>) => Promise<void>\n  onDelete: (todoId: string) => Promise<void>\n}\n// CLOSE: props-interface\n\n/**\n * REF: component-function\n *\n * ## TodoList Component Function\n *\n * Main component that renders the list of todos, separated into active and completed sections.\n *\n * ### Props Destructuring\n * All props are destructured for cleaner code access.\n */\nexport default function TodoList({\n  todos,\n  onToggle,\n  onUpdate,\n  onDelete,\n}: TodoListProps) {\n// CLOSE: component-function\n\n  /**\n   * REF: todo-filtering\n   *\n   * ## Separate Todos by Completion Status\n   *\n   * Filters todos into two arrays for better UX and visual organization.\n   *\n   * ### Filter Operations\n   * - `activeTodos`: Todos where `completed === false`\n   * - `completedTodos`: Todos where `completed === true`\n   *\n   * ### Benefits\n   * - Clear visual separation\n   * - Users can focus on active tasks\n   * - Completed tasks are visually de-emphasized\n   *\n   * ### Type Safety\n   * TypeScript knows that `todo.completed` is a boolean from the Drizzle schema.\n   * No need to check if the property exists.\n   */\n  const activeTodos = todos.filter(todo => !todo.completed)\n  const completedTodos = todos.filter(todo => todo.completed)\n  // CLOSE: todo-filtering\n\n  /**\n   * REF: component-render\n   *\n   * ## Render Structure\n   *\n   * Three conditional sections:\n   * 1. Active todos (if any exist)\n   * 2. Completed todos (if any exist)\n   * 3. Empty state (if no todos exist)\n   */\n  return (\n    <div className=\"space-y-6\">\n      {/* CLOSE: component-render */}\n\n      {/*\n       * REF: active-todos-section\n       *\n       * ## Active Todos Section\n       *\n       * Displays uncompleted todos with full opacity and prominence.\n       *\n       * ### Conditional Rendering\n       * Only renders if `activeTodos.length > 0`\n       *\n       * ### Display Features\n       * - Shows count in header\n       * - Full opacity for visibility\n       * - Each todo rendered via TodoItem component\n       * - Unique `key` prop using todo.id for React reconciliation\n       */}\n      {activeTodos.length > 0 && (\n        <div>\n          <h3 className=\"text-lg font-semibold mb-3\">\n            Active ({activeTodos.length})\n          </h3>\n          <div className=\"space-y-2\">\n            {activeTodos.map(todo => (\n              <TodoItem\n                key={todo.id}\n                todo={todo}\n                onToggle={onToggle}\n                onUpdate={onUpdate}\n                onDelete={onDelete}\n              />\n            ))}\n          </div>\n        </div>\n      )}\n      {/* CLOSE: active-todos-section */}\n\n      {/*\n       * REF: completed-todos-section\n       *\n       * ## Completed Todos Section\n       *\n       * Displays completed todos with reduced opacity to de-emphasize.\n       *\n       * ### Conditional Rendering\n       * Only renders if `completedTodos.length > 0`\n       *\n       * ### Display Features\n       * - Shows count in header\n       * - Gray text color for header\n       * - Reduced opacity (75%) for entire section\n       * - Same TodoItem component for consistency\n       * - Unique `key` prop for each item\n       */}\n      {completedTodos.length > 0 && (\n        <div>\n          <h3 className=\"text-lg font-semibold mb-3 text-gray-500\">\n            Completed ({completedTodos.length})\n          </h3>\n          <div className=\"space-y-2 opacity-75\">\n            {completedTodos.map(todo => (\n              <TodoItem\n                key={todo.id}\n                todo={todo}\n                onToggle={onToggle}\n                onUpdate={onUpdate}\n                onDelete={onDelete}\n              />\n            ))}\n          </div>\n        </div>\n      )}\n      {/* CLOSE: completed-todos-section */}\n\n      {/*\n       * REF: empty-state\n       *\n       * ## Empty State Message\n       *\n       * Displayed when no todos exist at all (neither active nor completed).\n       *\n       * ### Conditional Rendering\n       * Only shows if `todos.length === 0`\n       *\n       * ### Purpose\n       * - Informs users the list is empty\n       * - Provides guidance on next action (create a todo)\n       * - Prevents confusing blank screen\n       */}\n      {todos.length === 0 && (\n        <p className=\"text-center text-gray-500 py-8\">\n          No todos found. Create one to get started!\n        </p>\n      )}\n      {/* CLOSE: empty-state */}\n\n    </div>\n  )\n}\n\n/**\n * REF: usage-examples\n/**\n * ## Drizzle Query for Todos\n *\n * Example of how parent components fetch todos using Drizzle queries.\n *\n * ### Fetching Todos\n * ```typescript\n * import { getUserTodos } from '@/lib/db/queries'\n *\n * const todos = await getUserTodos(userId)\n * // TypeScript automatically infers the type:\n * // todos: {\n * //   id: string\n * //   userId: string\n * //   title: string\n * //   description: string | null\n * //   completed: boolean\n * //   isPublic: boolean\n * //   tags: string[] | null\n * //   createdAt: Date\n * //   updatedAt: Date\n * // }[]\n * ```\n *\n * ### Type Inference Benefits\n * - No manual type annotations needed\n * - TypeScript knows exact structure\n * - IDE autocomplete works perfectly\n * - Type errors caught at compile time\n */\n\n/**\n * ## Using with Server Components\n *\n * In a Next.js 13+ server component, fetch data directly in the component.\n *\n * ### Server Component Example\n * ```typescript\n * import { getUserTodos } from '@/lib/db/queries'\n * import TodoList from '@/components/todos/TodoList'\n *\n * export default async function Dashboard() {\n *   const user = await getUser()\n *   const todos = await getUserTodos(user.id) // Type-safe!\n *\n *   return <TodoList todos={todos} />\n * }\n * ```\n *\n * ### Benefits\n * - No loading state needed (data fetched server-side)\n * - Data ready immediately on render\n * - Better performance (less client JavaScript)\n * - SEO-friendly (content in initial HTML)\n */\n// CLOSE: usage-examples\n",
      "language": "typescript"
    },
    {
      "path": "components/ui/LoadingSpinner.tsx",
      "content": "/**\n * REF: loading-spinner-component\n *\n * # LoadingSpinner Component\n *\n * Reusable loading indicator with size variants.\n *\n * ## Key Concepts\n *\n * - **Reusable UI components** - DRY principle\n * - **Props customization** - Size and text options\n * - **CSS animations** - Tailwind animate-spin\n * - **Accessibility** - ARIA attributes\n * - **TypeScript props** - Type-safe interface\n *\n * ## Use Cases\n *\n * - Loading states in forms\n * - Page-level loading indicators\n * - Async operation feedback\n * - Data fetching states\n */\n\n/**\n * REF: spinner-props\n *\n * ## LoadingSpinner Props\n *\n * | `Prop` | Type | Default | Description |\n * |------|------|---------|-------------|\n * | `size` | 'sm' \\| 'md' \\| `'lg'` | `'md'` | Spinner size |\n * | `text` | `string` | `undefined` | Optional loading text |\n *\n * ### Size Variants\n *\n * - **sm**: Small (4x4) - for inline use\n * - **md**: Medium (8x8) - default\n * - **lg**: Large (12x12) - full-page loading\n */\ninterface LoadingSpinnerProps {\n  size?: 'sm' | 'md' | 'lg'\n  text?: string\n}\n// CLOSE: spinner-props\n\n/**\n * REF: spinner-function\n *\n * ## LoadingSpinner Function\n *\n * Component function with prop destructuring.\n */\nexport default function LoadingSpinner({\n  size = 'md',\n  text,\n}: LoadingSpinnerProps) {\n  // CLOSE: spinner-function\n\n  /**\n   * REF: size-classes\n   *\n   * ## Size Classes Mapping\n   *\n   * Maps size prop to Tailwind classes.\n   *\n   * | `Size` | `Classes` | `Dimensions` |\n   * |------|---------|------------|\n   * | `sm` | w-4 h-4 border-2 | 16x16px, 2px border |\n   * | `md` | w-8 h-8 border-4 | 32x32px, 4px border |\n   * | `lg` | w-12 h-12 border-4 | 48x48px, 4px border |\n   */\n  const sizeClasses = {\n    sm: 'w-4 h-4 border-2',\n    md: 'w-8 h-8 border-4',\n    lg: 'w-12 h-12 border-4',\n  }\n  // CLOSE: size-classes\n\n  /**\n   * REF: spinner-render\n   *\n   * ## Spinner Render\n   *\n   * Flex container with spinner and optional text.\n   */\n  return (\n    <div className=\"flex flex-col items-center justify-center gap-3\">\n      {/**\n       * REF: spinner-element\n       *\n       * ## Animated Spinner\n       *\n       * Circular div with rotation animation.\n       *\n       * ### Animation\n       *\n       * - `animate-spin` - Continuous rotation\n       * - `border-current` - Uses text color\n       * - `border-t-transparent` - Creates spinner gap\n       * - `rounded-full` - Perfect circle\n       */}\n      <div\n        className={`\n          ${sizeClasses[size]}\n          border-current\n          border-t-transparent\n          rounded-full\n          animate-spin\n        `}\n        role=\"status\"\n        aria-label=\"Loading\"\n      />\n      {/* CLOSE: spinner-element */}\n\n      {/**\n       * REF: loading-text\n       *\n       * ## Optional Loading Text\n       *\n       * Displays text below spinner when provided.\n       */}\n      {text && (\n        <p className=\"text-sm text-gray-600 dark:text-gray-300\">\n          {text}\n        </p>\n      )}\n      {/* CLOSE: loading-text */}\n    </div>\n  )\n}\n// CLOSE: spinner-render\n// CLOSE: loading-spinner-component\n",
      "language": "typescript"
    },
    {
      "path": "contexts/AuthContext.tsx",
      "content": "/**\n * REF: Context Overview\n *\n * # Authentication Context for Drizzle + Supabase Project\n *\n * This context demonstrates a hybrid architecture: Supabase for authentication\n * and Drizzle ORM for database operations. This approach leverages the strengths\n * of each tool.\n *\n * ## Key Concepts\n * - Hybrid architecture (Supabase auth + Drizzle database)\n * - Best tool for each job philosophy\n * - Type safety throughout the stack\n * - React Context API for auth state management\n * - Database operations via Drizzle inserts\n *\n * ## Why Supabase Auth with Drizzle?\n * - Supabase Auth is battle-tested and feature-complete\n * - Don't reinvent the wheel for authentication\n * - Use Drizzle where it excels (type-safe queries)\n * - Use Supabase where it excels (auth, realtime, storage)\n * - Clean separation of concerns\n *\n * ## Architecture\n * - Auth state and methods: Supabase\n * - User profile creation: Drizzle ORM\n * - Database queries: Drizzle ORM\n * - File storage: Supabase Storage\n *\n * CLOSE: Context Overview\n */\n\n'use client'\n\nimport { createContext, useContext, useEffect, useState, ReactNode } from 'react'\nimport type { User, Session } from '@supabase/supabase-js'\nimport { createClient } from '@/lib/supabase/client'\nimport { db } from '@/lib/db/client'\nimport { userProfiles, userSettings } from '@/lib/db/schema'\nimport { eq } from 'drizzle-orm'\n\n/**\n * REF: Context Type Interface\n *\n * ## AuthContext Type Definition\n *\n * TypeScript interface defining the shape of the auth context.\n *\n * | `Property` | Type | Description |\n * |----------|------|-------------|\n * | `user` | `User \\| null` | Current authenticated user from Supabase |\n * | `session` | `Session \\| null` | Current session with tokens and metadata |\n * | `loading` | `boolean` | Whether auth state is still being loaded |\n * | `signUp` | `Function` | Async function to register new user |\n * | `signIn` | `Function` | Async function to sign in existing user |\n * | `signOut` | `Function` | Async function to sign out current user |\n *\n * ### User and Session Types\n * From `@supabase/supabase-js`:\n * - `User`: Contains id, email, user_metadata, etc.\n * - `Session`: Contains access_token, refresh_token, user object\n *\n * ### Function Signatures\n * - `signUp(email, password, metadata?)`: Creates new account\n * - `signIn(email, password)`: Authenticates user\n * - `signOut()`: Ends current session\n *\n * CLOSE: Context Type Interface\n */\ninterface AuthContextType {\n  user: User | null\n  session: Session | null\n  loading: boolean\n  signUp: (email: string, password: string, metadata?: { displayName?: string }) => Promise<void>\n  signIn: (email: string, password: string) => Promise<void>\n  signOut: () => Promise<void>\n}\n\n/**\n * REF: Context Creation\n *\n * ## Create Auth Context\n *\n * Creates the React context with undefined initial value.\n *\n * ### Pattern\n * - Initial value is `undefined`\n * - `useAuth` hook will throw error if used outside provider\n * - Ensures context is always used correctly\n *\n * CLOSE: Context Creation\n */\nconst AuthContext = createContext<AuthContextType | undefined>(undefined)\n\n/**\n * REF: Provider Component and State\n *\n * ## AuthProvider Component\n *\n * Provider component that wraps the app and manages auth state.\n *\n * ### Props\n * - `children`: React nodes to wrap with auth context\n */\nexport function AuthProvider({ children }: { children: ReactNode }) {\n\n  /**\n   * ## State Variables\n   *\n   * React state for managing authentication.\n   *\n   * | `State` | Type | `Initial` | Description |\n   * |-------|------|---------|-------------|\n   * | `user` | `User \\| null` | `null` | Current user object |\n   * | `session` | `Session \\| null` | `null` | Current session object |\n   * | `loading` | `boolean` | `true` | Loading state (starts true) |\n   *\n   * ### Loading Pattern\n   * Starts as `true` to prevent rendering protected content before\n   * auth state is determined.\n   */\n  const [user, setUser] = useState<User | null>(null)\n  const [session, setSession] = useState<Session | null>(null)\n  const [loading, setLoading] = useState(true)\n\n  /**\n   * ## Supabase Client Instance\n   *\n   * Creates browser Supabase client for auth operations.\n   */\n  const supabase = createClient()\n  // CLOSE: Provider Component and State\n\n  /**\n   * REF: Auth State Listener Effect\n\n   *\n   * ## Auth State Listener useEffect\n   *\n   * Sets up listener for auth state changes and handles initial session.\n   *\n   * ### Execution Flow\n   * 1. Get initial session on mount\n   * 2. Set initial state and stop loading\n   * 3. Subscribe to auth state changes\n   * 4. Create user profile on sign in (via Drizzle)\n   * 5. Cleanup subscription on unmount\n   */\n  useEffect(() => {\n\n    /**\n     * ### Get Initial Session\n     *\n     * Fetches current session when component mounts.\n     *\n     * #### Process\n     * - Calls Supabase auth.getSession()\n     * - Sets session and user state\n     * - Sets loading to false\n     */\n    supabase.auth.getSession().then(({ data: { session } }) => {\n      setSession(session)\n      setUser(session?.user ?? null)\n      setLoading(false)\n    })\n\n    /**\n     * ### Subscribe to Auth Changes\n     *\n     * Listens for auth events (sign in, sign out, token refresh, etc.)\n     *\n     * #### Events Handled\n     * - SIGNED_IN: User successfully signed in\n     * - SIGNED_OUT: User signed out\n     * - TOKEN_REFRESHED: Access token refreshed\n     * - USER_UPDATED: User metadata updated\n     *\n     * #### State Updates\n     * All events update session and user state\n     */\n    const {\n      data: { subscription },\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      setSession(session)\n      setUser(session?.user ?? null)\n\n      /**\n       * ### Create User Profile with Drizzle\n       *\n       * When user signs in, create profile and settings using Drizzle.\n       *\n       * #### Drizzle Insert Operations\n       * - Type-safe insert via `db.insert()`\n       * - `.values()` provides data with type checking\n       * - `.onConflictDoNothing()` prevents duplicate errors\n       * - Safe to call on every sign in\n       *\n       * #### Alternative Approach\n       * Use PostgreSQL database trigger (more reliable, atomic).\n       * See migrations/001_initial_schema.sql for trigger examples.\n       *\n       * #### Why Both Tables?\n       * - userProfiles: Display name, avatar, etc.\n       * - userSettings: User preferences, theme, etc.\n       */\n      if (event === 'SIGNED_IN' && session?.user) {\n        // Create user profile\n        await db\n          .insert(userProfiles)\n          .values({\n            userId: session.user.id,\n            displayName: session.user.user_metadata?.displayName || '',\n          })\n          .onConflictDoNothing()\n\n        // Create default settings\n        await db\n          .insert(userSettings)\n          .values({\n            userId: session.user.id,\n          })\n          .onConflictDoNothing()\n      }\n    })\n\n    /**\n     * ### Cleanup Function\n     *\n     * Unsubscribes from auth changes when component unmounts.\n     *\n     * Prevents memory leaks and unnecessary updates.\n     */\n    return () => subscription.unsubscribe()\n  }, [supabase])\n  // CLOSE: Auth State Listener Effect\n\n  /**\n   * REF: Sign Up Function\n  /**\n   * ## Sign Up Function\n   *\n   * Creates new user account with Supabase Auth.\n   *\n   * ### Parameters\n   * - `email`: User's email address\n   * - `password`: User's password (min 6 chars by default)\n   * - `metadata`: Optional object with additional data (e.g., displayName)\n   *\n   * ### Process\n   * 1. Call Supabase auth.signUp()\n   * 2. Pass email, password, and optional metadata\n   * 3. Handle errors (duplicate email, weak password, etc.)\n   * 4. Check if email confirmation required\n   *\n   * ### Email Confirmation\n   * If Supabase requires email confirmation:\n   * - `data.user` exists but `data.session` is null\n   * - Throw error prompting user to check email\n   *\n   * ### Metadata Storage\n   * Metadata stored in `user.user_metadata` (Supabase)\n   * Can be accessed later via `user.user_metadata.displayName`\n   */\n  const signUp = async (\n    email: string,\n    password: string,\n    metadata?: { displayName?: string }\n  ) => {\n    const { data, error } = await supabase.auth.signUp({\n      email,\n      password,\n      options: {\n        data: metadata,\n      },\n    })\n\n    if (error) throw error\n\n    if (data.user && !data.session) {\n      throw new Error('Please check your email to confirm your account')\n    }\n  }\n  // CLOSE: Sign Up Function\n\n  /**\n   * REF: Sign In Function\n  /**\n   * ## Sign In Function\n   *\n   * Authenticates existing user with Supabase Auth.\n   *\n   * ### Parameters\n   * - `email`: User's email address\n   * - `password`: User's password\n   *\n   * ### Process\n   * 1. Call Supabase auth.signInWithPassword()\n   * 2. Supabase validates credentials\n   * 3. Returns session with access token\n   * 4. Auth state listener handles session update\n   *\n   * ### Error Handling\n   * Common errors:\n   * - Invalid credentials: Wrong email or password\n   * - Email not confirmed: User hasn't verified email\n   * - User not found: Email doesn't exist\n   *\n   * ### State Updates\n   * On success, auth state listener triggers and:\n   * - Updates session and user state\n   * - Creates profile/settings (if needed)\n   */\n  const signIn = async (email: string, password: string) => {\n    const { error } = await supabase.auth.signInWithPassword({\n      email,\n      password,\n    })\n\n    if (error) throw error\n  }\n  // CLOSE: Sign In Function\n\n  /**\n   * REF: Sign Out Function\n  /**\n   * ## Sign Out Function\n   *\n   * Signs out current user and invalidates session.\n   *\n   * ### Process\n   * 1. Call Supabase auth.signOut()\n   * 2. Invalidates session tokens\n   * 3. Auth state listener updates to null\n   * 4. Protected routes become inaccessible\n   *\n   * ### State Cleanup\n   * Auth state listener sets:\n   * - `session` to null\n   * - `user` to null\n   *\n   * ### Error Handling\n   * Rare but can fail if:\n   * - Network issues\n   * - Already signed out\n   */\n  const signOut = async () => {\n    const { error } = await supabase.auth.signOut()\n    if (error) throw error\n  }\n  // CLOSE: Sign Out Function\n\n  /**\n   * REF: Context Value and Provider\n  /**\n   * ## Context Value Object\n   *\n   * Combines all state and functions into context value.\n   *\n   * ### Properties\n   * - Current state: user, session, loading\n   * - Auth methods: signUp, signIn, signOut\n   */\n  const value = {\n    user,\n    session,\n    loading,\n    signUp,\n    signIn,\n    signOut,\n  }\n\n  /**\n   * ## Provider Render\n   *\n   * Wraps children with AuthContext.Provider, making auth\n   * state and methods available to all descendant components.\n   */\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>\n}\n// CLOSE: Context Value and Provider\n\n/**\n * REF: useAuth Hook\n/**\n * ## useAuth Custom Hook\n *\n * Hook for accessing auth context in components.\n *\n * ### Usage\n * ```typescript\n * const { user, loading, signIn, signOut } = useAuth()\n * ```\n *\n * ### Error Handling\n * Throws error if used outside AuthProvider.\n * This ensures auth context is always properly initialized.\n *\n * ### Pattern Benefits\n * - Type-safe access to auth context\n * - Clear error messages for misuse\n * - No need to check for undefined\n */\nexport function useAuth() {\n  const context = useContext(AuthContext)\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider')\n  }\n  return context\n}\n// CLOSE: useAuth Hook\n\n/**\n * REF: Usage Examples\n/**\n * ## Using Auth with Drizzle Queries\n *\n * Examples of combining Supabase auth with Drizzle database operations.\n *\n * ### In Client Components\n * ```typescript\n * import { useAuth } from '@/contexts/AuthContext'\n * import { getUserTodos } from '@/lib/db/queries'\n *\n * function TodoList() {\n *   const { user } = useAuth()\n *   const [todos, setTodos] = useState([])\n *\n *   useEffect(() => {\n *     if (!user) return\n *\n *     // Fetch with Drizzle (type-safe!)\n *     getUserTodos(user.id).then(setTodos)\n *   }, [user])\n *\n *   if (!user) {\n *     return <p>Please sign in</p>\n *   }\n *\n *   return <div>{/* Render todos */}</div>\n * }\n * ```\n *\n * ### Clean Separation of Concerns\n * - Auth state: From Supabase context via useAuth()\n * - Database queries: From Drizzle helpers (getUserTodos)\n * - No mixing of auth and database logic\n */\n\n/**\n * ## File Uploads with Hybrid Approach\n *\n * Supabase for storage, Drizzle for metadata.\n *\n * ### Upload Pattern\n * ```typescript\n * import { createClient } from '@/lib/supabase/client'\n * import { db } from '@/lib/db/client'\n * import { todoAttachments } from '@/lib/db/schema'\n *\n * async function uploadFile(todoId: string, file: File) {\n *   const supabase = createClient()\n *\n *   // 1. Upload file to Supabase Storage\n *   const filePath = `${todoId}/${file.name}`\n *   const { data, error } = await supabase.storage\n *     .from('attachments')\n *     .upload(filePath, file)\n *\n *   if (error) throw error\n *\n *   // 2. Save metadata to database with Drizzle\n *   await db.insert(todoAttachments).values({\n *     todoId,\n *     fileName: file.name,\n *     fileUrl: data.path,\n *     fileSize: file.size,\n *     mimeType: file.type,\n *   })\n *\n *   // 3. Get public URL\n *   const { data: urlData } = supabase.storage\n *     .from('attachments')\n *     .getPublicUrl(data.path)\n *\n *   return urlData.publicUrl\n * }\n * ```\n *\n * ### Benefits\n * - Supabase handles file storage (CDN, access control)\n * - Drizzle handles metadata (type-safe, queryable)\n * - Best of both worlds\n *\n * ## Real-time Updates with Hybrid Approach\n *\n * Supabase broadcasts changes, Drizzle fetches data.\n *\n * ### Real-time Pattern\n * ```typescript\n * import { createClient } from '@/lib/supabase/client'\n * import { getUserTodos } from '@/lib/db/queries'\n *\n * function TodoList() {\n *   const { user } = useAuth()\n *   const [todos, setTodos] = useState([])\n *   const supabase = createClient()\n *\n *   useEffect(() => {\n *     if (!user) return\n *\n *     // Initial fetch with Drizzle\n *     getUserTodos(user.id).then(setTodos)\n *\n *     // Subscribe to changes with Supabase\n *     const channel = supabase\n *       .channel('todos')\n *       .on('postgres_changes', {\n *         event: '*',\n *         schema: 'public',\n *         table: 'todos',\n *         filter: `userId=eq.${user.id}`\n *       }, async () => {\n *         // Refetch with Drizzle when changes occur\n *         const updated = await getUserTodos(user.id)\n *         setTodos(updated)\n *       })\n *       .subscribe()\n *\n *     return () => {\n *       supabase.removeChannel(channel)\n *     }\n *   }, [user])\n *\n *   return <div>{/* Render todos */}</div>\n * }\n * ```\n *\n * ### Benefits\n * - Supabase broadcasts changes in real-time\n * - Drizzle fetches with perfect type inference\n * - Automatic UI updates on data changes\n * - Type-safe throughout\n *\n * CLOSE: Usage Examples\n */\n",
      "language": "typescript"
    },
    {
      "path": "drizzle.config.ts",
      "content": "/**\n * Drizzle Kit Configuration\n *\n * REF: Drizzle Kit Configuration for Migration Management\n *\n * This file configures Drizzle Kit - the CLI tool that handles database\n * migrations, schema introspection, and the visual database studio.\n *\n * ## Drizzle ORM vs Drizzle Kit\n *\n * | `Aspect` | Drizzle ORM | Drizzle Kit |\n * |--------|-------------|-------------|\n * | Purpose | Runtime database queries | Build-time migrations |\n * | When Used | Application code | Development/deployment |\n * | `Package` | drizzle-orm | drizzle-kit |\n * | `Runs` | In production | In development |\n * | `Output` | Query results | SQL migration files |\n *\n * ## Drizzle Kit Commands\n *\n * | `Command` | `Script` | Purpose | `Output` |\n * |---------|--------|---------|--------|\n * | `generate` | npm run db:generate | Create migration SQL | drizzle/*.sql |\n * | `push` | npm run db:push | Apply to database | Updates DB schema |\n * | `studio` | npm run db:studio | Visual editor | Opens UI at local.drizzle.studio |\n * | `check` | drizzle-kit check | Validate schema | Shows errors/warnings |\n * | `introspect` | drizzle-kit introspect | Reverse engineer | Creates schema from DB |\n *\n * ## Configuration Options\n *\n * **schema:** Path to schema files\n * - Single file: './lib/db/schema.ts'\n * - Multiple files: './lib/db/*.schema.ts'\n * - Glob pattern: './lib/db/**\\/*.ts'\n *\n * **out:** Migration output directory\n * - Where to save .sql files\n * - Usually 'drizzle/' or 'migrations/'\n * - Commit to version control\n *\n * **driver:** Database type\n * - 'pg' for PostgreSQL (this project)\n * - 'mysql2' for MySQL\n * - 'better-sqlite3' for SQLite\n * - 'turso' for libSQL\n *\n * **dbCredentials:** Connection details\n * - connectionString for PostgreSQL\n * - host/port/database for others\n * - Uses environment variables\n *\n * CLOSE: Drizzle Kit Configuration for Migration Management\n */\n\nimport type { Config } from 'drizzle-kit'\nimport * as dotenv from 'dotenv'\n\n/**\n * REF: Environment Variable Loading\n *\n * Manually load .env.local because Drizzle Kit runs outside Next.js context.\n *\n * ## Why Manual Loading?\n *\n * | `Context` | Env Loading | `Why` |\n * |---------|-------------|-----|\n * | Next.js App | `Automatic` | Built into Next.js |\n * | Drizzle Kit | Manual (dotenv) | Runs as CLI tool, not in Next.js |\n * | This File | `dotenv.config()` | Need DATABASE_URL for migrations |\n *\n * **Without dotenv.config():**\n * - process.env.DATABASE_URL would be undefined\n * - Drizzle Kit commands would fail\n * - No connection to database\n *\n * **With dotenv.config():**\n * - Loads variables from .env.local\n * - Makes DATABASE_URL available\n * - Drizzle Kit can connect to database\n *\n * CLOSE: Environment Variable Loading\n */\ndotenv.config({ path: '.env.local' })\n\n/**\n * REF: Drizzle Kit Configuration Object\n *\n * Main configuration for migration generation and database management.\n *\n * ## Configuration Reference\n *\n * | `Option` | Type | `Required` | Description |\n * |--------|------|----------|-------------|\n * | `schema` | `string` | `Yes` | Path to schema files |\n * | `out` | `string` | `Yes` | Migration output directory |\n * | `driver` | `string` | `Yes` | Database driver type |\n * | `dbCredentials` | `object` | `Yes` | Connection details |\n * | `verbose` | `boolean` | `No` | Detailed logging |\n * | `strict` | `boolean` | `No` | Fail on warnings |\n *\n * CLOSE: Drizzle Kit Configuration Object\n */\nexport default {\n  /**\n   * REF: Schema Location\n   *\n   * Path to TypeScript schema definitions.\n   *\n   * **Single File (this project):**\n   * ```typescript\n   * schema: './lib/db/schema.ts'\n   * ```\n   *\n   * **Multiple Files:**\n   * ```typescript\n   * schema: './lib/db/*.schema.ts'\n   * ```\n   *\n   * **Nested Directories:**\n   * ```typescript\n   * schema: './lib/db/**\\/*.ts'\n   * ```\n   *\n   * CLOSE: Schema Location\n   */\n  schema: './lib/db/schema.ts',\n\n  /**\n   * REF: Migration Output Directory\n   *\n   * Where generated SQL migration files are saved.\n   *\n   * ## Migration Files Created\n   *\n   * ```\n   * drizzle/\n   * ‚îú‚îÄ‚îÄ 0000_initial_schema.sql\n   * ‚îú‚îÄ‚îÄ 0001_add_messages_table.sql\n   * ‚îú‚îÄ‚îÄ 0002_add_indexes.sql\n   * ‚îî‚îÄ‚îÄ meta/\n   *     ‚îú‚îÄ‚îÄ 0000_snapshot.json\n   *     ‚îú‚îÄ‚îÄ 0001_snapshot.json\n   *     ‚îî‚îÄ‚îÄ _journal.json\n   * ```\n   *\n   * **Important:**\n   * - Apply migrations in numerical order\n   * - Commit to version control\n   * - Don't modify after applying\n   * - meta/ folder tracks migration state\n   *\n   * CLOSE: Migration Output Directory\n   */\n  out: './drizzle',\n\n  /**\n   * REF: Database Driver\n   *\n   * Specifies which database type to use.\n   *\n   * ## Supported Drivers\n   *\n   * | `Driver` | `Database` | `Package` |\n   * |--------|----------|---------|\n   * | `pg` | `PostgreSQL` | `postgres` |\n   * | `mysql2` | `MySQL` | `mysql2` |\n   * | better-sqlite3 | `SQLite` | better-sqlite3 |\n   * | `turso` | Turso/libSQL | @libsql/client |\n   *\n   * **This Project:** PostgreSQL (pg)\n   * **Why:** Supabase uses PostgreSQL\n   *\n   * CLOSE: Database Driver\n   */\n  driver: 'pg',\n\n  /**\n   * REF: Database Credentials\n   *\n   * Connection details for PostgreSQL database.\n   *\n   * ## PostgreSQL Connection String Format\n   *\n   * ```\n   * postgresql://[user]:[password]@[host]:[port]/[database]\n   * ```\n   *\n   * ## Supabase Connection String\n   *\n   * ```\n   * postgresql://postgres:[PASSWORD]@db.[PROJECT-REF].supabase.co:5432/postgres\n   * ```\n   *\n   * **Finding Your Connection String:**\n   * 1. Go to Supabase Dashboard\n   * 2. Project Settings ‚Üí Database\n   * 3. Connection String ‚Üí URI\n   * 4. Copy and add to .env.local\n   *\n   * ## Security Best Practices\n   *\n   * - Store in .env.local (never commit)\n   * - Add .env.local to .gitignore\n   * - Use different credentials per environment\n   * - Rotate passwords regularly\n   * - Don't share connection strings\n   *\n   * CLOSE: Database Credentials\n   */\n  dbCredentials: {\n    connectionString: process.env.DATABASE_URL!,\n  },\n\n  /**\n   * REF: Verbose Logging\n   *\n   * Enable detailed console output during operations.\n   *\n   * **When true:**\n   * - Shows SQL being generated\n   * - Displays connection status\n   * - Logs each migration step\n   * - Helpful for debugging\n   *\n   * **When false:**\n   * - Minimal output\n   * - Only errors shown\n   * - Cleaner logs\n   *\n   * CLOSE: Verbose Logging\n   */\n  verbose: true,\n\n  /**\n   * REF: Strict Mode\n   *\n   * Fail fast on warnings and potential issues.\n   *\n   * **When true:**\n   * - Warnings become errors\n   * - Generation fails on issues\n   * - Ensures clean migrations\n   * - Good for CI/CD\n   *\n   * **When false:**\n   * - Warnings allowed\n   * - Generation continues\n   * - More permissive\n   *\n   * **Recommendation:** Keep true for production\n   *\n   * CLOSE: Strict Mode\n   */\n  strict: true,\n} satisfies Config\n\n/**\n * REF: Complete Migration Workflow\n *\n * Step-by-step process for evolving your database schema.\n *\n * ## Workflow Steps\n *\n * | `Step` | `Action` | `Command` | `Output` |\n * |------|--------|---------|--------|\n * | `1` | Modify Schema | Edit schema.ts | Updated TypeScript |\n * | `2` | Generate SQL | npm run db:generate | Migration .sql file |\n * | `3` | Review SQL | Open drizzle/*.sql | Verify changes |\n * | `4` | Apply Migration | npm run db:push | Database updated |\n * | `5` | Commit Files | git add/commit | Version controlled |\n *\n * ## Detailed Example\n *\n * **1. Modify Schema:**\n * ```typescript\n * // lib/db/schema.ts\n * export const todos = pgTable('todos', {\n *   id: uuid('id').primaryKey(),\n *   title: text('title').notNull(),\n *   priority: integer('priority').default(0), // NEW FIELD\n * })\n * ```\n *\n * **2. Generate Migration:**\n * ```bash\n * npm run db:generate\n * # Output: Created drizzle/0003_add_priority.sql\n * ```\n *\n * **3. Review Generated SQL:**\n * ```sql\n * -- drizzle/0003_add_priority.sql\n * ALTER TABLE todos ADD COLUMN priority INTEGER DEFAULT 0;\n * ```\n *\n * **4. Apply to Database:**\n * ```bash\n * npm run db:push\n * # Applies all pending migrations\n * ```\n *\n * **5. Commit to Git:**\n * ```bash\n * git add drizzle/0003_add_priority.sql\n * git add drizzle/meta/\n * git commit -m \"Add priority field to todos\"\n * ```\n *\n * CLOSE: Complete Migration Workflow\n */\n\n/**\n * REF: Drizzle Studio - Visual Database Editor\n *\n * Built-in database admin UI for browsing and editing data.\n *\n * ## Starting Drizzle Studio\n *\n * ```bash\n * npm run db:studio\n * # Opens: https://local.drizzle.studio\n * ```\n *\n * ## Features\n *\n * | Feature | Description | Similar To |\n * |---------|-------------|------------|\n * | Browse Tables | View all tables and columns | `phpMyAdmin` |\n * | Edit Data | Insert, update, delete records | `TablePlus` |\n * | Run Queries | Execute SQL directly | `pgAdmin` |\n * | View Relations | See foreign key relationships | `DataGrip` |\n * | Export Data | Download as JSON/CSV | `DBeaver` |\n * | Generate Queries | Get Drizzle code for operations | `-` |\n *\n * ## Advantages Over Other Tools\n *\n * - **No Installation:** Runs in browser\n * - **Schema Aware:** Knows your Drizzle schema\n * - **Type Safe:** Uses your schema types\n * - **Free:** No license needed\n * - **Integrated:** Part of Drizzle Kit\n *\n * CLOSE: Drizzle Studio - Visual Database Editor\n */\n\n/**\n * REF: Schema Introspection (Reverse Engineering)\n *\n * Generate Drizzle schema from existing database.\n *\n * ## When to Use\n *\n * | `Scenario` | Introspect? | `Why` |\n * |----------|-------------|-----|\n * | Existing database | `Yes` | Start with current schema |\n * | Legacy migration | `Yes` | Convert to Drizzle |\n * | New project | `No` | Write schema directly |\n * | After manual SQL | `Maybe` | Sync schema with DB |\n *\n * ## How to Introspect\n *\n * ```bash\n * drizzle-kit introspect:pg\n * # Generates: lib/db/schema.ts from database\n * ```\n *\n * ## Generated Output\n *\n * Creates TypeScript schema matching your database:\n * ```typescript\n * // Auto-generated from database\n * export const todos = pgTable('todos', {\n *   id: uuid('id').primaryKey(),\n *   title: text('title').notNull(),\n *   // ... all columns from DB\n * })\n * ```\n *\n * CLOSE: Schema Introspection (Reverse Engineering)\n */\n\n/**\n * REF: Comparison with Other Migration Tools\n *\n * How Drizzle Kit compares to alternatives.\n *\n * ## Migration Tools Comparison\n *\n * | Feature | Drizzle Kit | Prisma Migrate | `TypeORM` | `Knex.js` |\n * |---------|-------------|----------------|---------|---------|\n * | Migration Format | `SQL` | Prisma DSL | `TypeScript` | `JavaScript` |\n * | Visual Studio | Yes (built-in) | Yes (separate) | `No` | `No` |\n * | `Introspection` | `Yes` | `Yes` | `Yes` | `No` |\n * | Type Safety | `Perfect` | `Good` | `Good` | `None` |\n * | `Speed` | `Fast` | `Slow` | `Medium` | `Fast` |\n * | Learning Curve | `Low` | `Medium` | `High` | `Low` |\n * | Bundle Size | `Small` | `Large` | `Large` | `Medium` |\n * | SQL Control | `Full` | `Limited` | `Medium` | `Full` |\n *\n * ## Why Choose Drizzle Kit\n *\n * **Best For:**\n * - Perfect TypeScript inference\n * - SQL-first developers\n * - Performance-critical apps\n * - Lightweight bundles\n * - Direct SQL control\n *\n * CLOSE: Comparison with Other Migration Tools\n */\n\n/**\n * REF: Troubleshooting Common Issues\n *\n * Solutions to frequently encountered problems.\n *\n * ## DATABASE_URL Not Found\n *\n * **Error:**\n * ```\n * Error: DATABASE_URL environment variable is required\n * ```\n *\n * **Solutions:**\n * - Verify .env.local exists in project root\n * - Check dotenv.config() path is correct\n * - Ensure variable name is exactly DATABASE_URL\n * - Try: `echo $DATABASE_URL` to verify it loads\n *\n * ## Connection Refused\n *\n * **Error:**\n * ```\n * Error: connect ECONNREFUSED\n * ```\n *\n * **Solutions:**\n * - Verify database is running (Supabase project active)\n * - Check connection string format\n * - Confirm firewall allows connection\n * - Test connection with psql or pgAdmin\n *\n * ## Permission Denied\n *\n * **Error:**\n * ```\n * Error: permission denied for schema public\n * ```\n *\n * **Solutions:**\n * - Use service role key, not anon key\n * - Check user has CREATE/ALTER permissions\n * - Verify user can modify schema\n * - Grant permissions: `GRANT ALL ON SCHEMA public TO user`\n *\n * ## Migration Already Applied\n *\n * **Error:**\n * ```\n * Error: migration 0001 already exists\n * ```\n *\n * **Solutions:**\n * - Check drizzle/meta/_journal.json\n * - Compare with database migration table\n * - May need to manually mark as applied\n * - Don't modify existing migration files\n *\n * CLOSE: Troubleshooting Common Issues\n */\n",
      "language": "typescript"
    },
    {
      "path": "lib/db/client.ts",
      "content": "/**\n * REF: client-file-overview\n *\n * # Drizzle Client Configuration\n *\n * This file initializes the Drizzle ORM instance with a PostgreSQL connection.\n * It serves as the central database client for the entire application.\n *\n * ## Architecture Overview\n *\n * | `Component` | Purpose | Handled By |\n * |-----------|---------|------------|\n * | Database queries | Type-safe data operations | Drizzle ORM (this file) |\n * | User authentication | Sign in/out, sessions | Supabase Auth |\n * | File storage | Upload/download files | Supabase Storage |\n * | Real-time subscriptions | Live data updates | Supabase Realtime |\n *\n * ## Why Drizzle ORM?\n *\n * ### Benefits Over Other ORMs\n *\n * | Feature | `Drizzle` | `Prisma` | `TypeORM` |\n * |---------|---------|--------|---------|\n * | TypeScript Inference | `Perfect` | `Good` | `Fair` |\n * | SQL-like Syntax | `Yes` | `No` | `No` |\n * | Bundle Size | < 10KB | ~20KB | `Large` |\n * | Code Generation | `No` | `Yes` | `Yes` |\n * | Full SQL Support | `Yes` | `Limited` | `Limited` |\n * | `Performance` | `Excellent` | `Good` | `Good` |\n *\n * ## Hybrid Architecture Benefits\n *\n * ### Why Use Both Drizzle and Supabase Client?\n *\n * - **Drizzle**: Perfect for complex queries, joins, type safety\n * - **Supabase Client**: Proven auth system, easy file storage\n * - **Best of Both Worlds**: Type-safe DB + managed services\n *\n * ## File Structure\n *\n * ```\n * lib/db/\n * ‚îú‚îÄ‚îÄ client.ts    ‚Üê This file - Database connection\n * ‚îú‚îÄ‚îÄ schema.ts    ‚Üê Table definitions\n * ‚îî‚îÄ‚îÄ queries.ts   ‚Üê Query functions\n * ```\n */\n// CLOSE: client-file-overview\n\n/**\n * REF: client-imports\n *\n * ## Import Dependencies\n *\n * ## Drizzle ORM Packages\n *\n * | `Import` | `Package` | Purpose |\n * |--------|---------|---------|\n * | `drizzle` | drizzle-orm/postgres-js | Creates Drizzle instance |\n * | `postgres` | `postgres` | PostgreSQL client library |\n * | `* as schema` | ./schema | Table schema definitions |\n *\n * ## Why postgres.js?\n *\n * - Lightweight and fast PostgreSQL client\n * - Connection pooling built-in\n * - Works in Node.js and serverless environments\n * - Compatible with Supabase PostgreSQL\n */\nimport { drizzle } from 'drizzle-orm/postgres-js'\nimport postgres from 'postgres'\nimport * as schema from './schema'\n// CLOSE: client-imports\n\n/**\n * REF: database-connection-string\n *\n * ## Database Connection String\n *\n * The DATABASE_URL environment variable contains the PostgreSQL connection string\n * with authentication credentials and server information.\n *\n * ### Connection String Format\n *\n * ```\n * postgresql://[user]:[password]@[host]:[port]/[database]?[options]\n * ```\n *\n * ### Supabase Connection String Format\n *\n * ```\n * postgresql://postgres:[YOUR_PASSWORD]@db.[PROJECT_REF].supabase.co:5432/postgres\n * ```\n *\n * ### Components Explained\n *\n * | `Component` | `Example` | Description |\n * |-----------|---------|-------------|\n * | `Protocol` | `postgresql://` | Database type |\n * | `User` | `postgres` | Database username (default for Supabase) |\n * | `Password` | `[YOUR_PASSWORD]` | From Supabase dashboard |\n * | `Host` | `db.[PROJECT_REF].supabase.co` | Supabase database server |\n * | `Port` | `5432` | PostgreSQL default port |\n * | `Database` | `postgres` | Database name |\n *\n * ## Finding Your Supabase Connection String\n *\n * 1. Go to Supabase Dashboard\n * 2. Select your project\n * 3. Navigate to Settings ‚Üí Database\n * 4. Find \"Connection string\" section\n * 5. Choose \"URI\" tab\n * 6. Copy the connection string\n * 7. Replace `[YOUR-PASSWORD]` with your actual password\n *\n * ## Security Best Practices\n *\n * | `Practice` | Why Important |\n * |----------|---------------|\n * | Never commit to git | Prevents credential leaks |\n * | Use environment variables | Separates config from code |\n * | Rotate passwords regularly | Limits exposure if compromised |\n * | Use .env.local | Keeps secrets out of repository |\n * | Different creds per environment | Isolates prod from dev |\n *\n * ## Environment Variable Setup\n *\n * Create `.env.local` in project root:\n *\n * ```bash\n * DATABASE_URL=\"postgresql://postgres:password@db.project.supabase.co:5432/postgres\"\n * ```\n *\n * ## Connection String Validation\n *\n * This validation ensures the environment variable is set before the app starts,\n * preventing runtime errors from missing configuration.\n */\nif (!process.env.DATABASE_URL) {\n  throw new Error('DATABASE_URL environment variable is required')\n}\n\nconst connectionString = process.env.DATABASE_URL\n// CLOSE: database-connection-string\n\n/**\n * REF: postgres-client-configuration\n *\n * ## PostgreSQL Client Configuration\n *\n * Creates a postgres.js client with a connection pool for efficient database access.\n *\n * ## Connection Pooling\n *\n * Connection pooling reuses database connections instead of creating new ones\n * for each query, dramatically improving performance.\n *\n * ### How Connection Pooling Works\n *\n * ```\n * Request 1 ‚îÄ‚îÄ‚Üí [Pool] ‚îÄ‚îÄ‚Üí Connection A ‚îÄ‚îÄ‚Üí Database\n * Request 2 ‚îÄ‚îÄ‚Üí [Pool] ‚îÄ‚îÄ‚Üí Connection B ‚îÄ‚îÄ‚Üí Database\n * Request 3 ‚îÄ‚îÄ‚Üí [Pool] ‚îÄ‚îÄ‚Üí (waits) ‚îÄ‚îÄ‚Üí Connection A ‚îÄ‚îÄ‚Üí Database\n * ```\n *\n * ### Configuration Options\n *\n * | `Option` | Default | Purpose |\n * |--------|---------|---------|\n * | `prepare` | `true` | Enable prepared statements (must be false for Supabase) |\n * | `max` | `10` | Maximum connections in pool |\n * | `idle_timeout` | `0` | Seconds before closing idle connections |\n * | `connect_timeout` | `30` | Seconds to wait for connection |\n *\n * ## Why prepare: false?\n *\n * Supabase uses **Transaction Pooling Mode** by default:\n *\n * | Pool Mode | Prepared Statements | Connection Limit | Best For |\n * |-----------|-------------------|------------------|----------|\n * | `Transaction` | `No` | High (unlimited) | Serverless, high traffic |\n * | `Session` | `Yes` | Low (~60) | Traditional servers |\n *\n * ### Transaction vs Session Mode\n *\n * **Transaction Mode** (Supabase default):\n * - Connection assigned per transaction\n * - No prepared statements\n * - Supports many concurrent connections\n * - Perfect for serverless/edge functions\n *\n * **Session Mode**:\n * - Connection assigned for entire session\n * - Prepared statements supported\n * - Limited concurrent connections\n * - Better for long-running processes\n *\n * ## Additional Configuration Options\n *\n * ```typescript\n * const client = postgres(connectionString, {\n *   prepare: false,           // Required for Supabase\n *   max: 20,                  // Increase pool size\n *   idle_timeout: 20,         // Close idle after 20s\n *   connect_timeout: 10,      // Fail after 10s\n *   ssl: 'require',           // Enforce SSL\n *   onnotice: () => {},       // Suppress notices\n * })\n * ```\n *\n * ## Example Usage\n *\n * The client is used internally by Drizzle but can also execute raw SQL:\n *\n * ```typescript\n * // Raw query (if needed)\n * const result = await client`SELECT * FROM todos WHERE id = ${todoId}`\n * ```\n */\nconst client = postgres(connectionString, { prepare: false })\n// CLOSE: postgres-client-configuration\n\n/**\n * REF: drizzle-instance\n *\n * ## Drizzle ORM Instance\n *\n * Creates the main Drizzle database instance that provides type-safe query builders\n * and automatic type inference from the schema.\n *\n * ### Initialization Parameters\n *\n * | Parameter | Type | Purpose |\n * |-----------|------|---------|\n * | `client` | PostgreSQL client | Connection to database |\n * | `schema` | Schema object | Table definitions for type inference |\n *\n * ## The Magic of Drizzle\n *\n * Drizzle provides several \"magical\" features that make development easier:\n *\n * ### 1. Automatic Type Inference\n *\n * No manual type annotations needed:\n *\n * ```typescript\n * // Drizzle automatically knows the return type!\n * const todos = await db.select().from(todos)\n * // TypeScript knows: Todo[]\n *\n * todos[0].title   // ‚úÖ TypeScript knows this is a string\n * todos[0].fake    // ‚ùå TypeScript error - property doesn't exist\n * ```\n *\n * ### 2. Perfect Autocomplete\n *\n * Your IDE provides intelligent suggestions:\n *\n * ```typescript\n * db.select().from(todos).where(eq(todos.   // IDE suggests all column names\n * ```\n *\n * ### 3. Compile-Time Type Checking\n *\n * Errors caught before running code:\n *\n * ```typescript\n * // ‚ùå TypeScript error - completed is boolean, not string\n * db.update(todos).set({ completed: 'yes' })\n *\n * // ‚úÖ Correct\n * db.update(todos).set({ completed: true })\n * ```\n *\n * ### 4. No Code Generation\n *\n * Unlike Prisma, Drizzle doesn't require a separate generation step:\n *\n * | `ORM` | `Workflow` |\n * |-----|----------|\n * | `Prisma` | Edit schema ‚Üí Generate ‚Üí Use |\n * | `Drizzle` | Edit schema ‚Üí Use immediately |\n *\n * ## Schema Integration\n *\n * By passing the schema to Drizzle, we enable:\n * - Relational queries with `.query` API\n * - Type inference for all tables\n * - Automatic JOIN generation\n * - Nested data fetching\n *\n * ## Usage Examples\n *\n * ```typescript\n * // Import the db instance\n * import { db } from '@/lib/db/client'\n * import { todos } from '@/lib/db/schema'\n * import { eq } from 'drizzle-orm'\n *\n * // Simple query\n * const allTodos = await db.select().from(todos)\n *\n * // Filtered query\n * const userTodos = await db\n *   .select()\n *   .from(todos)\n *   .where(eq(todos.userId, userId))\n *\n * // Insert with returning\n * const [newTodo] = await db\n *   .insert(todos)\n *   .values({ userId, title: 'New todo' })\n *   .returning()\n *\n * // Relational query\n * const todosWithAttachments = await db.query.todos.findMany({\n *   with: { attachments: true }\n * })\n * ```\n */\nexport const db = drizzle(client, { schema })\n// CLOSE: drizzle-instance\n\n/**\n * REF: query-builder-examples\n *\n * ## Query Builder Examples\n *\n * Comprehensive examples of common database operations using Drizzle's query builder.\n *\n * ### SELECT Queries\n *\n * ```typescript\n * import { db } from './client'\n * import { todos } from './schema'\n * import { eq, and, desc } from 'drizzle-orm'\n *\n * // Simple SELECT\n * const allTodos = await db.select().from(todos)\n *\n * // With WHERE clause\n * const userTodos = await db\n *   .select()\n *   .from(todos)\n *   .where(eq(todos.userId, userId))\n *\n * // With multiple conditions\n * const completedUserTodos = await db\n *   .select()\n *   .from(todos)\n *   .where(and(\n *     eq(todos.userId, userId),\n *     eq(todos.completed, true)\n *   ))\n *\n * // With ORDER BY\n * const sortedTodos = await db\n *   .select()\n *   .from(todos)\n *   .where(eq(todos.userId, userId))\n *   .orderBy(desc(todos.createdAt))\n * ```\n *\n * ### INSERT Queries\n *\n * ```typescript\n * // Insert single record\n * const [newTodo] = await db\n *   .insert(todos)\n *   .values({\n *     userId,\n *     title: 'New todo',\n *     completed: false,\n *   })\n *   .returning()\n *\n * // Insert multiple records\n * const newTodos = await db\n *   .insert(todos)\n *   .values([\n *     { userId, title: 'Todo 1' },\n *     { userId, title: 'Todo 2' },\n *   ])\n *   .returning()\n * ```\n *\n * ### UPDATE Queries\n *\n * ```typescript\n * // Update single record\n * await db\n *   .update(todos)\n *   .set({ completed: true, updatedAt: new Date() })\n *   .where(eq(todos.id, todoId))\n *\n * // Update with returning\n * const [updated] = await db\n *   .update(todos)\n *   .set({ title: 'Updated title' })\n *   .where(eq(todos.id, todoId))\n *   .returning()\n * ```\n *\n * ### DELETE Queries\n *\n * ```typescript\n * // Delete single record\n * await db\n *   .delete(todos)\n *   .where(eq(todos.id, todoId))\n *\n * // Delete multiple records\n * await db\n *   .delete(todos)\n *   .where(eq(todos.userId, userId))\n * ```\n *\n * ### JOIN Queries\n *\n * ```typescript\n * import { todoAttachments } from './schema'\n *\n * // LEFT JOIN\n * const todosWithAttachments = await db\n *   .select({\n *     todo: todos,\n *     attachment: todoAttachments,\n *   })\n *   .from(todos)\n *   .leftJoin(todoAttachments, eq(todos.id, todoAttachments.todoId))\n *   .where(eq(todos.userId, userId))\n * ```\n */\n// CLOSE: query-builder-examples\n\n/**\n * REF: relational-queries-api\n *\n * ## Relational Queries API\n *\n * Drizzle's relational API provides a cleaner way to fetch related data without\n * writing explicit JOINs.\n *\n * ### Basic Relational Query\n *\n * ```typescript\n * // Get todos with their attachments\n * const todosWithAttachments = await db.query.todos.findMany({\n *   where: eq(todos.userId, userId),\n *   with: {\n *     attachments: true,\n *   },\n * })\n * ```\n *\n * ### Nested Relations\n *\n * ```typescript\n * // Multiple levels of nesting\n * const users = await db.query.users.findMany({\n *   with: {\n *     todos: {\n *       with: {\n *         attachments: true\n *       }\n *     }\n *   }\n * })\n * ```\n *\n * ### Filtering Relations\n *\n * ```typescript\n * // Get todos with only image attachments\n * const todos = await db.query.todos.findMany({\n *   with: {\n *     attachments: {\n *       where: sql`mime_type LIKE 'image/%'`\n *     }\n *   }\n * })\n * ```\n *\n * ### Benefits\n *\n * - No manual JOIN syntax\n * - Automatic type inference for nested objects\n * - Cleaner, more readable code\n * - Prevents N+1 query problems\n */\n// CLOSE: relational-queries-api\n\n/**\n * REF: transactions-overview\n *\n * ## Database Transactions\n *\n * Transactions ensure data consistency by making multiple operations atomic.\n *\n * ### Basic Transaction\n *\n * ```typescript\n * await db.transaction(async (tx) => {\n *   const [todo] = await tx\n *     .insert(todos)\n *     .values({ userId, title })\n *     .returning()\n *\n *   await tx\n *     .insert(todoAttachments)\n *     .values({ todoId: todo.id, fileName, fileUrl })\n *\n *   // If ANY operation fails, ALL operations are rolled back\n * })\n * ```\n *\n * ### Error Handling in Transactions\n *\n * ```typescript\n * try {\n *   const result = await db.transaction(async (tx) => {\n *     // Your operations\n *     return someValue\n *   })\n * } catch (error) {\n *   // Transaction was automatically rolled back\n *   console.error('Transaction failed:', error)\n * }\n * ```\n *\n * See queries.ts for more transaction examples.\n */\n// CLOSE: transactions-overview\n\n/**\n * REF: raw-sql-execution\n *\n * ## Raw SQL Execution\n *\n * For complex queries not supported by the query builder, use raw SQL.\n *\n * ### Using sql Template\n *\n * ```typescript\n * import { sql } from 'drizzle-orm'\n *\n * // Full-text search\n * const results = await db.execute(sql`\n *   SELECT *\n *   FROM todos\n *   WHERE to_tsvector('english', title) @@ plainto_tsquery('english', ${searchTerm})\n * `)\n *\n * // Complex aggregations\n * const stats = await db.execute(sql`\n *   SELECT\n *     user_id,\n *     COUNT(*) as total_todos,\n *     SUM(CASE WHEN completed THEN 1 ELSE 0 END) as completed_count\n *   FROM todos\n *   GROUP BY user_id\n * `)\n * ```\n *\n * ### When to Use Raw SQL\n *\n * - PostgreSQL-specific features (full-text search, JSON operators)\n * - Complex aggregations\n * - Window functions\n * - CTEs (Common Table Expressions)\n * - Performance-critical queries requiring specific optimization\n */\n// CLOSE: raw-sql-execution\n\n/**\n * REF: migrations-workflow\n *\n * ## Migrations Workflow\n *\n * Drizzle Kit generates and manages database migrations based on schema changes.\n *\n * ### Generate Migration\n *\n * ```bash\n * npm run db:generate\n * ```\n *\n * This creates SQL files in the `drizzle/` folder based on schema changes.\n *\n * ### Push to Database\n *\n * ```bash\n * npm run db:push\n * ```\n *\n * Applies migrations directly to the database (dev/prototyping).\n *\n * ### Apply Migrations to Supabase\n *\n * 1. Generate migration with `npm run db:generate`\n * 2. Copy SQL from `drizzle/` folder\n * 3. Paste into Supabase SQL Editor\n * 4. Run the migration\n *\n * ### Migration Best Practices\n *\n * - Always review generated SQL before applying\n * - Test migrations on staging environment first\n * - Keep migrations in version control\n * - Never edit applied migrations\n * - Create new migration for changes\n */\n// CLOSE: migrations-workflow\n\n/**\n * REF: performance-characteristics\n *\n * ## Performance Characteristics\n *\n * Drizzle is designed for optimal performance with minimal overhead.\n *\n * ### Performance Features\n *\n * | Feature | Benefit |\n * |---------|---------|\n * | No N+1 queries | Relational API uses JOINs |\n * | Efficient SQL generation | Only fetches needed data |\n * | Connection pooling | Reuses connections |\n * | Prepared statements | When supported by pool mode |\n * | Minimal runtime | Small bundle size |\n *\n * ### Benchmarks\n *\n * Compared to other ORMs:\n * - **vs Prisma**: ~2x faster queries\n * - **vs TypeORM**: Similar or better performance\n * - **vs Raw SQL**: < 1% overhead\n *\n * ### Optimization Tips\n *\n * See queries.ts performance-optimization-tips section for detailed guidance.\n */\n// CLOSE: performance-characteristics\n\n/**\n * REF: debugging-tools\n *\n * ## Debugging Tools\n *\n * Tools for inspecting generated SQL and diagnosing issues.\n *\n * ### View Generated SQL\n *\n * ```typescript\n * const query = db.select().from(todos).toSQL()\n * console.log(query.sql)    // SELECT * FROM todos\n * console.log(query.params) // []\n * ```\n *\n * ### Enable Query Logging\n *\n * ```typescript\n * const db = drizzle(client, {\n *   schema,\n *   logger: true  // Logs all queries to console\n * })\n * ```\n *\n * See queries.ts debugging-queries section for more tools.\n */\n// CLOSE: debugging-tools\n\n/**\n * REF: supabase-auth-integration\n *\n * ## Supabase Auth Integration\n *\n * Important considerations when using Drizzle with Supabase authentication.\n *\n * ## Row Level Security (RLS)\n *\n * **Critical**: Drizzle does NOT automatically enforce Supabase Row Level Security!\n *\n * ### Security Options\n *\n * ### Option 1: Service Role Key (Server-side only)\n *\n * ```typescript\n * // Uses DATABASE_URL with service role credentials\n * // Bypasses RLS - YOU must enforce security in code\n * // NEVER expose service role key to client!\n * ```\n *\n * ### Option 2: Supabase Client with RLS\n *\n * ```typescript\n * // Use Supabase client for RLS-protected operations\n * const { data } = await supabase\n *   .from('todos')\n *   .select('*')\n *   .eq('user_id', userId)\n * ```\n *\n * ### Option 3: Hybrid Approach (Recommended)\n *\n * | `Operation` | `Use` | `Why` |\n * |-----------|-----|-----|\n * | Complex queries | `Drizzle` | Type safety, joins, complex logic |\n * | User-specific data | Supabase Client | RLS enforced automatically |\n * | Server actions | `Drizzle` | Full control, type safety |\n * | Client components | Supabase Client | RLS protection |\n *\n * ### Best Practices\n *\n * 1. Use Drizzle in server-side code only\n * 2. Always validate user authentication\n * 3. Manually check user ownership in queries\n * 4. Use Supabase client for RLS when appropriate\n * 5. Never send service role credentials to client\n */\n// CLOSE: supabase-auth-integration\n\n/**\n * REF: exports\n *\n * ## Module Exports\n *\n * Export the database instance for use throughout the application.\n */\nexport default db\n// CLOSE: exports\n",
      "language": "typescript"
    },
    {
      "path": "lib/db/queries.ts",
      "content": "/**\n * REF: queries-file-overview\n *\n * # Drizzle Query Helpers - Type-Safe Database Operations\n *\n * This file contains reusable, type-safe database queries using Drizzle ORM.\n * Each function provides a clean API for common database operations with perfect\n * TypeScript type inference.\n *\n * ## Core Concepts\n *\n * | `Concept` | Description |\n * |---------|-------------|\n * | Type-safe queries | Drizzle provides compile-time type checking for all queries |\n * | Reusable operations | Functions encapsulate common patterns for DRY code |\n * | SQL-like syntax | Familiar query building with TypeScript benefits |\n * | Automatic inference | Return types derived from schema definitions |\n *\n * ## Benefits of Helper Functions\n *\n * - **DRY Principle**: Avoid repeating query logic across your application\n * - **Consistent Error Handling**: Centralized error management\n * - **Easier Testing**: Mock individual query functions\n * - **Single Optimization Point**: Performance improvements benefit all callers\n * - **Type Safety**: TypeScript catches errors before runtime\n *\n * ## File Organization\n *\n * Functions are organized by entity type:\n * 1. Todo Queries - CRUD operations for todos\n * 2. Public Feed Queries - Public todo discovery and search\n * 3. User Settings Queries - User preference management\n * 4. Message Queries - Messaging between users\n * 5. Attachment Queries - File attachment management\n */\n// CLOSE: queries-file-overview\n\n/**\n * REF: queries-imports\n *\n * ## Import Dependencies\n *\n * ### Drizzle ORM Operators\n *\n * | `Import` | Purpose | Example Usage |\n * |--------|---------|---------------|\n * | `eq` | Equality comparison | `where(eq(todos.id, '123'))` |\n * | `and` | Logical AND | `where(and(eq(...), eq(...)))` |\n * | `desc` | Descending sort | `orderBy(desc(todos.createdAt))` |\n * | `sql` | Raw SQL expressions | `sql\\`count(*)\\`` |\n *\n * ### Local Dependencies\n *\n * | `Import` | `Source` | Purpose |\n * |--------|--------|---------|\n * | `db` | `./client` | Drizzle database instance |\n * | `todos` | `./schema` | Todos table schema |\n * | `userSettings` | `./schema` | User settings table schema |\n * | `messages` | `./schema` | Messages table schema |\n * | `todoAttachments` | `./schema` | Attachments table schema |\n */\nimport { eq, and, desc, sql } from 'drizzle-orm'\nimport { db } from './client'\nimport { todos, userSettings, messages, todoAttachments } from './schema'\n// CLOSE: queries-imports\n\n/**\n * REF: todo-queries-section\n *\n * ## Todo CRUD Operations\n *\n * Functions for creating, reading, updating, and deleting todos. All functions\n * include proper type safety and handle the common use cases for todo management.\n */\n// CLOSE: todo-queries-section\n\n/**\n * REF: get-user-todos\n *\n * ## Get User Todos\n *\n * Retrieves all todos for a specific user, sorted by creation date (newest first).\n *\n * ### Parameters\n *\n * | Name | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `userId` | `string` | `Yes` | The authenticated user's unique identifier |\n *\n * ### Returns\n *\n * `Promise<Todo[]>` - Array of todo objects with all fields\n *\n * ### Query Breakdown\n *\n * This function demonstrates the basic Drizzle query pattern:\n *\n * 1. `db.select()` - Initiates a SELECT query (selects all columns by default)\n * 2. `.from(todos)` - Specifies the source table\n * 3. `.where(eq(todos.userId, userId))` - Filters by user ID\n * 4. `.orderBy(desc(todos.createdAt))` - Sorts newest first\n *\n * ### SQL Equivalent\n *\n * ```sql\n * SELECT *\n * FROM todos\n * WHERE user_id = $1\n * ORDER BY created_at DESC\n * ```\n *\n * ### Type Inference\n *\n * Drizzle automatically infers the return type from the schema. No manual type\n * annotations needed! TypeScript knows the exact shape of each todo object.\n *\n * ### Example Usage\n *\n * ```typescript\n * const todos = await getUserTodos('user-123')\n * todos[0].title // TypeScript knows this is a string\n * todos[0].completed // TypeScript knows this is a boolean\n * ```\n */\nexport async function getUserTodos(userId: string) {\n  return await db\n    .select()\n    .from(todos)\n    .where(eq(todos.userId, userId))\n    .orderBy(desc(todos.createdAt))\n}\n// CLOSE: get-user-todos\n\n/**\n * REF: create-todo\n *\n * ## Create Todo\n *\n * Inserts a new todo into the database and returns the created record with\n * all generated fields (ID, timestamps).\n *\n * ## Parameters\n *\n * | Name | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `data.userId` | `string` | `Yes` | Owner of the todo |\n * | `data.title` | `string` | `Yes` | Todo title/description |\n * | `data.description` | `string` | `No` | Extended description |\n * | `data.isPublic` | `boolean` | `No` | Whether visible in public feed (default: `false`) |\n * | `data.tags` | `string[]` | `No` | Array of tag strings |\n *\n * ## Returns\n *\n * `Promise<Todo>` - The newly created todo object including:\n * - `id` - Auto-generated UUID\n * - `createdAt` - Timestamp of creation\n * - `updatedAt` - Initially same as createdAt\n * - All provided fields\n *\n * ## The RETURNING Clause\n *\n * The `.returning()` method is a PostgreSQL feature that returns the inserted row\n * in a single database round-trip. This is more efficient than:\n *\n * ```typescript\n * // Less efficient approach\n * await db.insert(todos).values(...)\n * const todo = await db.select().from(todos).where(eq(todos.id, id))\n * ```\n *\n * ### SQL Equivalent\n *\n * ```sql\n * INSERT INTO todos (user_id, title, description, is_public, tags, completed)\n * VALUES ($1, $2, $3, $4, $5, false)\n * RETURNING *\n * ```\n *\n * ### Default Values\n *\n * - `completed` is always set to `false` for new todos\n * - `isPublic` defaults to `false` if not provided\n * - Optional fields are set to `null` if not provided\n *\n * ### Example Usage\n *\n * ```typescript\n * const newTodo = await createTodo({\n *   userId: 'user-123',\n *   title: 'Buy groceries',\n *   description: 'Milk, eggs, bread',\n *   isPublic: true,\n *   tags: ['shopping', 'urgent']\n * })\n *\n * console.log(newTodo.id) // Auto-generated UUID\n * console.log(newTodo.completed) // false\n * ```\n */\nexport async function createTodo(data: {\n  userId: string\n  title: string\n  description?: string\n  isPublic?: boolean\n  tags?: string[]\n}) {\n  const [todo] = await db\n    .insert(todos)\n    .values({\n      userId: data.userId,\n      title: data.title,\n      description: data.description || null,\n      isPublic: data.isPublic || false,\n      tags: data.tags || null,\n      completed: false,\n    })\n    .returning()\n\n  return todo\n}\n// CLOSE: create-todo\n\n/**\n * REF: update-todo\n *\n * ## Update Todo\n *\n * Updates one or more fields of an existing todo. Supports partial updates,\n * meaning you only need to provide the fields that changed.\n *\n * ## Parameters\n *\n * | Name | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `todoId` | `string` | `Yes` | ID of the todo to update |\n * | `updates.title` | `string` | `No` | New title |\n * | `updates.description` | `string` | `No` | New description |\n * | `updates.completed` | `boolean` | `No` | Completion status |\n * | `updates.isPublic` | `boolean` | `No` | Public visibility |\n * | `updates.tags` | `string[]` | `No` | New tag array |\n *\n * ## Returns\n *\n * `Promise<Todo>` - The updated todo with all fields\n *\n * ### Partial Updates Pattern\n *\n * This function demonstrates the partial update pattern:\n * - Only send fields that changed\n * - Spread operator merges updates with automatic fields\n * - `updatedAt` is always set to current time\n * - Bandwidth efficient - no need to send entire object\n *\n * ### Type Safety Features\n *\n * TypeScript provides compile-time validation:\n * - Field names must match schema\n * - Field types must match schema\n * - Typos caught before runtime\n *\n * ```typescript\n * // TypeScript error - invalid field\n * updateTodo('id', { invalid: true })\n *\n * // TypeScript error - wrong type\n * updateTodo('id', { completed: 'yes' })\n * ```\n *\n * ### SQL Equivalent\n *\n * ```sql\n * UPDATE todos\n * SET title = $1, updated_at = NOW()\n * WHERE id = $2\n * RETURNING *\n * ```\n *\n * ### Example Usage\n *\n * ```typescript\n * // Update just the completion status\n * await updateTodo('todo-123', { completed: true })\n *\n * // Update multiple fields\n * await updateTodo('todo-123', {\n *   title: 'Updated title',\n *   tags: ['new', 'tags']\n * })\n * ```\n */\nexport async function updateTodo(\n  todoId: string,\n  updates: {\n    title?: string\n    description?: string\n    completed?: boolean\n    isPublic?: boolean\n    tags?: string[]\n  }\n) {\n  const [updated] = await db\n    .update(todos)\n    .set({\n      ...updates,\n      updatedAt: new Date(),\n    })\n    .where(eq(todos.id, todoId))\n    .returning()\n\n  return updated\n}\n// CLOSE: update-todo\n\n/**\n * REF: delete-todo\n *\n * ## Delete Todo\n *\n * Permanently removes a todo from the database. Supports cascade deletion\n * for related records.\n *\n * ## Parameters\n *\n * | Name | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `todoId` | `string` | `Yes` | ID of the todo to delete |\n *\n * ## Returns\n *\n * `Promise<void>` - No return value\n *\n * ### Cascade Deletion\n *\n * If the database schema includes `ON DELETE CASCADE` for related tables,\n * deleting a todo will automatically:\n * - Delete all todo_attachments for this todo\n * - Remove any other related records\n * - Ensure no orphaned data remains\n *\n * ### SQL Equivalent\n *\n * ```sql\n * DELETE FROM todos WHERE id = $1\n * ```\n *\n * ### Example Usage\n *\n * ```typescript\n * await deleteTodo('todo-123')\n * // Todo and all attachments are now deleted\n * ```\n */\nexport async function deleteTodo(todoId: string) {\n  await db\n    .delete(todos)\n    .where(eq(todos.id, todoId))\n}\n// CLOSE: delete-todo\n\n/**\n * REF: public-feed-queries-section\n *\n * ## Public Feed Queries\n *\n * Functions for discovering and searching public todos. These queries power\n * the public feed feature where users can browse todos marked as public.\n */\n// CLOSE: public-feed-queries-section\n\n/**\n * REF: get-public-todos\n *\n * ## Get Public Todos with Pagination\n *\n * Retrieves public todos with pagination support. Returns both the todos and\n * metadata needed for implementing pagination UI.\n *\n * ## Parameters\n *\n * | Name | Type | `Required` | Default | Description |\n * |------|------|----------|---------|-------------|\n * | `limit` | `number` | `No` | `20` | Number of todos per page |\n * | `offset` | `number` | `No` | `0` | Number of todos to skip |\n *\n * ## Returns\n *\n * ```typescript\n * {\n *   todos: Todo[]      // Array of public todos\n *   total: number      // Total count of public todos\n *   hasMore: boolean   // Whether more pages exist\n * }\n * ```\n *\n * ## Advanced Pattern: Parallel Queries\n *\n * This function demonstrates executing multiple queries in parallel using\n * `Promise.all()`. This is more efficient than sequential queries:\n *\n * ```typescript\n * // Efficient - both queries run simultaneously\n * const [todos, count] = await Promise.all([query1, query2])\n *\n * // Less efficient - queries run one after another\n * const todos = await query1\n * const count = await query2\n * ```\n *\n * ## Count Query Pattern\n *\n * The count query uses PostgreSQL's aggregate function with type casting:\n * - `sql<number>\\`count(*)\\`` - Raw SQL for counting\n * - `::int` - Cast to integer type\n * - Returns `{ count: number }` object\n *\n * ### Pagination Metadata\n *\n * - `total` - Used to calculate total pages: `Math.ceil(total / limit)`\n * - `hasMore` - Simple check: if we got a full page, there might be more\n *\n * ### SQL Equivalent\n *\n * ```sql\n * -- Todos query\n * SELECT * FROM todos\n * WHERE is_public = true\n * ORDER BY created_at DESC\n * LIMIT 20 OFFSET 0\n *\n * -- Count query\n * SELECT count(*)::int FROM todos\n * WHERE is_public = true\n * ```\n *\n * ### Example Usage\n *\n * ```typescript\n * // First page\n * const page1 = await getPublicTodos(20, 0)\n *\n * // Second page\n * const page2 = await getPublicTodos(20, 20)\n *\n * // Calculate total pages\n * const totalPages = Math.ceil(page1.total / 20)\n *\n * // Check if \"Next\" button should be shown\n * const showNext = page1.hasMore\n * ```\n */\nexport async function getPublicTodos(limit = 20, offset = 0) {\n  const [todosData, countData] = await Promise.all([\n    // Get todos\n    db\n      .select()\n      .from(todos)\n      .where(eq(todos.isPublic, true))\n      .orderBy(desc(todos.createdAt))\n      .limit(limit)\n      .offset(offset),\n\n    // Get total count for pagination\n    db\n      .select({ count: sql<number>`count(*)::int` })\n      .from(todos)\n      .where(eq(todos.isPublic, true)),\n  ])\n\n  return {\n    todos: todosData,\n    total: countData[0]?.count || 0,\n    hasMore: todosData.length === limit,\n  }\n}\n// CLOSE: get-public-todos\n\n/**\n * REF: search-public-todos\n *\n * ## Search Public Todos\n *\n * Performs full-text search on public todos using PostgreSQL's built-in\n * text search capabilities. Searches both title and description fields.\n *\n * ## Parameters\n *\n * | Name | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `searchTerm` | `string` | `Yes` | Search query (words or phrases) |\n *\n * ## Returns\n *\n * `Promise<Todo[]>` - Array of matching todos, sorted by creation date\n *\n * ## PostgreSQL Full-Text Search\n *\n * This function uses PostgreSQL's powerful text search features, which are\n * significantly faster and more flexible than LIKE queries.\n *\n * ### Key Functions\n *\n * | `Function` | Purpose |\n * |----------|---------|\n * | `to_tsvector('english', text)` | Converts text to searchable document vector |\n * | `plainto_tsquery('english', query)` | Converts search term to query format |\n * | `@@` | Match operator for text search |\n * | `COALESCE(description, '')` | Handle null descriptions |\n *\n * ### Why Full-Text Search?\n *\n * ```typescript\n * // SLOW - Must scan entire table\n * WHERE title LIKE '%search%' OR description LIKE '%search%'\n *\n * // FAST - Uses specialized index (GIN or GiST)\n * WHERE to_tsvector(title || ' ' || description) @@ plainto_tsquery('search')\n * ```\n *\n * ## Performance Optimization\n *\n * For best performance, add a GIN index:\n *\n * ```sql\n * CREATE INDEX idx_todos_fts ON todos\n * USING GIN (to_tsvector('english', title || ' ' || COALESCE(description, '')))\n * ```\n *\n * ### Search Features\n *\n * - Stemming: \"running\" matches \"run\", \"runs\", \"ran\"\n * - Stop words: Ignores common words like \"the\", \"a\", \"is\"\n * - Language-aware: Uses English dictionary and rules\n * - Multiple words: Searches for all words in query\n *\n * ### SQL Equivalent\n *\n * ```sql\n * SELECT * FROM todos\n * WHERE is_public = true\n *   AND to_tsvector('english', title || ' ' || COALESCE(description, ''))\n *       @@ plainto_tsquery('english', $1)\n * ORDER BY created_at DESC\n * ```\n *\n * ### Example Usage\n *\n * ```typescript\n * // Search for todos about groceries\n * const results = await searchPublicTodos('grocery shopping')\n *\n * // Finds todos with:\n * // - \"Buy groceries\"\n * // - \"Shopping list\"\n * // - \"Grocery store run\"\n * ```\n */\nexport async function searchPublicTodos(searchTerm: string) {\n  return await db\n    .select()\n    .from(todos)\n    .where(\n      and(\n        eq(todos.isPublic, true),\n        sql`to_tsvector('english', ${todos.title} || ' ' || COALESCE(${todos.description}, '')) @@ plainto_tsquery('english', ${searchTerm})`\n      )\n    )\n    .orderBy(desc(todos.createdAt))\n}\n// CLOSE: search-public-todos\n\n/**\n * REF: filter-public-todos-by-tag\n *\n * ## Filter Public Todos by Tag\n *\n * Retrieves public todos that include a specific tag. Uses PostgreSQL array\n * operations for efficient filtering.\n *\n * ## Parameters\n *\n * | Name | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `tag` | `string` | `Yes` | Tag to filter by |\n *\n * ## Returns\n *\n * `Promise<Todo[]>` - Array of todos containing the tag\n *\n * ## PostgreSQL Array Operations\n *\n * PostgreSQL provides powerful operators for working with array columns:\n *\n * | `Operator` | Purpose | `Example` |\n * |----------|---------|---------|\n * | `= ANY(array)` | Check if value exists in array | `'urgent' = ANY(tags)` |\n * | `&& array` | Check if arrays overlap | `tags && ARRAY['urgent','work']` |\n * | `@> array` | Check if array contains all values | `tags @> ARRAY['urgent']` |\n *\n * ## Performance with GIN Index\n *\n * For optimal performance on array queries, create a GIN index:\n *\n * ```sql\n * CREATE INDEX idx_todos_tags ON todos USING GIN (tags)\n * ```\n *\n * GIN (Generalized Inverted Index) is designed for array and JSONB operations.\n *\n * ### SQL Equivalent\n *\n * ```sql\n * SELECT * FROM todos\n * WHERE is_public = true\n *   AND $1 = ANY(tags)\n * ORDER BY created_at DESC\n * ```\n *\n * ## Advanced Array Queries\n *\n * ```typescript\n * // Multiple tags (any match)\n * sql`tags && ARRAY[${tag1}, ${tag2}]`\n *\n * // All tags must be present\n * sql`tags @> ARRAY[${tag1}, ${tag2}]`\n *\n * // Get array length\n * sql`array_length(tags, 1) > 0`\n * ```\n *\n * ### Example Usage\n *\n * ```typescript\n * // Find all public todos tagged \"urgent\"\n * const urgentTodos = await filterPublicTodosByTag('urgent')\n *\n * // Find todos with specific category\n * const workTodos = await filterPublicTodosByTag('work')\n * ```\n */\nexport async function filterPublicTodosByTag(tag: string) {\n  return await db\n    .select()\n    .from(todos)\n    .where(\n      and(\n        eq(todos.isPublic, true),\n        sql`${tag} = ANY(${todos.tags})`\n      )\n    )\n    .orderBy(desc(todos.createdAt))\n}\n// CLOSE: filter-public-todos-by-tag\n\n/**\n * REF: user-settings-queries-section\n *\n * ## User Settings Queries\n *\n * Functions for managing user preferences and application settings. Each user\n * has a single settings record with preferences for theme, display, and accessibility.\n */\n// CLOSE: user-settings-queries-section\n\n/**\n * REF: get-user-settings\n *\n * ## Get User Settings\n *\n * Retrieves the settings record for a specific user. Returns null if no\n * settings exist yet.\n *\n * ## Parameters\n *\n * | Name | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `userId` | `string` | `Yes` | User's unique identifier |\n *\n * ## Returns\n *\n * `Promise<UserSettings | null>` - Settings object or null if not found\n *\n * ### Pattern: Single Result from Array\n *\n * Drizzle's `.select()` always returns an array. To get a single result:\n *\n * ```typescript\n * // Get first result or null\n * const result = await db.select().from(table).where(...).limit(1)\n * return result[0] || null\n * ```\n *\n * ### Alternative Patterns\n *\n * | `Pattern` | `Behavior` |\n * |---------|----------|\n * | `result[0] \\|\\| null` | Returns null if array is empty |\n * | `result[0] ?? null` | Same as above, slightly stricter |\n * | `.limit(1)` | Limits database query to 1 row |\n *\n * ### SQL Equivalent\n *\n * ```sql\n * SELECT * FROM user_settings\n * WHERE user_id = $1\n * LIMIT 1\n * ```\n *\n * ### Example Usage\n *\n * ```typescript\n * const settings = await getUserSettings('user-123')\n *\n * if (settings) {\n *   console.log(settings.theme) // 'dark' or 'light'\n *   console.log(settings.fontSize) // 'medium', 'large', etc.\n * } else {\n *   // User hasn't set preferences yet, use defaults\n * }\n * ```\n */\nexport async function getUserSettings(userId: string) {\n  const result = await db\n    .select()\n    .from(userSettings)\n    .where(eq(userSettings.userId, userId))\n    .limit(1)\n\n  return result[0] || null\n}\n// CLOSE: get-user-settings\n\n/**\n * REF: update-user-settings\n *\n * ## Update User Settings\n *\n * Updates one or more user preference fields. Supports partial updates.\n *\n * ## Parameters\n *\n * | Name | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `userId` | `string` | `Yes` | User whose settings to update |\n * | `updates.theme` | `string` | `No` | Theme preference (e.g., `'light'`, `'dark'`) |\n * | `updates.fontSize` | `string` | `No` | Font size (e.g., `'small'`, `'medium'`, `'large'`) |\n * | `updates.highContrast` | `boolean` | `No` | High contrast mode enabled |\n * | `updates.reducedMotion` | `boolean` | `No` | Reduced motion preference |\n *\n * ## Returns\n *\n * `Promise<UserSettings>` - Updated settings object\n *\n * ## UPSERT Pattern Alternative\n *\n * This function assumes settings already exist. For insert-or-update behavior,\n * use the UPSERT pattern with `onConflictDoUpdate`:\n *\n * ```typescript\n * export async function upsertUserSettings(userId: string, settings: {}) {\n *   const [result] = await db\n *     .insert(userSettings)\n *     .values({\n *       userId,\n *       ...settings,\n *       updatedAt: new Date(),\n *     })\n *     .onConflictDoUpdate({\n *       target: userSettings.userId,\n *       set: {\n *         ...settings,\n *         updatedAt: new Date(),\n *       },\n *     })\n *     .returning()\n *\n *   return result\n * }\n * ```\n *\n * ## When to Use UPSERT\n *\n * | `Scenario` | Best Approach |\n * |----------|---------------|\n * | Settings always exist | Use `UPDATE` (this function) |\n * | Settings may not exist | Use `UPSERT` (`onConflictDoUpdate`) |\n * | First-time setup | Use `INSERT` |\n *\n * ### SQL Equivalent\n *\n * ```sql\n * UPDATE user_settings\n * SET theme = $1, updated_at = NOW()\n * WHERE user_id = $2\n * RETURNING *\n * ```\n *\n * ### Example Usage\n *\n * ```typescript\n * // Update just the theme\n * await updateUserSettings('user-123', {\n *   theme: 'dark'\n * })\n *\n * // Update multiple preferences\n * await updateUserSettings('user-123', {\n *   fontSize: 'large',\n *   highContrast: true,\n *   reducedMotion: true\n * })\n * ```\n */\nexport async function updateUserSettings(\n  userId: string,\n  updates: {\n    theme?: string\n    fontSize?: string\n    highContrast?: boolean\n    reducedMotion?: boolean\n  }\n) {\n  const [updated] = await db\n    .update(userSettings)\n    .set({\n      ...updates,\n      updatedAt: new Date(),\n    })\n    .where(eq(userSettings.userId, userId))\n    .returning()\n\n  return updated\n}\n// CLOSE: update-user-settings\n\n/**\n * REF: message-queries-section\n *\n * ## Message Queries\n *\n * Functions for managing user-to-user messaging. Includes conversation retrieval,\n * sending messages, read receipts, and unread counts.\n */\n// CLOSE: message-queries-section\n\n/**\n * REF: get-conversation\n *\n * ## Get Conversation\n *\n * Retrieves all messages between two users in chronological order. The conversation\n * includes messages in both directions (A‚ÜíB and B‚ÜíA).\n *\n * ## Parameters\n *\n * | Name | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `userId` | `string` | `Yes` | Current user's ID |\n * | `otherUserId` | `string` | `Yes` | Other participant's ID |\n *\n * ## Returns\n *\n * `Promise<Message[]>` - All messages between the two users, oldest first\n *\n * ### Complex WHERE Clause\n *\n * This query demonstrates a bidirectional conversation pattern:\n *\n * ```sql\n * WHERE (sender_id = A AND recipient_id = B)\n *    OR (sender_id = B AND recipient_id = A)\n * ```\n *\n * This retrieves messages in both directions, creating a complete conversation thread.\n *\n * ### Raw SQL Pattern\n *\n * When Drizzle's query builder doesn't support complex conditions cleanly,\n * use the `sql` template literal:\n *\n * ```typescript\n * .where(sql`complex condition here`)\n * ```\n *\n * ### Chronological Ordering\n *\n * Messages are ordered by `createdAt` ascending (oldest first), which is typical\n * for chat interfaces where you scroll to see newer messages.\n *\n * ### SQL Equivalent\n *\n * ```sql\n * SELECT * FROM messages\n * WHERE (sender_id = $1 AND recipient_id = $2)\n *    OR (sender_id = $2 AND recipient_id = $1)\n * ORDER BY created_at ASC\n * ```\n *\n * ### Example Usage\n *\n * ```typescript\n * // Get chat history between two users\n * const conversation = await getConversation('user-123', 'user-456')\n *\n * // Render messages in order\n * conversation.forEach(msg => {\n *   const isMine = msg.senderId === currentUserId\n *   console.log(`${isMine ? 'Me' : 'Them'}: ${msg.content}`)\n * })\n * ```\n */\nexport async function getConversation(userId: string, otherUserId: string) {\n  return await db\n    .select()\n    .from(messages)\n    .where(\n      sql`(${messages.senderId} = ${userId} AND ${messages.recipientId} = ${otherUserId})\n       OR (${messages.senderId} = ${otherUserId} AND ${messages.recipientId} = ${userId})`\n    )\n    .orderBy(messages.createdAt)\n}\n// CLOSE: get-conversation\n\n/**\n * REF: send-message\n *\n * ## Send Message\n *\n * Creates a new message from one user to another.\n *\n * ## Parameters\n *\n * | Name | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `senderId` | `string` | `Yes` | User sending the message |\n * | `recipientId` | `string` | `Yes` | User receiving the message |\n * | `content` | `string` | `Yes` | Message text content |\n *\n * ## Returns\n *\n * `Promise<Message>` - The created message with generated ID and timestamp\n *\n * ### Default Values\n *\n * New messages are created with:\n * - `read: false` - Initially unread\n * - `createdAt` - Auto-generated timestamp\n * - `readAt: null` - Set later when message is read\n *\n * ### SQL Equivalent\n *\n * ```sql\n * INSERT INTO messages (sender_id, recipient_id, content, read)\n * VALUES ($1, $2, $3, false)\n * RETURNING *\n * ```\n *\n * ### Example Usage\n *\n * ```typescript\n * const message = await sendMessage(\n *   'user-123',\n *   'user-456',\n *   'Hello there!'\n * )\n *\n * console.log(message.id) // Auto-generated ID\n * console.log(message.createdAt) // Timestamp\n * console.log(message.read) // false\n * ```\n */\nexport async function sendMessage(\n  senderId: string,\n  recipientId: string,\n  content: string\n) {\n  const [message] = await db\n    .insert(messages)\n    .values({\n      senderId,\n      recipientId,\n      content,\n      read: false,\n    })\n    .returning()\n\n  return message\n}\n// CLOSE: send-message\n\n/**\n * REF: mark-message-as-read\n *\n * ## Mark Message as Read\n *\n * Updates a message to mark it as read and records the timestamp when it was read.\n * Used for read receipts and \"delivered\" indicators in chat interfaces.\n *\n * ## Parameters\n *\n * | Name | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `messageId` | `string` | `Yes` | ID of message to mark as read |\n *\n * ## Returns\n *\n * `Promise<void>` - No return value\n *\n * ### Read Receipt Pattern\n *\n * This function implements the read receipt pattern by tracking:\n * - `read` boolean - Whether message has been seen\n * - `readAt` timestamp - Exact time it was read\n *\n * ### Use Cases\n *\n * - Show \"Read\" vs \"Delivered\" status in UI\n * - Track when messages are seen\n * - Calculate response times\n * - Display \"seen at\" timestamps\n *\n * ### SQL Equivalent\n *\n * ```sql\n * UPDATE messages\n * SET read = true, read_at = NOW()\n * WHERE id = $1\n * ```\n *\n * ### Example Usage\n *\n * ```typescript\n * // User opens chat and sees new message\n * await markMessageAsRead('message-789')\n *\n * // Now other user can see \"Read\" indicator\n * ```\n */\nexport async function markMessageAsRead(messageId: string) {\n  await db\n    .update(messages)\n    .set({\n      read: true,\n      readAt: new Date(),\n    })\n    .where(eq(messages.id, messageId))\n}\n// CLOSE: mark-message-as-read\n\n/**\n * REF: get-unread-count\n *\n * ## Get Unread Message Count\n *\n * Returns the number of unread messages for a user. Efficient aggregation query\n * that doesn't fetch message content.\n *\n * ## Parameters\n *\n * | Name | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `userId` | `string` | `Yes` | User to check unread count for |\n *\n * ## Returns\n *\n * `Promise<number>` - Count of unread messages\n *\n * ### Aggregation Pattern\n *\n * This demonstrates PostgreSQL aggregate functions in Drizzle:\n *\n * ```typescript\n * .select({ count: sql<number>`count(*)::int` })\n * ```\n *\n * ### Why This is Efficient\n *\n * | `Approach` | `Performance` |\n * |----------|-------------|\n * | `SELECT *` then count in JS | Fetches all message data |\n * | `SELECT count(*)` | Database only counts rows |\n * | With `::int` cast | Returns proper number type |\n *\n * ## Common Aggregate Functions\n *\n * ```typescript\n * // Count\n * sql<number>`count(*)`\n *\n * // Sum\n * sql<number>`sum(column_name)`\n *\n * // Average\n * sql<number>`avg(column_name)`\n *\n * // Min/Max\n * sql<number>`min(column_name)`\n * sql<number>`max(column_name)`\n * ```\n *\n * ### SQL Equivalent\n *\n * ```sql\n * SELECT count(*)::int FROM messages\n * WHERE recipient_id = $1\n *   AND read = false\n * ```\n *\n * ### Example Usage\n *\n * ```typescript\n * const unreadCount = await getUnreadCount('user-123')\n *\n * // Show badge in UI\n * <Badge count={unreadCount} />\n *\n * // Conditionally render\n * {unreadCount > 0 && <NotificationDot />}\n * ```\n */\nexport async function getUnreadCount(userId: string) {\n  const result = await db\n    .select({ count: sql<number>`count(*)::int` })\n    .from(messages)\n    .where(\n      and(\n        eq(messages.recipientId, userId),\n        eq(messages.read, false)\n      )\n    )\n\n  return result[0]?.count || 0\n}\n// CLOSE: get-unread-count\n\n/**\n * REF: attachment-queries-section\n *\n * ## Attachment Queries\n *\n * Functions for managing file attachments associated with todos.\n */\n// CLOSE: attachment-queries-section\n\n/**\n * REF: get-todo-attachments\n *\n * ## Get Todo Attachments\n *\n * Retrieves all file attachments for a specific todo, ordered by upload time.\n *\n * ## Parameters\n *\n * | Name | Type | `Required` | Description |\n * |------|------|----------|-------------|\n * | `todoId` | `string` | `Yes` | ID of the todo |\n *\n * ## Returns\n *\n * `Promise<TodoAttachment[]>` - Array of attachment objects\n *\n * ### Attachment Fields\n *\n * Each attachment includes:\n * - `id` - Unique attachment identifier\n * - `todoId` - Parent todo ID\n * - `fileName` - Original filename\n * - `fileUrl` - Storage URL (e.g., from Supabase Storage)\n * - `fileSize` - Size in bytes\n * - `mimeType` - File MIME type (e.g., 'image/png')\n * - `uploadedAt` - Upload timestamp\n *\n * ### SQL Equivalent\n *\n * ```sql\n * SELECT * FROM todo_attachments\n * WHERE todo_id = $1\n * ORDER BY uploaded_at ASC\n * ```\n *\n * ### Example Usage\n *\n * ```typescript\n * const attachments = await getTodoAttachments('todo-123')\n *\n * attachments.forEach(file => {\n *   console.log(`${file.fileName} (${file.fileSize} bytes)`)\n *   console.log(`Download: ${file.fileUrl}`)\n * })\n * ```\n */\nexport async function getTodoAttachments(todoId: string) {\n  return await db\n    .select()\n    .from(todoAttachments)\n    .where(eq(todoAttachments.todoId, todoId))\n    .orderBy(todoAttachments.uploadedAt)\n}\n// CLOSE: get-todo-attachments\n\n/**\n * REF: relational-queries-pattern\n *\n * ## Relational Queries Pattern\n *\n * Drizzle provides a relational query API for fetching related data in a single\n * query with automatic JOIN handling.\n *\n * ## Get Todos with Attachments\n *\n * This pattern demonstrates fetching a todo and all its attachments together:\n *\n * ```typescript\n * export async function getTodosWithAttachments(userId: string) {\n *   return await db.query.todos.findMany({\n *     where: eq(todos.userId, userId),\n *     with: {\n *       attachments: true,\n *     },\n *     orderBy: desc(todos.createdAt),\n *   })\n * }\n * ```\n *\n * ## Nested Result Structure\n *\n * The relational API returns nested objects instead of flat JOIN results:\n *\n * ```typescript\n * [\n *   {\n *     id: 'todo-1',\n *     title: 'Buy groceries',\n *     attachments: [\n *       { id: 'att-1', fileName: 'list.pdf' },\n *       { id: 'att-2', fileName: 'coupon.jpg' }\n *     ]\n *   },\n *   {\n *     id: 'todo-2',\n *     title: 'Book flight',\n *     attachments: [\n *       { id: 'att-3', fileName: 'passport.pdf' }\n *     ]\n *   }\n * ]\n * ```\n *\n * ## Benefits\n *\n * | Feature | Benefit |\n * |---------|---------|\n * | Automatic JOINs | No manual JOIN syntax needed |\n * | Type-safe | Full TypeScript inference for nested objects |\n * | N+1 Prevention | Single query instead of multiple |\n * | Clean structure | Nested data matches domain model |\n *\n * ## Advanced Relational Patterns\n *\n * ```typescript\n * // Multiple levels of nesting\n * db.query.users.findMany({\n *   with: {\n *     todos: {\n *       with: {\n *         attachments: true\n *       }\n *     }\n *   }\n * })\n *\n * // Filtered relations\n * db.query.todos.findMany({\n *   with: {\n *     attachments: {\n *       where: eq(todoAttachments.mimeType, 'image/png')\n *     }\n *   }\n * })\n * ```\n *\n * ### SQL Equivalent\n *\n * Drizzle handles the JOIN automatically:\n *\n * ```sql\n * SELECT t.*, a.*\n * FROM todos t\n * LEFT JOIN todo_attachments a ON t.id = a.todo_id\n * WHERE t.user_id = $1\n * ORDER BY t.created_at DESC\n * ```\n */\n// CLOSE: relational-queries-pattern\n\n/**\n * REF: transactions-pattern\n *\n * ## Database Transactions\n *\n * Transactions ensure multiple database operations succeed or fail together,\n * maintaining data consistency.\n *\n * ## Create Todo with Attachments\n *\n * This pattern demonstrates atomic creation of a todo and its attachments:\n *\n * ```typescript\n * export async function createTodoWithAttachments(\n *   userId: string,\n *   title: string,\n *   files: FileData[]\n * ) {\n *   return await db.transaction(async (tx) => {\n *     // Create todo\n *     const [todo] = await tx\n *       .insert(todos)\n *       .values({ userId, title })\n *       .returning()\n *\n *     // Create attachments\n *     await tx\n *       .insert(todoAttachments)\n *       .values(files.map(f => ({\n *         todoId: todo.id,\n *         fileName: f.name,\n *         fileUrl: f.url,\n *         fileSize: f.size,\n *         mimeType: f.type,\n *       })))\n *\n *     return todo\n *   })\n * }\n * ```\n *\n * ## Transaction Guarantees\n *\n * | `Scenario` | `Result` |\n * |----------|--------|\n * | All operations succeed | All changes committed |\n * | Any operation fails | All changes rolled back |\n * | Network error | All changes rolled back |\n * | Exception thrown | All changes rolled back |\n *\n * ## ACID Properties\n *\n * Transactions provide ACID guarantees:\n * - **Atomicity**: All or nothing\n * - **Consistency**: Database stays valid\n * - **Isolation**: Concurrent transactions don't interfere\n * - **Durability**: Committed changes persist\n *\n * ### Use Cases\n *\n * Use transactions when you need:\n * - Creating parent and child records together\n * - Transferring between accounts (debit + credit)\n * - Complex multi-table updates\n * - Ensuring data integrity across operations\n *\n * ## Transaction Error Handling\n *\n * ```typescript\n * try {\n *   const result = await db.transaction(async (tx) => {\n *     // Operations here\n *   })\n *   return result\n * } catch (error) {\n *   // Transaction was rolled back\n *   console.error('Transaction failed:', error)\n *   throw error\n * }\n * ```\n */\n// CLOSE: transactions-pattern\n\n/**\n * REF: performance-optimization-tips\n *\n * ## Performance Optimization Tips\n *\n * Best practices for writing efficient Drizzle queries.\n *\n * ## 1. Select Only Needed Columns\n *\n * Reduce data transfer by selecting specific columns:\n *\n * ```typescript\n * // Instead of SELECT *\n * db.select().from(todos)\n *\n * // Select only what you need\n * db.select({\n *   id: todos.id,\n *   title: todos.title,\n * }).from(todos)\n * ```\n *\n * ## 2. Use Database Indexes\n *\n * Add indexes for frequently queried columns:\n *\n * ```sql\n * -- Single column index\n * CREATE INDEX idx_todos_user ON todos(user_id);\n *\n * -- Composite index for common query\n * CREATE INDEX idx_todos_user_created\n * ON todos(user_id, created_at DESC);\n *\n * -- Full-text search index\n * CREATE INDEX idx_todos_fts ON todos\n * USING GIN (to_tsvector('english', title || ' ' || COALESCE(description, '')));\n *\n * -- Array operations index\n * CREATE INDEX idx_todos_tags ON todos USING GIN (tags);\n * ```\n *\n * ## 3. Batch Operations\n *\n * Insert/update multiple records in one query:\n *\n * ```typescript\n * // Instead of multiple inserts\n * for (const todo of todos) {\n *   await db.insert(todos).values(todo)\n * }\n *\n * // Batch insert\n * await db.insert(todos).values([todo1, todo2, todo3])\n * ```\n *\n * ## 4. Use Prepared Statements\n *\n * Reuse query plans for repeated queries:\n *\n * ```typescript\n * // Prepare once\n * const getUserTodosPrepared = db\n *   .select()\n *   .from(todos)\n *   .where(eq(todos.userId, sql.placeholder('userId')))\n *   .prepare()\n *\n * // Execute multiple times efficiently\n * const user1Todos = await getUserTodosPrepared.execute({ userId: 'user-1' })\n * const user2Todos = await getUserTodosPrepared.execute({ userId: 'user-2' })\n * ```\n *\n * ## 5. Use Pagination\n *\n * Limit result sets for large tables:\n *\n * ```typescript\n * const PAGE_SIZE = 20\n * const page = 1\n *\n * db.select()\n *   .from(todos)\n *   .limit(PAGE_SIZE)\n *   .offset((page - 1) * PAGE_SIZE)\n * ```\n *\n * ## 6. Optimize Aggregations\n *\n * Use database aggregations instead of fetching all data:\n *\n * ```typescript\n * // Inefficient\n * const todos = await db.select().from(todos)\n * const count = todos.length\n *\n * // Efficient\n * const [{ count }] = await db\n *   .select({ count: sql<number>`count(*)` })\n *   .from(todos)\n * ```\n */\n// CLOSE: performance-optimization-tips\n\n/**\n * REF: debugging-queries\n *\n * ## Debugging Queries\n *\n * Tools and techniques for understanding and debugging Drizzle queries.\n *\n * ## View Generated SQL\n *\n * See exactly what SQL Drizzle generates:\n *\n * ```typescript\n * const query = db\n *   .select()\n *   .from(todos)\n *   .where(eq(todos.userId, 'user-123'))\n *   .toSQL()\n *\n * console.log(query.sql)\n * // Output: SELECT * FROM todos WHERE user_id = $1\n *\n * console.log(query.params)\n * // Output: ['user-123']\n * ```\n *\n * ## Enable Query Logging\n *\n * Log all queries during development:\n *\n * ```typescript\n * import { drizzle } from 'drizzle-orm/postgres-js'\n * import postgres from 'postgres'\n *\n * const client = postgres(connectionString)\n * const db = drizzle(client, {\n *   schema,\n *   logger: true  // Enables logging\n * })\n * ```\n *\n * ## Custom Logger\n *\n * Implement custom logging logic:\n *\n * ```typescript\n * const db = drizzle(client, {\n *   schema,\n *   logger: {\n *     logQuery(query: string, params: unknown[]) {\n *       console.log('Query:', query)\n *       console.log('Params:', params)\n *       console.log('Time:', Date.now())\n *     }\n *   }\n * })\n * ```\n *\n * ## Explain Query Plans\n *\n * Analyze query performance with EXPLAIN:\n *\n * ```typescript\n * const result = await db.execute(sql`\n *   EXPLAIN ANALYZE\n *   SELECT * FROM todos WHERE user_id = ${'user-123'}\n * `)\n * console.log(result)\n * ```\n *\n * ## Common Debug Scenarios\n *\n * | `Issue` | `Solution` |\n * |-------|----------|\n * | Slow query | Use `EXPLAIN` to check index usage |\n * | Wrong results | Log SQL and verify `WHERE` clause |\n * | Type errors | Check schema matches database |\n * | Missing data | Verify JOINs and relations |\n */\n// CLOSE: debugging-queries\n",
      "language": "typescript"
    },
    {
      "path": "lib/db/schema.ts",
      "content": "/**\n * Drizzle ORM Schema Definition\n *\n * REF: Drizzle Type-Safe Database Schema\n *\n * This file defines the complete database schema using Drizzle ORM, providing\n * perfect TypeScript inference and type-safe database operations throughout\n * the application.\n *\n * ## Core Drizzle Concepts\n *\n * | `Concept` | Description | Benefit |\n * |---------|-------------|---------|\n * | Schema-first | Define tables in TypeScript | Single source of truth |\n * | Type inference | Auto-generate types from schema | No manual type definitions |\n * | SQL-like syntax | Familiar query patterns | Easy learning curve |\n * | Code-first | Schema in code, not SQL | Version controlled, refactorable |\n * | Migration generation | Auto-generate SQL from changes | Database evolution tracking |\n *\n * ## Drizzle vs Other ORMs\n *\n * | Feature | `Drizzle` | `Prisma` | `TypeORM` | Raw SQL |\n * |---------|---------|--------|---------|---------|\n * | Type Safety | `Perfect` | `Good` | `Good` | `None` |\n * | Bundle Size | `~10KB` | `~1MB` | `~500KB` | `0KB` |\n * | Learning Curve | `Low` | `Medium` | `High` | `Medium` |\n * | SQL-like | `Yes` | `No` | `Partial` | `Yes` |\n * | `Performance` | `Excellent` | `Good` | `Good` | `Best` |\n * | `Autocomplete` | `Perfect` | `Good` | `Good` | `None` |\n *\n * ## Why Drizzle with Supabase?\n *\n * **Problem with Supabase Client Alone:**\n * - Type safety isn't perfect for complex queries\n * - JOIN operations can be awkward\n * - TypeScript inference limited for nested queries\n * - No built-in migration system\n *\n * **Solution with Drizzle:**\n * - Perfect TypeScript inference for ALL queries\n * - SQL-like syntax for complex operations\n * - Built-in migration generation\n * - Still use Supabase Auth and Storage\n *\n * **Hybrid Architecture:**\n * ```\n * Supabase Auth ‚Üí User authentication\n * Supabase Storage ‚Üí File uploads\n * Supabase Realtime ‚Üí Live subscriptions\n * Drizzle ORM ‚Üí All database queries\n * ```\n *\n * ## Schema to SQL Workflow\n *\n * ```typescript\n * // 1. Define schema in TypeScript\n * export const todos = pgTable('todos', {\n *   id: uuid('id').primaryKey(),\n *   title: text('title').notNull()\n * })\n *\n * // 2. Generate migration SQL\n * // Run: npm run db:generate\n * // Creates: drizzle/0001_migration.sql\n *\n * // 3. Apply to database\n * // Run: npm run db:push\n * // Or copy SQL to Supabase SQL Editor\n *\n * // 4. Types automatically available\n * const todos = await db.select().from(todos)\n * // TypeScript knows exact shape!\n * ```\n *\n * CLOSE: Drizzle Type-Safe Database Schema\n */\n\nimport {\n  pgTable,\n  uuid,\n  text,\n  timestamp,\n  boolean,\n  integer,\n} from 'drizzle-orm/pg-core'\nimport { relations } from 'drizzle-orm'\n\n/**\n * REF: User Profiles Table\n *\n * Extends Supabase Auth users with application-specific profile data.\n *\n * ## Table Structure\n *\n * | Column | Type | Constraints | Description |\n * |--------|------|-------------|-------------|\n * | `id` | `UUID` | `PRIMARY KEY`, `DEFAULT random` | Profile ID |\n * | `user_id` | `UUID` | `NOT NULL`, `UNIQUE` | References `auth.users` |\n * | `display_name` | `TEXT` | `NULL` | User's display name |\n * | `profile_picture` | `TEXT` | `NULL` | URL to profile image |\n * | `created_at` | `TIMESTAMP` | `NOT NULL`, `DEFAULT now()` | Profile creation time |\n * | `updated_at` | `TIMESTAMP` | `NOT NULL`, `DEFAULT now()` | Last update time |\n *\n * ## Why Separate Profile Table?\n *\n * **Supabase Auth Schema:**\n * - `auth.users` - Managed by Supabase (email, password, etc.)\n * - Cannot directly modify auth schema\n * - Limited custom fields (user_metadata)\n *\n * **Application Profile:**\n * - `user_profiles` - Our custom table\n * - Full control over fields\n * - Easy to query and update\n * - Links to auth.users via user_id\n *\n * ## Usage Example\n *\n * ```typescript\n * // Create profile after signup\n * await db.insert(userProfiles).values({\n *   userId: authUser.id,\n *   displayName: 'John Doe'\n * })\n *\n * // Query user profile\n * const profile = await db\n *   .select()\n *   .from(userProfiles)\n *   .where(eq(userProfiles.userId, userId))\n *   .limit(1)\n * ```\n *\n * CLOSE: User Profiles Table\n */\nexport const userProfiles = pgTable('user_profiles', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  userId: uuid('user_id').notNull().unique(),\n  displayName: text('display_name'),\n  profilePicture: text('profile_picture'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull(),\n})\n\n/**\n * REF: User Settings Table\n *\n * Stores per-user accessibility and appearance preferences.\n *\n * ## Table Structure\n *\n * | Column | Type | Constraints | Default | Description |\n * |--------|------|-------------|---------|-------------|\n * | `id` | `UUID` | `PRIMARY KEY` | `random()` | Settings ID |\n * | `user_id` | `UUID` | `NOT NULL`, `UNIQUE` | `-` | References `auth.users` |\n * | `theme` | `TEXT` | `NOT NULL` | `'light'` | UI theme (`light`/`dark`) |\n * | `font_size` | `TEXT` | `NOT NULL` | `'medium'` | Font size (`small`/`medium`/`large`) |\n * | `high_contrast` | `BOOLEAN` | `NOT NULL` | `false` | High contrast mode |\n * | `reduced_motion` | `BOOLEAN` | `NOT NULL` | `false` | Disable animations |\n * | `updated_at` | `TIMESTAMP` | `NOT NULL` | `now()` | Last update time |\n *\n * ## Drizzle Features Demonstrated\n *\n * **Type-Safe Defaults:**\n * ```typescript\n * theme: text('theme').default('light').notNull()\n * // TypeScript knows: theme is string, never null, defaults to 'light'\n * ```\n *\n * **Constraint Enforcement:**\n * - `notNull()` - Field required\n * - `unique()` - One row per user\n * - `default()` - Automatic value if not provided\n *\n * ## Accessibility Features\n *\n * | Setting | Values | Purpose |\n * |---------|--------|---------|\n * | `theme` | `light`, `dark` | Color scheme preference |\n * | `font_size` | `small`, `medium`, `large` | Text sizing for readability |\n * | `high_contrast` | `true`, `false` | Enhanced contrast for vision |\n * | `reduced_motion` | `true`, `false` | Disable animations for vestibular |\n *\n * ## Usage Example\n *\n * ```typescript\n * // Get user settings\n * const settings = await db\n *   .select()\n *   .from(userSettings)\n *   .where(eq(userSettings.userId, userId))\n *   .limit(1)\n *\n * // Update settings (type-safe!)\n * await db\n *   .update(userSettings)\n *   .set({ theme: 'dark', fontSize: 'large' })\n *   .where(eq(userSettings.userId, userId))\n * ```\n *\n * CLOSE: User Settings Table\n */\nexport const userSettings = pgTable('user_settings', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  userId: uuid('user_id').notNull().unique(),\n  theme: text('theme').default('light').notNull(),\n  fontSize: text('font_size').default('medium').notNull(),\n  highContrast: boolean('high_contrast').default(false).notNull(),\n  reducedMotion: boolean('reduced_motion').default(false).notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull(),\n})\n\n/**\n * REF: Todos Table\n *\n * Main table for storing todo items with full CRUD capabilities.\n *\n * ## Table Structure\n *\n * | Column | Type | Constraints | Default | Description |\n * |--------|------|-------------|---------|-------------|\n * | `id` | `UUID` | `PRIMARY KEY` | `random()` | Todo ID |\n * | `user_id` | `UUID` | `NOT NULL` | `-` | Owner of todo |\n * | `title` | `TEXT` | `NOT NULL` | `-` | Todo title |\n * | `description` | `TEXT` | `NULL` | `-` | Optional description |\n * | `completed` | `BOOLEAN` | `NOT NULL` | `false` | Completion status |\n * | `is_public` | `BOOLEAN` | `NOT NULL` | `false` | Public feed visibility |\n * | `tags` | `TEXT[]` | `NULL` | `-` | Array of tags |\n * | `created_at` | `TIMESTAMP` | `NOT NULL` | `now()` | Creation time |\n * | `updated_at` | `TIMESTAMP` | `NOT NULL` | `now()` | Last update |\n *\n * ## PostgreSQL Array Type\n *\n * **Drizzle Syntax:**\n * ```typescript\n * tags: text('tags').array()\n * ```\n *\n * **Benefits of Arrays:**\n * - Store multiple tags in single column\n * - No separate tags table needed\n * - Efficient with GIN indexes\n * - Native PostgreSQL support\n *\n * **Query Operations:**\n * ```typescript\n * // Check if tag exists\n * sql`${tag} = ANY(${todos.tags})`\n *\n * // Multiple tags (intersection)\n * sql`${todos.tags} && ${arrayOfTags}`\n *\n * // All tags match (containment)\n * sql`${todos.tags} @> ${arrayOfTags}`\n * ```\n *\n * ## Usage Examples\n *\n * ```typescript\n * // Create todo with tags\n * await db.insert(todos).values({\n *   userId,\n *   title: 'Learn Drizzle',\n *   tags: ['typescript', 'database', 'orm']\n * })\n *\n * // Query by tag\n * const tagged = await db\n *   .select()\n *   .from(todos)\n *   .where(sql`'typescript' = ANY(${todos.tags})`)\n *\n * // Public todos only\n * const publicTodos = await db\n *   .select()\n *   .from(todos)\n *   .where(eq(todos.isPublic, true))\n * ```\n *\n * CLOSE: Todos Table\n */\nexport const todos = pgTable('todos', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  userId: uuid('user_id').notNull(),\n  title: text('title').notNull(),\n  description: text('description'),\n  completed: boolean('completed').default(false).notNull(),\n  isPublic: boolean('is_public').default(false).notNull(),\n  tags: text('tags').array(),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull(),\n})\n\n/**\n * REF: Todo Attachments Table\n *\n * Stores metadata for files attached to todos.\n *\n * ## Table Structure\n *\n * | Column | Type | Constraints | Description |\n * |--------|------|-------------|-------------|\n * | `id` | `UUID` | `PRIMARY KEY` | Attachment ID |\n * | `todo_id` | `UUID` | `NOT NULL` | References `todos` table |\n * | `file_name` | `TEXT` | `NOT NULL` | Original filename |\n * | `file_url` | `TEXT` | `NOT NULL` | Supabase Storage URL |\n * | `file_size` | `INTEGER` | `NOT NULL` | Size in bytes |\n * | `mime_type` | `TEXT` | `NOT NULL` | File MIME type |\n * | `uploaded_at` | `TIMESTAMP` | `NOT NULL` | Upload timestamp |\n *\n * ## Cascade Delete Pattern\n *\n * **Database Level:**\n * ```sql\n * ALTER TABLE todo_attachments\n * ADD CONSTRAINT fk_todo\n * FOREIGN KEY (todo_id) REFERENCES todos(id)\n * ON DELETE CASCADE;\n * ```\n *\n * **Benefits:**\n * - When todo deleted, attachments auto-removed from DB\n * - Prevents orphaned records\n * - Data consistency guaranteed\n *\n * **Important:** Must manually delete files from Supabase Storage!\n *\n * ## Complete Delete Flow\n *\n * ```typescript\n * // 1. Get attachments before deleting todo\n * const attachments = await db\n *   .select()\n *   .from(todoAttachments)\n *   .where(eq(todoAttachments.todoId, todoId))\n *\n * // 2. Delete files from Supabase Storage\n * for (const attach of attachments) {\n *   await supabase.storage\n *     .from('attachments')\n *     .remove([attach.fileUrl])\n * }\n *\n * // 3. Delete todo (cascade deletes DB records)\n * await db.delete(todos).where(eq(todos.id, todoId))\n * ```\n *\n * ## Usage with Drizzle Relations\n *\n * ```typescript\n * // Get todo with attachments\n * const todosWithFiles = await db.query.todos.findMany({\n *   with: { attachments: true }\n * })\n *\n * // Access: todosWithFiles[0].attachments[]\n * ```\n *\n * CLOSE: Todo Attachments Table\n */\nexport const todoAttachments = pgTable('todo_attachments', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  todoId: uuid('todo_id').notNull(),\n  fileName: text('file_name').notNull(),\n  fileUrl: text('file_url').notNull(),\n  fileSize: integer('file_size').notNull(),\n  mimeType: text('mime_type').notNull(),\n  uploadedAt: timestamp('uploaded_at').defaultNow().notNull(),\n})\n\n/**\n * REF: Messages Table\n *\n * Real-time messaging system between users.\n *\n * ## Table Structure\n *\n * | Column | Type | Constraints | Default | Description |\n * |--------|------|-------------|---------|-------------|\n * | `id` | `UUID` | `PRIMARY KEY` | `random()` | Message ID |\n * | `sender_id` | `UUID` | `NOT NULL` | `-` | Who sent message |\n * | `recipient_id` | `UUID` | `NOT NULL` | `-` | Who receives message |\n * | `content` | `TEXT` | `NOT NULL` | `-` | Message content |\n * | `read` | `BOOLEAN` | `NOT NULL` | `false` | Read status |\n * | `read_at` | `TIMESTAMP` | `NULL` | `-` | When message was read |\n * | `created_at` | `TIMESTAMP` | `NOT NULL` | `now()` | Send time |\n *\n * ## Message Status Flow\n *\n * **Initial State:**\n * - read: false\n * - read_at: null\n *\n * **After Reading:**\n * ```typescript\n * await db\n *   .update(messages)\n *   .set({ read: true, readAt: new Date() })\n *   .where(eq(messages.id, messageId))\n * ```\n *\n * ## Query Patterns\n *\n * **Get Conversation:**\n * ```typescript\n * const conversation = await db\n *   .select()\n *   .from(messages)\n *   .where(\n *     sql`(sender_id = ${user1} AND recipient_id = ${user2})\n *      OR (sender_id = ${user2} AND recipient_id = ${user1})`\n *   )\n *   .orderBy(messages.createdAt)\n * ```\n *\n * **Unread Count:**\n * ```typescript\n * const unread = await db\n *   .select({ count: sql<number>`count(*)::int` })\n *   .from(messages)\n *   .where(and(\n *     eq(messages.recipientId, userId),\n *     eq(messages.read, false)\n *   ))\n * ```\n *\n * CLOSE: Messages Table\n */\nexport const messages = pgTable('messages', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  senderId: uuid('sender_id').notNull(),\n  recipientId: uuid('recipient_id').notNull(),\n  content: text('content').notNull(),\n  read: boolean('read').default(false).notNull(),\n  readAt: timestamp('read_at'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n})\n\n/**\n * REF: Drizzle Relations\n *\n * Define relationships between tables for type-safe JOIN operations.\n *\n * ## Benefits of Relations\n *\n * | Feature | Without Relations | With Relations |\n * |---------|------------------|----------------|\n * | `Joins` | Manual SQL | `Automatic` |\n * | Type Safety | `Partial` | `Complete` |\n * | Nested Queries | `Complex` | `Simple` |\n * | `Autocomplete` | `Limited` | `Perfect` |\n *\n * ## Usage Comparison\n *\n * **Without Relations (Manual Join):**\n * ```typescript\n * const result = await db\n *   .select()\n *   .from(todos)\n *   .leftJoin(todoAttachments, eq(todos.id, todoAttachments.todoId))\n * // Result: Flat array, manual grouping needed\n * ```\n *\n * **With Relations (Automatic Nested):**\n * ```typescript\n * const todosWithAttachments = await db.query.todos.findMany({\n *   with: { attachments: true }\n * })\n * // Result: Nested structure automatically!\n * // todosWithAttachments[0].attachments[]\n * ```\n *\n * ## Relation Types\n *\n * **One-to-Many (todos ‚Üí attachments):**\n * - One todo has many attachments\n * - Defined with `many()`\n *\n * **Many-to-One (attachment ‚Üí todo):**\n * - Each attachment belongs to one todo\n * - Defined with `one()`\n *\n * CLOSE: Drizzle Relations\n */\nexport const todosRelations = relations(todos, ({ many }) => ({\n  attachments: many(todoAttachments),\n}))\n\nexport const todoAttachmentsRelations = relations(todoAttachments, ({ one }) => ({\n  todo: one(todos, {\n    fields: [todoAttachments.todoId],\n    references: [todos.id],\n  }),\n}))\n\n/**\n * REF: Drizzle Type Inference\n *\n * Automatic TypeScript type generation from database schema.\n *\n * ## Type Inference APIs\n *\n * | `API` | Purpose | Example Usage |\n * |-----|---------|---------------|\n * | `InferSelectModel` | `SELECT` query types | Reading from database |\n * | `InferInsertModel` | `INSERT` operation types | Creating new records |\n * | `typeof table` | Direct table reference | Generic type operations |\n *\n * ## Usage Examples\n *\n * ```typescript\n * import { InferSelectModel, InferInsertModel } from 'drizzle-orm'\n * import { todos } from './schema'\n *\n * // SELECT type (all fields, including defaults)\n * type Todo = InferSelectModel<typeof todos>\n * // {\n * //   id: string\n * //   userId: string\n * //   title: string\n * //   description: string | null\n * //   completed: boolean\n * //   isPublic: boolean\n * //   tags: string[] | null\n * //   createdAt: Date\n * //   updatedAt: Date\n * // }\n *\n * // INSERT type (required fields only)\n * type NewTodo = InferInsertModel<typeof todos>\n * // {\n * //   userId: string         // required\n * //   title: string          // required\n * //   description?: string   // optional\n * //   completed?: boolean    // optional (has default)\n * //   isPublic?: boolean     // optional (has default)\n * //   tags?: string[]        // optional\n * // }\n * ```\n *\n * ## Benefits\n *\n * **No Manual Definitions:**\n * - Types automatically sync with schema\n * - Change schema, types update instantly\n * - Zero maintenance overhead\n *\n * **Perfect Autocomplete:**\n * - IDE knows all fields\n * - Correct types for each column\n * - Catches typos immediately\n *\n * **Refactoring Safety:**\n * - Rename column ‚Üí all usages flagged\n * - Change type ‚Üí compile errors shown\n * - No runtime surprises\n *\n * CLOSE: Drizzle Type Inference\n */\n\n/**\n * REF: Drizzle Query Examples\n *\n * Comprehensive examples of type-safe database operations.\n *\n * ## Basic CRUD Operations\n *\n * **SELECT (Read):**\n * ```typescript\n * // All todos\n * const allTodos = await db.select().from(todos)\n *\n * // With filter\n * const userTodos = await db\n *   .select()\n *   .from(todos)\n *   .where(eq(todos.userId, userId))\n *\n * // With ordering\n * const sorted = await db\n *   .select()\n *   .from(todos)\n *   .orderBy(desc(todos.createdAt))\n *\n * // With limit/offset (pagination)\n * const paginated = await db\n *   .select()\n *   .from(todos)\n *   .limit(20)\n *   .offset(40)\n * ```\n *\n * **INSERT (Create):**\n * ```typescript\n * // Single insert\n * const [newTodo] = await db\n *   .insert(todos)\n *   .values({\n *     userId,\n *     title: 'New todo',\n *     completed: false\n *   })\n *   .returning()\n *\n * // Batch insert\n * const created = await db\n *   .insert(todos)\n *   .values([\n *     { userId, title: 'Todo 1' },\n *     { userId, title: 'Todo 2' },\n *     { userId, title: 'Todo 3' }\n *   ])\n *   .returning()\n * ```\n *\n * **UPDATE (Modify):**\n * ```typescript\n * // Update specific record\n * await db\n *   .update(todos)\n *   .set({ completed: true, updatedAt: new Date() })\n *   .where(eq(todos.id, todoId))\n *\n * // Update with returning\n * const [updated] = await db\n *   .update(todos)\n *   .set({ title: 'Updated title' })\n *   .where(eq(todos.id, todoId))\n *   .returning()\n * ```\n *\n * **DELETE (Remove):**\n * ```typescript\n * // Delete specific record\n * await db\n *   .delete(todos)\n *   .where(eq(todos.id, todoId))\n *\n * // Delete with condition\n * await db\n *   .delete(todos)\n *   .where(and(\n *     eq(todos.userId, userId),\n *     eq(todos.completed, true)\n *   ))\n * ```\n *\n * ## Advanced Queries\n *\n * **JOIN Operations:**\n * ```typescript\n * // Manual join\n * const todosWithAttachments = await db\n *   .select()\n *   .from(todos)\n *   .leftJoin(todoAttachments, eq(todos.id, todoAttachments.todoId))\n *\n * // Relational join\n * const nested = await db.query.todos.findMany({\n *   with: { attachments: true }\n * })\n * ```\n *\n * **Aggregations:**\n * ```typescript\n * // Count\n * const [{ count }] = await db\n *   .select({ count: sql<number>`count(*)::int` })\n *   .from(todos)\n *\n * // Group by\n * const byUser = await db\n *   .select({\n *     userId: todos.userId,\n *     count: sql<number>`count(*)::int`\n *   })\n *   .from(todos)\n *   .groupBy(todos.userId)\n * ```\n *\n * CLOSE: Drizzle Query Examples\n */\n\n/**\n * REF: Database Migrations with Drizzle Kit\n *\n * Schema evolution and version control for your database.\n *\n * ## Migration Workflow\n *\n * | `Step` | `Command` | `Output` | Purpose |\n * |------|---------|--------|---------|\n * | 1. Modify schema | Edit `schema.ts` | `-` | Define changes |\n * | 2. Generate SQL | `npm run db:generate` | `.sql` file | Create migration |\n * | 3. Review SQL | Check `drizzle/` folder | `-` | Verify changes |\n * | 4. Apply migration | `npm run db:push` | Database updated | Deploy changes |\n * | 5. Commit | `git add drizzle/` | `-` | Version control |\n *\n * ## Detailed Steps\n *\n * **1. Generate Migration:**\n * ```bash\n * npm run db:generate\n * #  Creates: drizzle/0001_migration_name.sql\n * #  Creates: drizzle/meta/0001_snapshot.json\n * ```\n *\n * **2. Review Generated SQL:**\n * ```sql\n * -- drizzle/0001_add_tags_column.sql\n * ALTER TABLE todos ADD COLUMN tags TEXT[];\n * CREATE INDEX idx_todos_tags ON todos USING GIN(tags);\n * ```\n *\n * **3. Apply to Database:**\n *\n * Option A - Drizzle Kit:\n * ```bash\n * npm run db:push\n * ```\n *\n * Option B - Supabase Dashboard:\n * 1. Copy SQL from drizzle/ folder\n * 2. Open Supabase SQL Editor\n * 3. Paste and execute\n *\n * ## Migration Best Practices\n *\n * **Always:**\n * - Review generated SQL before applying\n * - Test migrations in development first\n * - Commit migrations to version control\n * - Apply migrations in order (0001, 0002, etc.)\n *\n * **Never:**\n * - Modify applied migration files\n * - Skip migration numbers\n * - Delete meta/ folder\n * - Apply migrations out of order\n *\n * ## Rollback Strategy\n *\n * Drizzle doesn't auto-generate rollbacks. Create manually:\n *\n * ```sql\n * -- Migration: 0002_add_column.sql\n * ALTER TABLE todos ADD COLUMN priority INTEGER;\n *\n * -- Rollback: 0002_rollback.sql (create separately)\n * ALTER TABLE todos DROP COLUMN priority;\n * ```\n *\n * CLOSE: Database Migrations with Drizzle Kit\n */\n",
      "language": "typescript"
    },
    {
      "path": "lib/supabase/client.ts",
      "content": "/**\n * REF: supabase-client-overview\n *\n * # Supabase Client for Authentication and Storage\n *\n * This file provides the Supabase client specifically for authentication and file\n * storage in a hybrid Drizzle + Supabase architecture.\n *\n * ## Hybrid Architecture\n *\n * This project uses a hybrid approach combining the strengths of both libraries:\n *\n * | Feature | `Tool` | `Why` |\n * |---------|------|-----|\n * | Database queries | Drizzle ORM | Perfect type safety, complex queries |\n * | `Authentication` | `Supabase` | Battle-tested, feature-rich auth |\n * | File storage | `Supabase` | Easy uploads, CDN, transformations |\n * | Real-time | `Supabase` | Built-in subscriptions |\n *\n * ## Why Hybrid Approach?\n *\n * ### Drizzle Strengths\n * - Perfect TypeScript inference\n * - SQL-like query syntax\n * - Complex JOINs and queries\n * - Lightweight and fast\n *\n * ### Supabase Strengths\n * - Best-in-class authentication\n * - Easy file uploads and management\n * - Built-in CDN for storage\n * - Real-time subscriptions\n * - OAuth providers integration\n *\n * ### Best of Both Worlds\n * - Type-safe database operations (Drizzle)\n * - Proven authentication system (Supabase)\n * - Easy file management (Supabase)\n * - Each tool excels at what it does best\n *\n * ## File Organization\n *\n * ```\n * lib/\n * ‚îú‚îÄ‚îÄ db/\n * ‚îÇ   ‚îú‚îÄ‚îÄ client.ts    ‚Üê Drizzle for database\n * ‚îÇ   ‚îú‚îÄ‚îÄ schema.ts\n * ‚îÇ   ‚îî‚îÄ‚îÄ queries.ts\n * ‚îî‚îÄ‚îÄ supabase/\n *     ‚îî‚îÄ‚îÄ client.ts    ‚Üê This file - Supabase for auth/storage\n * ```\n */\n// CLOSE: supabase-client-overview\n\n/**\n * REF: supabase-imports\n *\n * ## Import Dependencies\n *\n * ## Supabase SSR Package\n *\n * | `Import` | `Package` | Purpose |\n * |--------|---------|---------|\n * | `createBrowserClient` | @supabase/ssr | Creates client-side Supabase instance |\n *\n * ### Why @supabase/ssr?\n *\n * The SSR package provides:\n * - Automatic cookie handling\n * - Server and client compatibility\n * - Proper session management in Next.js\n * - Works with App Router and Pages Router\n *\n * ### Alternative Imports\n *\n * ```typescript\n * // For server-side (Server Components, API Routes)\n * import { createServerClient } from '@supabase/ssr'\n *\n * // For middleware\n * import { createMiddlewareClient } from '@supabase/ssr'\n * ```\n */\nimport { createBrowserClient } from '@supabase/ssr'\n// CLOSE: supabase-imports\n\n/**\n * REF: create-client-function\n *\n * ## Create Supabase Client\n *\n * Factory function that creates a Supabase browser client instance configured\n * for authentication and storage operations.\n *\n * ## Function Signature\n *\n * ```typescript\n * export const createClient = () => SupabaseClient\n * ```\n *\n * ## Environment Variables\n *\n * | `Variable` | Purpose | Where to Find |\n * |----------|---------|---------------|\n * | `NEXT_PUBLIC_SUPABASE_URL` | Supabase project URL | Dashboard ‚Üí Settings ‚Üí API |\n * | `NEXT_PUBLIC_SUPABASE_ANON_KEY` | Public API key | Dashboard ‚Üí Settings ‚Üí API |\n *\n * ### Environment Variable Setup\n *\n * Create `.env.local` in project root:\n *\n * ```bash\n * NEXT_PUBLIC_SUPABASE_URL=https://[PROJECT_REF].supabase.co\n * NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGc...\n * ```\n *\n * ## Database Types Not Included\n *\n * Unlike pure Supabase projects, we don't pass database types to this client\n * because we use Drizzle for all database operations.\n *\n * ```typescript\n * // Pure Supabase approach (not used here)\n * createBrowserClient<Database>(url, key)\n *\n * // Our approach - no database types needed\n * createBrowserClient(url, key)\n * ```\n *\n * ## Usage Scope\n *\n * Use this client for:\n * - **Authentication**: `supabase.auth.signUp()`, `signIn()`, `signOut()`\n * - **Storage**: `supabase.storage.from('bucket').upload()`\n * - **Real-time**: `supabase.channel().on().subscribe()`\n *\n * Do NOT use for:\n * - **Database queries**: Use Drizzle instead (`db` from lib/db/client.ts)\n *\n * ## Example Usage\n *\n * ```typescript\n * // In a Client Component\n * import { createClient } from '@/lib/supabase/client'\n *\n * export default function LoginForm() {\n *   const supabase = createClient()\n *\n *   const handleLogin = async () => {\n *     const { data, error } = await supabase.auth.signInWithPassword({\n *       email: 'user@example.com',\n *       password: 'password'\n *     })\n *   }\n * }\n * ```\n */\nexport const createClient = () =>\n  createBrowserClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n  )\n// CLOSE: create-client-function\n\n/**\n * REF: when-to-use-comparison\n *\n * ## When to Use Supabase Client vs Drizzle\n *\n * Decision guide for choosing between Supabase client and Drizzle ORM.\n *\n * ## Use Supabase Client For\n *\n * | `Operation` | Why Supabase |\n * |-----------|--------------|\n * | `Authentication` | Built-in, secure, feature-complete |\n * | OAuth providers | Google, GitHub, etc. integration |\n * | File uploads | Easy API, CDN, transformations |\n * | File downloads | Signed URLs, public URLs |\n * | Real-time subscriptions | Built-in change detection |\n * | Simple CRUD (optional) | Quick prototyping |\n *\n * ## Use Drizzle For\n *\n * | `Operation` | Why Drizzle |\n * |-----------|-------------|\n * | Complex queries | SQL-like syntax, better ergonomics |\n * | JOINs across tables | Cleaner than Supabase |\n * | Type safety | Perfect TypeScript inference |\n * | `Transactions` | ACID guarantees |\n * | Schema migrations | Version controlled SQL |\n * | `Aggregations` | COUNT, SUM, AVG, etc. |\n * | Full-text search | PostgreSQL features |\n *\n * ## Hybrid Usage Pattern\n *\n * ```typescript\n * import { createClient } from '@/lib/supabase/client'\n * import { db } from '@/lib/db/client'\n * import { todos } from '@/lib/db/schema'\n * import { eq } from 'drizzle-orm'\n *\n * // 1. Auth with Supabase\n * const supabase = createClient()\n * const { data: { user } } = await supabase.auth.getUser()\n *\n * // 2. Database queries with Drizzle\n * const userTodos = await db\n *   .select()\n *   .from(todos)\n *   .where(eq(todos.userId, user.id))\n *\n * // 3. File storage with Supabase\n * await supabase.storage\n *   .from('attachments')\n *   .upload(path, file)\n *\n * // 4. Real-time with Supabase\n * supabase\n *   .channel('todos')\n *   .on('postgres_changes', { table: 'todos' }, handleChange)\n *   .subscribe()\n * ```\n */\n// CLOSE: when-to-use-comparison\n\n/**\n * REF: authentication-examples\n *\n * ## Authentication Examples\n *\n * Common authentication operations using Supabase Auth.\n *\n * ### Sign Up\n *\n * ```typescript\n * const supabase = createClient()\n *\n * const { data, error } = await supabase.auth.signUp({\n *   email: 'user@example.com',\n *   password: 'password123',\n *   options: {\n *     data: {\n *       display_name: 'John Doe',\n *       avatar_url: 'https://...'\n *     },\n *     emailRedirectTo: 'https://yourapp.com/welcome'\n *   }\n * })\n * ```\n *\n * ### Sign In with Password\n *\n * ```typescript\n * const { data, error } = await supabase.auth.signInWithPassword({\n *   email: 'user@example.com',\n *   password: 'password123'\n * })\n *\n * if (data.user) {\n *   // User signed in successfully\n * }\n * ```\n *\n * ### Sign In with OAuth\n *\n * ```typescript\n * // Google\n * await supabase.auth.signInWithOAuth({\n *   provider: 'google',\n *   options: {\n *     redirectTo: 'https://yourapp.com/auth/callback'\n *   }\n * })\n *\n * // GitHub\n * await supabase.auth.signInWithOAuth({\n *   provider: 'github'\n * })\n * ```\n *\n * ### Sign Out\n *\n * ```typescript\n * await supabase.auth.signOut()\n * ```\n *\n * ### Get Current User\n *\n * ```typescript\n * const { data: { user } } = await supabase.auth.getUser()\n *\n * if (user) {\n *   console.log(user.id)\n *   console.log(user.email)\n *   console.log(user.user_metadata.display_name)\n * }\n * ```\n *\n * ### Get Session\n *\n * ```typescript\n * const { data: { session } } = await supabase.auth.getSession()\n *\n * if (session) {\n *   console.log(session.access_token)\n *   console.log(session.user)\n * }\n * ```\n *\n * ### Password Reset\n *\n * ```typescript\n * // Request reset email\n * await supabase.auth.resetPasswordForEmail('user@example.com', {\n *   redirectTo: 'https://yourapp.com/reset-password'\n * })\n *\n * // Update password (after clicking email link)\n * await supabase.auth.updateUser({\n *   password: 'new-password'\n * })\n * ```\n *\n * ### Listen to Auth Changes\n *\n * ```typescript\n * supabase.auth.onAuthStateChange((event, session) => {\n *   if (event === 'SIGNED_IN') {\n *     console.log('User signed in:', session.user)\n *   }\n *   if (event === 'SIGNED_OUT') {\n *     console.log('User signed out')\n *   }\n * })\n * ```\n */\n// CLOSE: authentication-examples\n\n/**\n * REF: storage-examples\n *\n * ## Storage Examples\n *\n * File upload, download, and management with Supabase Storage.\n *\n * ### Upload File\n *\n * ```typescript\n * const supabase = createClient()\n *\n * const { data, error } = await supabase.storage\n *   .from('attachments')\n *   .upload(`${userId}/${filename}`, file, {\n *     cacheControl: '3600',\n *     upsert: false,  // Don't overwrite existing\n *     contentType: 'image/png'\n *   })\n *\n * if (data) {\n *   console.log('File path:', data.path)\n * }\n * ```\n *\n * ### Get Public URL\n *\n * ```typescript\n * const { data } = supabase.storage\n *   .from('attachments')\n *   .getPublicUrl('user-123/photo.jpg')\n *\n * console.log('Public URL:', data.publicUrl)\n * ```\n *\n * ### Get Signed URL (Temporary Access)\n *\n * ```typescript\n * const { data, error } = await supabase.storage\n *   .from('private-files')\n *   .createSignedUrl('document.pdf', 3600) // Valid for 1 hour\n *\n * console.log('Temporary URL:', data.signedUrl)\n * ```\n *\n * ### Download File\n *\n * ```typescript\n * const { data, error } = await supabase.storage\n *   .from('attachments')\n *   .download('user-123/photo.jpg')\n *\n * if (data) {\n *   // data is a Blob\n *   const url = URL.createObjectURL(data)\n *   // Use the URL for display or download\n * }\n * ```\n *\n * ### List Files in Bucket\n *\n * ```typescript\n * const { data, error } = await supabase.storage\n *   .from('attachments')\n *   .list('user-123/', {\n *     limit: 100,\n *     offset: 0,\n *     sortBy: { column: 'created_at', order: 'desc' }\n *   })\n *\n * data.forEach(file => {\n *   console.log(file.name, file.size, file.created_at)\n * })\n * ```\n *\n * ### Delete File\n *\n * ```typescript\n * await supabase.storage\n *   .from('attachments')\n *   .remove(['user-123/photo.jpg'])\n *\n * // Delete multiple files\n * await supabase.storage\n *   .from('attachments')\n *   .remove([\n *     'user-123/photo1.jpg',\n *     'user-123/photo2.jpg'\n *   ])\n * ```\n *\n * ### Move/Rename File\n *\n * ```typescript\n * await supabase.storage\n *   .from('attachments')\n *   .move('old-path/file.jpg', 'new-path/file.jpg')\n * ```\n *\n * ### Image Transformations\n *\n * ```typescript\n * const { data } = supabase.storage\n *   .from('attachments')\n *   .getPublicUrl('photo.jpg', {\n *     transform: {\n *       width: 300,\n *       height: 300,\n *       resize: 'cover',\n *       format: 'webp',\n *       quality: 80\n *     }\n *   })\n * ```\n */\n// CLOSE: storage-examples\n\n/**\n * REF: realtime-examples\n *\n * ## Real-Time Subscriptions\n *\n * Subscribe to database changes using Supabase Real-time.\n *\n * ### Subscribe to Table Changes\n *\n * ```typescript\n * const supabase = createClient()\n *\n * const channel = supabase\n *   .channel('db-changes')\n *   .on('postgres_changes', {\n *     event: '*',  // INSERT, UPDATE, DELETE, or *\n *     schema: 'public',\n *     table: 'todos',\n *     filter: `user_id=eq.${userId}`\n *   }, (payload) => {\n *     console.log('Change received:', payload)\n *\n *     if (payload.eventType === 'INSERT') {\n *       console.log('New record:', payload.new)\n *     }\n *\n *     if (payload.eventType === 'UPDATE') {\n *       console.log('Old:', payload.old)\n *       console.log('New:', payload.new)\n *     }\n *\n *     if (payload.eventType === 'DELETE') {\n *       console.log('Deleted:', payload.old)\n *     }\n *   })\n *   .subscribe()\n * ```\n *\n * ### Hybrid Pattern: Real-Time + Drizzle\n *\n * Use Supabase for change notifications, Drizzle for type-safe refetch:\n *\n * ```typescript\n * import { getUserTodos } from '@/lib/db/queries'\n *\n * supabase\n *   .channel('todos')\n *   .on('postgres_changes', {\n *     event: '*',\n *     table: 'todos',\n *     filter: `user_id=eq.${userId}`\n *   }, async () => {\n *     // Refetch with Drizzle for type safety\n *     const todos = await getUserTodos(userId)\n *     setTodos(todos)\n *   })\n *   .subscribe()\n * ```\n *\n * ### Cleanup Subscriptions\n *\n * ```typescript\n * // Remove specific channel\n * supabase.removeChannel(channel)\n *\n * // Remove all channels\n * supabase.removeAllChannels()\n * ```\n *\n * ### Benefits\n *\n * - Supabase broadcasts changes in real-time\n * - Drizzle provides type-safe data refetch\n * - Best of both worlds: real-time + type safety\n */\n// CLOSE: realtime-examples\n\n/**\n * REF: architecture-rationale\n *\n * ## Why This Hybrid Architecture?\n *\n * Comparison of different approaches and why the hybrid model wins.\n *\n * ## Problem: Supabase Client Alone\n *\n * | `Issue` | `Impact` |\n * |-------|--------|\n * | Limited type safety | Complex queries lose type information |\n * | Awkward JOINs | Nested selects or multiple queries |\n * | No migration system | Manual SQL or Supabase dashboard |\n * | Query builder limitations | Some SQL features hard to access |\n *\n * ## Problem: Drizzle Alone\n *\n * | `Issue` | `Impact` |\n * |-------|--------|\n * | Build auth from scratch | Time-consuming, security risks |\n * | Implement file storage | Need S3/CDN integration |\n * | Custom real-time | WebSockets, polling, or third-party |\n * | No OAuth integration | Manual provider setup |\n *\n * ## Solution: Hybrid Approach\n *\n * | Benefit | `How` |\n * |---------|-----|\n * | Proven authentication | Supabase handles it |\n * | Easy file management | Supabase Storage + CDN |\n * | Type-safe queries | Drizzle ORM |\n * | Complex database operations | Drizzle query builder |\n * | Real-time updates | Supabase subscriptions |\n * | Each tool excels | Use the right tool for each job |\n *\n * ## The Best of Both Worlds\n *\n * - Supabase: Best-in-class managed services (Auth, Storage, Real-time)\n * - Drizzle: Perfect type safety and powerful queries\n * - Together: Complete, type-safe, production-ready stack\n */\n// CLOSE: architecture-rationale\n\n/**\n * REF: exports\n *\n * ## Module Exports\n *\n * Export the client factory function for use throughout the application.\n */\nexport default createClient\n// CLOSE: exports\n",
      "language": "typescript"
    },
    {
      "path": "package.json",
      "content": "{\n  \"name\": \"nextjs-supabase-drizzle-todo\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"lint\": \"next lint\",\n    \"db:generate\": \"drizzle-kit generate:pg\",\n    \"db:push\": \"drizzle-kit push:pg\",\n    \"db:studio\": \"drizzle-kit studio\"\n  },\n  \"dependencies\": {\n    \"react\": \"^18.3.1\",\n    \"react-dom\": \"^18.3.1\",\n    \"next\": \"^15.0.0\",\n    \"@supabase/supabase-js\": \"^2.38.4\",\n    \"@supabase/ssr\": \"^0.0.10\",\n    \"drizzle-orm\": \"^0.29.1\",\n    \"postgres\": \"^3.4.3\",\n    \"dotenv\": \"^16.3.1\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20\",\n    \"@types/react\": \"^18\",\n    \"@types/react-dom\": \"^18\",\n    \"typescript\": \"^5\",\n    \"tailwindcss\": \"^3.4.1\",\n    \"postcss\": \"^8\",\n    \"autoprefixer\": \"^10.4.16\",\n    \"eslint\": \"^8\",\n    \"eslint-config-next\": \"^15.0.0\",\n    \"drizzle-kit\": \"^0.20.6\"\n  }\n}\n",
      "language": "json"
    },
    {
      "path": "postcss.config.js",
      "content": "/**\n * REF: file-header\n *\n * # PostCSS Configuration\n *\n * Configuration for PostCSS, a tool for transforming CSS with JavaScript plugins.\n *\n * ## What is PostCSS?\n * Tool that processes CSS through JavaScript plugins for:\n * - Modern CSS transformation\n * - Automatic vendor prefixing\n * - CSS optimization\n * - Preprocessor features\n *\n * ## Role in Tailwind\n * PostCSS bridges Tailwind and browser-ready CSS:\n * | `Step` | `Process` |\n * |------|---------|\n * | `1` | Tailwind generates utility CSS |\n * | `2` | PostCSS processes the CSS |\n * | `3` | Autoprefixer adds vendor prefixes |\n * | `4` | Output is browser-ready CSS |\n */\n// CLOSE: file-header\n\n/**\n * REF: module-export\n *\n * ## CommonJS Module Export\n *\n * Exports configuration as CommonJS module (required for PostCSS).\n */\nmodule.exports = {\n  /**\n   * REF: plugins-config\n   *\n   * ## PostCSS Plugins\n   *\n   * Plugins run in specified order.\n   *\n   * ### Execution Order\n   * 1. `tailwindcss`: Generates Tailwind utilities\n   * 2. `autoprefixer`: Adds vendor prefixes\n   *\n   * ### Why Order Matters\n   * Tailwind must generate CSS before autoprefixer can prefix it.\n   */\n  plugins: {\n    /**\n     * REF: tailwindcss-plugin\n     *\n     * ## Tailwind CSS Plugin\n     *\n     * Processes Tailwind directives and generates utility classes.\n     *\n     * ### What It Does\n     * 1. Reads `tailwind.config.ts`\n     * 2. Scans content files for classes\n     * 3. Generates CSS for used utilities\n     * 4. Injects CSS into build\n     *\n     * ### Tailwind Directives\n     * In `globals.css`:\n     * ```css\n     * @tailwind base;       // Base styles, CSS reset\n     * @tailwind components; // Component classes\n     * @tailwind utilities;  // Utility classes\n     * ```\n     *\n     * ### Output Example\n     * Input: `bg-blue-500`\n     * ```css\n     * .bg-blue-500 {\n     *   background-color: rgb(59 130 246);\n     * }\n     * ```\n     *\n     * ### Configuration\n     * Empty object `{}` = use `tailwind.config.ts` settings.\n     */\n    tailwindcss: {},\n    // CLOSE: tailwindcss-plugin\n\n    /**\n     * REF: autoprefixer-plugin\n     *\n     * ## Autoprefixer Plugin\n     *\n     * Automatically adds vendor prefixes to CSS properties.\n     *\n     * ### What It Does\n     * Adds browser-specific prefixes based on:\n     * - Browser targets (from package.json or .browserslistrc)\n     * - Can I Use database for browser support\n     *\n     * ### Vendor Prefixes\n     * | `Prefix` | `Browser` |\n     * |--------|---------|\n     * | `-webkit-` | Chrome, Safari, newer Edge |\n     * | `-moz-` | `Firefox` |\n     * | `-ms-` | Old IE, old Edge |\n     * | `-o-` | Old Opera |\n     *\n     * ### Example Transformation\n     * Input CSS:\n     * ```css\n     * .example {\n     *   display: flex;\n     *   user-select: none;\n     *   backdrop-filter: blur(10px);\n     * }\n     * ```\n     *\n     * Output CSS:\n     * ```css\n     * .example {\n     *   display: -webkit-box;\n     *   display: -ms-flexbox;\n     *   display: flex;\n     *   -webkit-user-select: none;\n     *   -moz-user-select: none;\n     *   -ms-user-select: none;\n     *   user-select: none;\n     *   -webkit-backdrop-filter: blur(10px);\n     *   backdrop-filter: blur(10px);\n     * }\n     * ```\n     *\n     * ### Browser Targets\n     * Default: Last 2 versions of major browsers.\n     *\n     * Customize in `package.json`:\n     * ```json\n     * {\n     *   \"browserslist\": [\n     *     \"> 1%\",\n     *     \"last 2 versions\",\n     *     \"not dead\"\n     *   ]\n     * }\n     * ```\n     *\n     * ### Benefits\n     * - Automatic cross-browser compatibility\n     * - No manual prefix management\n     * - Only adds needed prefixes\n     * - Updates with browser changes\n     *\n     * ### Configuration\n     * Empty object `{}` = use default settings.\n     */\n    autoprefixer: {},\n    // CLOSE: autoprefixer-plugin\n  },\n}\n// CLOSE: plugins-config\n// CLOSE: module-export\n\n/**\n * REF: nextjs-integration\n *\n * ## How PostCSS Integrates with Next.js\n *\n * Next.js automatically uses PostCSS if config exists.\n *\n * ### Build Process Flow\n * 1. **Developer writes Tailwind**\n *    ```tsx\n *    <div className=\"flex items-center gap-4\">\n *    ```\n *\n * 2. **Tailwind generates CSS**\n *    ```css\n *    .flex { display: flex; }\n *    .items-center { align-items: center; }\n *    .gap-4 { gap: 1rem; }\n *    ```\n *\n * 3. **Autoprefixer adds prefixes**\n *    ```css\n *    .flex {\n *      display: -webkit-box;\n *      display: -ms-flexbox;\n *      display: flex;\n *    }\n *    ```\n *\n * 4. **Next.js bundles and optimizes**\n *    - Minifies in production\n *    - Removes unused CSS\n *    - Optimizes for performance\n *\n * ### Development vs Production\n * | `Mode` | `Characteristics` |\n * |------|----------------|\n * | `Development` | Fast, unminified, all utilities |\n * | `Production` | Minified, only used utilities, prefixed |\n */\n// CLOSE: nextjs-integration\n\n/**\n * REF: additional-plugins\n *\n * ## Adding Additional PostCSS Plugins\n *\n * Extend configuration with more plugins.\n *\n * ### cssnano (Minification)\n * ```javascript\n * // Install: npm install cssnano\n * module.exports = {\n *   plugins: {\n *     tailwindcss: {},\n *     autoprefixer: {},\n *     ...(process.env.NODE_ENV === 'production' ? { cssnano: {} } : {})\n *   },\n * }\n * ```\n *\n * ### postcss-nested (Nested CSS)\n * ```javascript\n * // Install: npm install postcss-nested\n * module.exports = {\n *   plugins: {\n *     'postcss-nested': {},\n *     tailwindcss: {},\n *     autoprefixer: {},\n *   },\n * }\n * ```\n *\n * ### postcss-import (CSS Imports)\n * ```javascript\n * // Install: npm install postcss-import\n * module.exports = {\n *   plugins: {\n *     'postcss-import': {},\n *     tailwindcss: {},\n *     autoprefixer: {},\n *   },\n * }\n * ```\n *\n * ### Plugin Order\n * Always maintain correct order:\n * 1. Import/preprocessor plugins first\n * 2. Tailwind in the middle\n * 3. Autoprefixer and optimization last\n */\n// CLOSE: additional-plugins\n\n/**\n * REF: troubleshooting\n *\n * ## Troubleshooting\n *\n * ### Common Issues\n *\n * #### PostCSS not processing\n * - Ensure `postcss.config.js` in project root\n * - Restart Next.js dev server\n * - Check for syntax errors\n *\n * #### Vendor prefixes not added\n * - Check autoprefixer in plugins\n * - Verify browser targets\n * - Ensure autoprefixer after Tailwind\n *\n * #### Tailwind classes not working\n * - Check `tailwind.config.ts` content paths\n * - Ensure Tailwind plugin first\n * - Verify directives in CSS file\n *\n * ### Debug Mode\n * ```javascript\n * module.exports = {\n *   plugins: {\n *     tailwindcss: { config: './tailwind.config.ts' },\n *     autoprefixer: {},\n *   },\n * }\n * ```\n */\n// CLOSE: troubleshooting\n\n/**\n * REF: resources\n *\n * ## Resources\n *\n * ### Official Documentation\n * - PostCSS: https://postcss.org/\n * - Autoprefixer: https://github.com/postcss/autoprefixer\n * - Tailwind PostCSS: https://tailwindcss.com/docs/installation/using-postcss\n *\n * ### Browser Support\n * - Can I Use: https://caniuse.com/\n * - Browserslist: https://browsersl.ist/\n *\n * ### Next.js Integration\n * - CSS Support: https://nextjs.org/docs/basic-features/built-in-css-support\n * - PostCSS Config: https://nextjs.org/docs/advanced-features/customizing-postcss-config\n */\n// CLOSE: resources\n",
      "language": "javascript"
    },
    {
      "path": "tailwind.config.ts",
      "content": "/**\n * REF: file-header\n *\n * # Tailwind CSS Configuration\n *\n * Configuration for Tailwind CSS in the Next.js + Drizzle project.\n *\n * ## What is Tailwind?\n * Utility-first CSS framework that generates styles based on class names.\n *\n * ## How It Works\n * | `Step` | `Process` |\n * |------|---------|\n * | `1` | Scans files in `content` array |\n * | `2` | Finds Tailwind classes (e.g., `bg-blue-500`) |\n * | `3` | Generates only CSS for used classes |\n * | `4` | Results in minimal bundle size |\n *\n * ## Benefits\n * - **JIT**: Just-In-Time compilation for fast builds\n * - **Tree-shaking**: Only includes used styles\n * - **Type-safe**: With TypeScript configuration\n * - **Customizable**: Extend theme as needed\n */\n// CLOSE: file-header\n\n/**\n * REF: imports\n *\n * ## Import TypeScript Types\n *\n * Import `Config` type for type-safe configuration.\n */\nimport type { Config } from 'tailwindcss'\n// CLOSE: imports\n\n/**\n * REF: config-object\n *\n * ## Tailwind Configuration Object\n *\n * Main configuration with TypeScript typing.\n */\nconst config: Config = {\n  /**\n   * REF: content-paths\n   *\n   * ## Content Paths\n   *\n   * Specifies which files Tailwind should scan for class names.\n   *\n   * ### Glob Patterns\n   * | `Pattern` | `Matches` | Purpose |\n   * |---------|---------|---------|\n   * | `./pages/**\\/*.{js,ts,jsx,tsx,mdx}` | Pages directory | Pages Router |\n   * | `./components/**\\/*.{js,ts,jsx,tsx,mdx}` | `Components` | React components |\n   * | `./app/**\\/*.{js,ts,jsx,tsx,mdx}` | App directory | App Router |\n   *\n   * ### File Extensions\n   * - `.js` / `.jsx`: JavaScript/React\n   * - `.ts` / `.tsx`: TypeScript/React\n   * - `.mdx`: Markdown + JSX\n   *\n   * ### Performance\n   * Only scans these paths, generates only needed CSS.\n   *\n   * ### Example Detection\n   * ```tsx\n   * <div className=\"bg-blue-500 text-white p-4 rounded-lg\">\n   *   // Tailwind finds: bg-blue-500, text-white, p-4, rounded-lg\n   * </div>\n   * ```\n   */\n  content: [\n    './pages/**/*.{js,ts,jsx,tsx,mdx}',\n    './components/**/*.{js,ts,jsx,tsx,mdx}',\n    './app/**/*.{js,ts,jsx,tsx,mdx}',\n  ],\n  // CLOSE: content-paths\n\n  /**\n   * REF: theme-config\n   *\n   * ## Theme Configuration\n   *\n   * Customize or extend Tailwind's default theme.\n   *\n   * ### Extend vs Replace\n   * - `extend`: Adds to defaults (recommended)\n   * - Direct properties: Replace defaults\n   *\n   * ### Default Configuration\n   * Empty `extend` uses all Tailwind defaults:\n   * - Color palette (blue, red, green, etc.)\n   * - Spacing scale (1, 2, 4, 8, etc.)\n   * - Breakpoints (sm, md, lg, xl, 2xl)\n   * - Font families\n   *\n   * ### Extending Example\n   * ```typescript\n   * theme: {\n   *   extend: {\n   *     colors: {\n   *       primary: '#3b82f6',\n   *       secondary: '#8b5cf6',\n   *     },\n   *     spacing: {\n   *       '128': '32rem',\n   *     },\n   *     fontFamily: {\n   *       custom: ['Inter', 'sans-serif'],\n   *     },\n   *   },\n   * }\n   * ```\n   *\n   * ### Usage After Extending\n   * ```tsx\n   * <div className=\"bg-primary text-secondary p-128 font-custom\" />\n   * ```\n   */\n  theme: {\n    extend: {},\n  },\n  // CLOSE: theme-config\n\n  /**\n   * REF: plugins-config\n   *\n   * ## Plugins Configuration\n   *\n   * Array of Tailwind plugins for additional functionality.\n   *\n   * ### What Are Plugins?\n   * Add new utilities, components, or features to Tailwind.\n   *\n   * ### Popular Plugins\n   * | `Plugin` | Purpose |\n   * |--------|---------|\n   * | `@tailwindcss/forms` | Better form styling |\n   * | `@tailwindcss/typography` | Prose/markdown styling |\n   * | `@tailwindcss/aspect-ratio` | Aspect ratio utilities |\n   * | `@tailwindcss/line-clamp` | Line clamping |\n   *\n   * ### Adding Plugins\n   * ```bash\n   * npm install @tailwindcss/forms\n   * ```\n   * ```typescript\n   * import forms from '@tailwindcss/forms'\n   *\n   * plugins: [forms],\n   * ```\n   *\n   * ### Default\n   * Empty array = no additional plugins, all default utilities available.\n   */\n  plugins: [],\n  // CLOSE: plugins-config\n}\n// CLOSE: config-object\n\n/**\n * REF: export\n *\n * ## Export Configuration\n *\n * Export config for Next.js and Tailwind to use automatically.\n */\nexport default config\n// CLOSE: export\n\n/**\n * REF: usage-patterns\n *\n * ## Common Tailwind Patterns in Project\n *\n * Examples of Tailwind usage throughout the codebase.\n *\n * ### Layout Classes\n * ```tsx\n * // Flexbox\n * <div className=\"flex items-center justify-between gap-4\">\n *\n * // Grid\n * <div className=\"grid grid-cols-3 gap-6\">\n *\n * // Spacing\n * <div className=\"p-4 m-2 space-y-3\">\n * ```\n *\n * ### Styling Classes\n * ```tsx\n * // Colors\n * <div className=\"bg-blue-500 text-white\">\n *\n * // Typography\n * <h1 className=\"text-2xl font-bold\">\n *\n * // Borders\n * <div className=\"border border-gray-300 rounded-lg\">\n * ```\n *\n * ### Responsive Classes\n * ```tsx\n * // Mobile-first breakpoints\n * <div className=\"w-full md:w-1/2 lg:w-1/3\">\n * // Full width mobile, half tablet, third desktop\n * ```\n *\n * ### Dark Mode Classes\n * ```tsx\n * <div className=\"bg-white dark:bg-gray-800 text-black dark:text-white\">\n * ```\n *\n * ### State Classes\n * ```tsx\n * <button className=\"bg-blue-500 hover:bg-blue-700 focus:ring-2 active:scale-95\">\n * ```\n */\n// CLOSE: usage-patterns\n\n/**\n * REF: performance-notes\n *\n * ## Performance Optimizations\n *\n * Tailwind automatically optimizes CSS output.\n *\n * ### JIT Mode\n * - Generates styles on-demand\n * - Faster build times\n * - Smaller CSS bundles\n * - Arbitrary value support (e.g., `w-[73px]`)\n *\n * ### Production Build\n * ```bash\n * npm run build\n * ```\n * - Removes unused CSS\n * - Minifies output\n * - Optimizes for performance\n *\n * ### Bundle Size\n * | `Environment` | CSS Size |\n * |-------------|----------|\n * | `Development` | All utilities available |\n * | `Production` | Only used utilities |\n * | `Typical` | 10-50KB gzipped |\n */\n// CLOSE: performance-notes\n\n/**\n * REF: resources\n *\n * ## Customization Resources\n *\n * ### Official Documentation\n * - Main docs: https://tailwindcss.com/docs\n * - Configuration: https://tailwindcss.com/docs/configuration\n * - Theme: https://tailwindcss.com/docs/theme\n * - Plugins: https://tailwindcss.com/docs/plugins\n * - Dark Mode: https://tailwindcss.com/docs/dark-mode\n *\n * ### VS Code Extension\n * **Tailwind CSS IntelliSense**\n * - Class name autocomplete\n * - CSS value preview on hover\n * - Class name validation\n * - Syntax highlighting\n */\n// CLOSE: resources\n",
      "language": "typescript"
    },
    {
      "path": "tsconfig.json",
      "content": "{\n  \"compilerOptions\": {\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\",\n    \"incremental\": true,\n    \"plugins\": [\n      {\n        \"name\": \"next\"\n      }\n    ],\n    \"paths\": {\n      \"@/*\": [\"./*\"]\n    }\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\", \".next/types/**/*.ts\"],\n  \"exclude\": [\"node_modules\"]\n}\n",
      "language": "json"
    }
  ]
}